/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/obsidian-dataview/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-dataview/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require("obsidian");
    var LuxonError2 = class extends Error {
    };
    var InvalidDateTimeError2 = class extends LuxonError2 {
      constructor(reason) {
        super(`Invalid DateTime: ${reason.toMessage()}`);
      }
    };
    var InvalidIntervalError2 = class extends LuxonError2 {
      constructor(reason) {
        super(`Invalid Interval: ${reason.toMessage()}`);
      }
    };
    var InvalidDurationError2 = class extends LuxonError2 {
      constructor(reason) {
        super(`Invalid Duration: ${reason.toMessage()}`);
      }
    };
    var ConflictingSpecificationError2 = class extends LuxonError2 {
    };
    var InvalidUnitError2 = class extends LuxonError2 {
      constructor(unit) {
        super(`Invalid unit ${unit}`);
      }
    };
    var InvalidArgumentError2 = class extends LuxonError2 {
    };
    var ZoneIsAbstractError2 = class extends LuxonError2 {
      constructor() {
        super("Zone is an abstract class");
      }
    };
    var n2 = "numeric";
    var s2 = "short";
    var l2 = "long";
    var DATE_SHORT2 = {
      year: n2,
      month: n2,
      day: n2
    };
    var DATE_MED2 = {
      year: n2,
      month: s2,
      day: n2
    };
    var DATE_MED_WITH_WEEKDAY2 = {
      year: n2,
      month: s2,
      day: n2,
      weekday: s2
    };
    var DATE_FULL2 = {
      year: n2,
      month: l2,
      day: n2
    };
    var DATE_HUGE2 = {
      year: n2,
      month: l2,
      day: n2,
      weekday: l2
    };
    var TIME_SIMPLE2 = {
      hour: n2,
      minute: n2
    };
    var TIME_WITH_SECONDS2 = {
      hour: n2,
      minute: n2,
      second: n2
    };
    var TIME_WITH_SHORT_OFFSET2 = {
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: s2
    };
    var TIME_WITH_LONG_OFFSET2 = {
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: l2
    };
    var TIME_24_SIMPLE2 = {
      hour: n2,
      minute: n2,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SECONDS2 = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SHORT_OFFSET2 = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23",
      timeZoneName: s2
    };
    var TIME_24_WITH_LONG_OFFSET2 = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23",
      timeZoneName: l2
    };
    var DATETIME_SHORT2 = {
      year: n2,
      month: n2,
      day: n2,
      hour: n2,
      minute: n2
    };
    var DATETIME_SHORT_WITH_SECONDS2 = {
      year: n2,
      month: n2,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2
    };
    var DATETIME_MED2 = {
      year: n2,
      month: s2,
      day: n2,
      hour: n2,
      minute: n2
    };
    var DATETIME_MED_WITH_SECONDS2 = {
      year: n2,
      month: s2,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2
    };
    var DATETIME_MED_WITH_WEEKDAY2 = {
      year: n2,
      month: s2,
      day: n2,
      weekday: s2,
      hour: n2,
      minute: n2
    };
    var DATETIME_FULL2 = {
      year: n2,
      month: l2,
      day: n2,
      hour: n2,
      minute: n2,
      timeZoneName: s2
    };
    var DATETIME_FULL_WITH_SECONDS2 = {
      year: n2,
      month: l2,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: s2
    };
    var DATETIME_HUGE2 = {
      year: n2,
      month: l2,
      day: n2,
      weekday: l2,
      hour: n2,
      minute: n2,
      timeZoneName: l2
    };
    var DATETIME_HUGE_WITH_SECONDS2 = {
      year: n2,
      month: l2,
      day: n2,
      weekday: l2,
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: l2
    };
    var Zone2 = class {
      /**
       * The type of zone
       * @abstract
       * @type {string}
       */
      get type() {
        throw new ZoneIsAbstractError2();
      }
      /**
       * The name of this zone.
       * @abstract
       * @type {string}
       */
      get name() {
        throw new ZoneIsAbstractError2();
      }
      get ianaName() {
        return this.name;
      }
      /**
       * Returns whether the offset is known to be fixed for the whole year.
       * @abstract
       * @type {boolean}
       */
      get isUniversal() {
        throw new ZoneIsAbstractError2();
      }
      /**
       * Returns the offset's common name (such as EST) at the specified timestamp
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the name
       * @param {Object} opts - Options to affect the format
       * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
       * @param {string} opts.locale - What locale to return the offset name in.
       * @return {string}
       */
      offsetName(ts, opts) {
        throw new ZoneIsAbstractError2();
      }
      /**
       * Returns the offset's value as a string
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the offset
       * @param {string} format - What style of offset to return.
       *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
       * @return {string}
       */
      formatOffset(ts, format) {
        throw new ZoneIsAbstractError2();
      }
      /**
       * Return the offset in minutes for this zone at the specified timestamp.
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to compute the offset
       * @return {number}
       */
      offset(ts) {
        throw new ZoneIsAbstractError2();
      }
      /**
       * Return whether this Zone is equal to another zone
       * @abstract
       * @param {Zone} otherZone - the zone to compare
       * @return {boolean}
       */
      equals(otherZone) {
        throw new ZoneIsAbstractError2();
      }
      /**
       * Return whether this Zone is valid.
       * @abstract
       * @type {boolean}
       */
      get isValid() {
        throw new ZoneIsAbstractError2();
      }
    };
    var singleton$1 = null;
    var SystemZone2 = class _SystemZone extends Zone2 {
      /**
       * Get a singleton instance of the local zone
       * @return {SystemZone}
       */
      static get instance() {
        if (singleton$1 === null) {
          singleton$1 = new _SystemZone();
        }
        return singleton$1;
      }
      /** @override **/
      get type() {
        return "system";
      }
      /** @override **/
      get name() {
        return new Intl.DateTimeFormat().resolvedOptions().timeZone;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format, locale }) {
        return parseZoneInfo2(ts, format, locale);
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset2(this.offset(ts), format);
      }
      /** @override **/
      offset(ts) {
        return -new Date(ts).getTimezoneOffset();
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "system";
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var dtfCache2 = {};
    function makeDTF2(zone) {
      if (!dtfCache2[zone]) {
        dtfCache2[zone] = new Intl.DateTimeFormat("en-US", {
          hour12: false,
          timeZone: zone,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          era: "short"
        });
      }
      return dtfCache2[zone];
    }
    var typeToPos2 = {
      year: 0,
      month: 1,
      day: 2,
      era: 3,
      hour: 4,
      minute: 5,
      second: 6
    };
    function hackyOffset2(dtf, date) {
      const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
      return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
    }
    function partsOffset2(dtf, date) {
      const formatted = dtf.formatToParts(date);
      const filled = [];
      for (let i = 0; i < formatted.length; i++) {
        const { type, value } = formatted[i];
        const pos = typeToPos2[type];
        if (type === "era") {
          filled[pos] = value;
        } else if (!isUndefined2(pos)) {
          filled[pos] = parseInt(value, 10);
        }
      }
      return filled;
    }
    var ianaZoneCache2 = {};
    var IANAZone2 = class _IANAZone extends Zone2 {
      /**
       * @param {string} name - Zone name
       * @return {IANAZone}
       */
      static create(name) {
        if (!ianaZoneCache2[name]) {
          ianaZoneCache2[name] = new _IANAZone(name);
        }
        return ianaZoneCache2[name];
      }
      /**
       * Reset local caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCache() {
        ianaZoneCache2 = {};
        dtfCache2 = {};
      }
      /**
       * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
       * @param {string} s - The string to check validity on
       * @example IANAZone.isValidSpecifier("America/New_York") //=> true
       * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
       * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
       * @return {boolean}
       */
      static isValidSpecifier(s3) {
        return this.isValidZone(s3);
      }
      /**
       * Returns whether the provided string identifies a real zone
       * @param {string} zone - The string to check
       * @example IANAZone.isValidZone("America/New_York") //=> true
       * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
       * @example IANAZone.isValidZone("Sport~~blorp") //=> false
       * @return {boolean}
       */
      static isValidZone(zone) {
        if (!zone) {
          return false;
        }
        try {
          new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
          return true;
        } catch (e) {
          return false;
        }
      }
      constructor(name) {
        super();
        this.zoneName = name;
        this.valid = _IANAZone.isValidZone(name);
      }
      /** @override **/
      get type() {
        return "iana";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format, locale }) {
        return parseZoneInfo2(ts, format, locale, this.name);
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset2(this.offset(ts), format);
      }
      /** @override **/
      offset(ts) {
        const date = new Date(ts);
        if (isNaN(date))
          return NaN;
        const dtf = makeDTF2(this.name);
        let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset2(dtf, date) : hackyOffset2(dtf, date);
        if (adOrBc === "BC") {
          year = -Math.abs(year) + 1;
        }
        const adjustedHour = hour === 24 ? 0 : hour;
        const asUTC = objToLocalTS2({
          year,
          month,
          day,
          hour: adjustedHour,
          minute,
          second,
          millisecond: 0
        });
        let asTS = +date;
        const over = asTS % 1e3;
        asTS -= over >= 0 ? over : 1e3 + over;
        return (asUTC - asTS) / (60 * 1e3);
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "iana" && otherZone.name === this.name;
      }
      /** @override **/
      get isValid() {
        return this.valid;
      }
    };
    var intlLFCache2 = {};
    function getCachedLF2(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlLFCache2[key];
      if (!dtf) {
        dtf = new Intl.ListFormat(locString, opts);
        intlLFCache2[key] = dtf;
      }
      return dtf;
    }
    var intlDTCache2 = {};
    function getCachedDTF2(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlDTCache2[key];
      if (!dtf) {
        dtf = new Intl.DateTimeFormat(locString, opts);
        intlDTCache2[key] = dtf;
      }
      return dtf;
    }
    var intlNumCache2 = {};
    function getCachedINF2(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let inf = intlNumCache2[key];
      if (!inf) {
        inf = new Intl.NumberFormat(locString, opts);
        intlNumCache2[key] = inf;
      }
      return inf;
    }
    var intlRelCache2 = {};
    function getCachedRTF2(locString, opts = {}) {
      const { base, ...cacheKeyOpts } = opts;
      const key = JSON.stringify([locString, cacheKeyOpts]);
      let inf = intlRelCache2[key];
      if (!inf) {
        inf = new Intl.RelativeTimeFormat(locString, opts);
        intlRelCache2[key] = inf;
      }
      return inf;
    }
    var sysLocaleCache2 = null;
    function systemLocale2() {
      if (sysLocaleCache2) {
        return sysLocaleCache2;
      } else {
        sysLocaleCache2 = new Intl.DateTimeFormat().resolvedOptions().locale;
        return sysLocaleCache2;
      }
    }
    function parseLocaleString2(localeStr) {
      const xIndex = localeStr.indexOf("-x-");
      if (xIndex !== -1) {
        localeStr = localeStr.substring(0, xIndex);
      }
      const uIndex = localeStr.indexOf("-u-");
      if (uIndex === -1) {
        return [localeStr];
      } else {
        let options;
        let selectedStr;
        try {
          options = getCachedDTF2(localeStr).resolvedOptions();
          selectedStr = localeStr;
        } catch (e) {
          const smaller = localeStr.substring(0, uIndex);
          options = getCachedDTF2(smaller).resolvedOptions();
          selectedStr = smaller;
        }
        const { numberingSystem, calendar } = options;
        return [selectedStr, numberingSystem, calendar];
      }
    }
    function intlConfigString2(localeStr, numberingSystem, outputCalendar) {
      if (outputCalendar || numberingSystem) {
        if (!localeStr.includes("-u-")) {
          localeStr += "-u";
        }
        if (outputCalendar) {
          localeStr += `-ca-${outputCalendar}`;
        }
        if (numberingSystem) {
          localeStr += `-nu-${numberingSystem}`;
        }
        return localeStr;
      } else {
        return localeStr;
      }
    }
    function mapMonths2(f) {
      const ms = [];
      for (let i = 1; i <= 12; i++) {
        const dt = DateTime2.utc(2009, i, 1);
        ms.push(f(dt));
      }
      return ms;
    }
    function mapWeekdays2(f) {
      const ms = [];
      for (let i = 1; i <= 7; i++) {
        const dt = DateTime2.utc(2016, 11, 13 + i);
        ms.push(f(dt));
      }
      return ms;
    }
    function listStuff2(loc, length, englishFn, intlFn) {
      const mode = loc.listingMode();
      if (mode === "error") {
        return null;
      } else if (mode === "en") {
        return englishFn(length);
      } else {
        return intlFn(length);
      }
    }
    function supportsFastNumbers2(loc) {
      if (loc.numberingSystem && loc.numberingSystem !== "latn") {
        return false;
      } else {
        return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
      }
    }
    var PolyNumberFormatter2 = class {
      constructor(intl, forceSimple, opts) {
        this.padTo = opts.padTo || 0;
        this.floor = opts.floor || false;
        const { padTo, floor, ...otherOpts } = opts;
        if (!forceSimple || Object.keys(otherOpts).length > 0) {
          const intlOpts = { useGrouping: false, ...opts };
          if (opts.padTo > 0)
            intlOpts.minimumIntegerDigits = opts.padTo;
          this.inf = getCachedINF2(intl, intlOpts);
        }
      }
      format(i) {
        if (this.inf) {
          const fixed = this.floor ? Math.floor(i) : i;
          return this.inf.format(fixed);
        } else {
          const fixed = this.floor ? Math.floor(i) : roundTo2(i, 3);
          return padStart2(fixed, this.padTo);
        }
      }
    };
    var PolyDateFormatter2 = class {
      constructor(dt, intl, opts) {
        this.opts = opts;
        this.originalZone = void 0;
        let z2 = void 0;
        if (this.opts.timeZone) {
          this.dt = dt;
        } else if (dt.zone.type === "fixed") {
          const gmtOffset = -1 * (dt.offset / 60);
          const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
          if (dt.offset !== 0 && IANAZone2.create(offsetZ).valid) {
            z2 = offsetZ;
            this.dt = dt;
          } else {
            z2 = "UTC";
            this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
            this.originalZone = dt.zone;
          }
        } else if (dt.zone.type === "system") {
          this.dt = dt;
        } else if (dt.zone.type === "iana") {
          this.dt = dt;
          z2 = dt.zone.name;
        } else {
          z2 = "UTC";
          this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
          this.originalZone = dt.zone;
        }
        const intlOpts = { ...this.opts };
        intlOpts.timeZone = intlOpts.timeZone || z2;
        this.dtf = getCachedDTF2(intl, intlOpts);
      }
      format() {
        if (this.originalZone) {
          return this.formatToParts().map(({ value }) => value).join("");
        }
        return this.dtf.format(this.dt.toJSDate());
      }
      formatToParts() {
        const parts = this.dtf.formatToParts(this.dt.toJSDate());
        if (this.originalZone) {
          return parts.map((part) => {
            if (part.type === "timeZoneName") {
              const offsetName = this.originalZone.offsetName(this.dt.ts, {
                locale: this.dt.locale,
                format: this.opts.timeZoneName
              });
              return {
                ...part,
                value: offsetName
              };
            } else {
              return part;
            }
          });
        }
        return parts;
      }
      resolvedOptions() {
        return this.dtf.resolvedOptions();
      }
    };
    var PolyRelFormatter2 = class {
      constructor(intl, isEnglish, opts) {
        this.opts = { style: "long", ...opts };
        if (!isEnglish && hasRelative2()) {
          this.rtf = getCachedRTF2(intl, opts);
        }
      }
      format(count, unit) {
        if (this.rtf) {
          return this.rtf.format(count, unit);
        } else {
          return formatRelativeTime2(unit, count, this.opts.numeric, this.opts.style !== "long");
        }
      }
      formatToParts(count, unit) {
        if (this.rtf) {
          return this.rtf.formatToParts(count, unit);
        } else {
          return [];
        }
      }
    };
    var Locale2 = class _Locale {
      static fromOpts(opts) {
        return _Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
      }
      static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
        const specifiedLocale = locale || Settings2.defaultLocale;
        const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale2());
        const numberingSystemR = numberingSystem || Settings2.defaultNumberingSystem;
        const outputCalendarR = outputCalendar || Settings2.defaultOutputCalendar;
        return new _Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
      }
      static resetCache() {
        sysLocaleCache2 = null;
        intlDTCache2 = {};
        intlNumCache2 = {};
        intlRelCache2 = {};
      }
      static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
        return _Locale.create(locale, numberingSystem, outputCalendar);
      }
      constructor(locale, numbering, outputCalendar, specifiedLocale) {
        const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString2(locale);
        this.locale = parsedLocale;
        this.numberingSystem = numbering || parsedNumberingSystem || null;
        this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
        this.intl = intlConfigString2(this.locale, this.numberingSystem, this.outputCalendar);
        this.weekdaysCache = { format: {}, standalone: {} };
        this.monthsCache = { format: {}, standalone: {} };
        this.meridiemCache = null;
        this.eraCache = {};
        this.specifiedLocale = specifiedLocale;
        this.fastNumbersCached = null;
      }
      get fastNumbers() {
        if (this.fastNumbersCached == null) {
          this.fastNumbersCached = supportsFastNumbers2(this);
        }
        return this.fastNumbersCached;
      }
      listingMode() {
        const isActuallyEn = this.isEnglish();
        const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        return isActuallyEn && hasNoWeirdness ? "en" : "intl";
      }
      clone(alts) {
        if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
          return this;
        } else {
          return _Locale.create(
            alts.locale || this.specifiedLocale,
            alts.numberingSystem || this.numberingSystem,
            alts.outputCalendar || this.outputCalendar,
            alts.defaultToEN || false
          );
        }
      }
      redefaultToEN(alts = {}) {
        return this.clone({ ...alts, defaultToEN: true });
      }
      redefaultToSystem(alts = {}) {
        return this.clone({ ...alts, defaultToEN: false });
      }
      months(length, format = false) {
        return listStuff2(this, length, months2, () => {
          const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
          if (!this.monthsCache[formatStr][length]) {
            this.monthsCache[formatStr][length] = mapMonths2((dt) => this.extract(dt, intl, "month"));
          }
          return this.monthsCache[formatStr][length];
        });
      }
      weekdays(length, format = false) {
        return listStuff2(this, length, weekdays2, () => {
          const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
          if (!this.weekdaysCache[formatStr][length]) {
            this.weekdaysCache[formatStr][length] = mapWeekdays2(
              (dt) => this.extract(dt, intl, "weekday")
            );
          }
          return this.weekdaysCache[formatStr][length];
        });
      }
      meridiems() {
        return listStuff2(
          this,
          void 0,
          () => meridiems2,
          () => {
            if (!this.meridiemCache) {
              const intl = { hour: "numeric", hourCycle: "h12" };
              this.meridiemCache = [DateTime2.utc(2016, 11, 13, 9), DateTime2.utc(2016, 11, 13, 19)].map(
                (dt) => this.extract(dt, intl, "dayperiod")
              );
            }
            return this.meridiemCache;
          }
        );
      }
      eras(length) {
        return listStuff2(this, length, eras2, () => {
          const intl = { era: length };
          if (!this.eraCache[length]) {
            this.eraCache[length] = [DateTime2.utc(-40, 1, 1), DateTime2.utc(2017, 1, 1)].map(
              (dt) => this.extract(dt, intl, "era")
            );
          }
          return this.eraCache[length];
        });
      }
      extract(dt, intlOpts, field) {
        const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
        return matching ? matching.value : null;
      }
      numberFormatter(opts = {}) {
        return new PolyNumberFormatter2(this.intl, opts.forceSimple || this.fastNumbers, opts);
      }
      dtFormatter(dt, intlOpts = {}) {
        return new PolyDateFormatter2(dt, this.intl, intlOpts);
      }
      relFormatter(opts = {}) {
        return new PolyRelFormatter2(this.intl, this.isEnglish(), opts);
      }
      listFormatter(opts = {}) {
        return getCachedLF2(this.intl, opts);
      }
      isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
      }
      equals(other) {
        return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
      }
    };
    var singleton3 = null;
    var FixedOffsetZone2 = class _FixedOffsetZone extends Zone2 {
      /**
       * Get a singleton instance of UTC
       * @return {FixedOffsetZone}
       */
      static get utcInstance() {
        if (singleton3 === null) {
          singleton3 = new _FixedOffsetZone(0);
        }
        return singleton3;
      }
      /**
       * Get an instance with a specified offset
       * @param {number} offset - The offset in minutes
       * @return {FixedOffsetZone}
       */
      static instance(offset3) {
        return offset3 === 0 ? _FixedOffsetZone.utcInstance : new _FixedOffsetZone(offset3);
      }
      /**
       * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
       * @param {string} s - The offset string to parse
       * @example FixedOffsetZone.parseSpecifier("UTC+6")
       * @example FixedOffsetZone.parseSpecifier("UTC+06")
       * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
       * @return {FixedOffsetZone}
       */
      static parseSpecifier(s3) {
        if (s3) {
          const r = s3.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
          if (r) {
            return new _FixedOffsetZone(signedOffset2(r[1], r[2]));
          }
        }
        return null;
      }
      constructor(offset3) {
        super();
        this.fixed = offset3;
      }
      /** @override **/
      get type() {
        return "fixed";
      }
      /** @override **/
      get name() {
        return this.fixed === 0 ? "UTC" : `UTC${formatOffset2(this.fixed, "narrow")}`;
      }
      get ianaName() {
        if (this.fixed === 0) {
          return "Etc/UTC";
        } else {
          return `Etc/GMT${formatOffset2(-this.fixed, "narrow")}`;
        }
      }
      /** @override **/
      offsetName() {
        return this.name;
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset2(this.fixed, format);
      }
      /** @override **/
      get isUniversal() {
        return true;
      }
      /** @override **/
      offset() {
        return this.fixed;
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var InvalidZone2 = class extends Zone2 {
      constructor(zoneName) {
        super();
        this.zoneName = zoneName;
      }
      /** @override **/
      get type() {
        return "invalid";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName() {
        return null;
      }
      /** @override **/
      formatOffset() {
        return "";
      }
      /** @override **/
      offset() {
        return NaN;
      }
      /** @override **/
      equals() {
        return false;
      }
      /** @override **/
      get isValid() {
        return false;
      }
    };
    function normalizeZone2(input, defaultZone3) {
      if (isUndefined2(input) || input === null) {
        return defaultZone3;
      } else if (input instanceof Zone2) {
        return input;
      } else if (isString2(input)) {
        const lowered = input.toLowerCase();
        if (lowered === "default")
          return defaultZone3;
        else if (lowered === "local" || lowered === "system")
          return SystemZone2.instance;
        else if (lowered === "utc" || lowered === "gmt")
          return FixedOffsetZone2.utcInstance;
        else
          return FixedOffsetZone2.parseSpecifier(lowered) || IANAZone2.create(input);
      } else if (isNumber2(input)) {
        return FixedOffsetZone2.instance(input);
      } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
        return input;
      } else {
        return new InvalidZone2(input);
      }
    }
    var now3 = () => Date.now();
    var defaultZone2 = "system";
    var defaultLocale2 = null;
    var defaultNumberingSystem2 = null;
    var defaultOutputCalendar2 = null;
    var twoDigitCutoffYear2 = 60;
    var throwOnInvalid2;
    var Settings2 = class {
      /**
       * Get the callback for returning the current timestamp.
       * @type {function}
       */
      static get now() {
        return now3;
      }
      /**
       * Set the callback for returning the current timestamp.
       * The function should return a number, which will be interpreted as an Epoch millisecond count
       * @type {function}
       * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
       * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
       */
      static set now(n3) {
        now3 = n3;
      }
      /**
       * Set the default time zone to create DateTimes in. Does not affect existing instances.
       * Use the value "system" to reset this value to the system's time zone.
       * @type {string}
       */
      static set defaultZone(zone) {
        defaultZone2 = zone;
      }
      /**
       * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
       * The default value is the system's time zone (the one set on the machine that runs this code).
       * @type {Zone}
       */
      static get defaultZone() {
        return normalizeZone2(defaultZone2, SystemZone2.instance);
      }
      /**
       * Get the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultLocale() {
        return defaultLocale2;
      }
      /**
       * Set the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultLocale(locale) {
        defaultLocale2 = locale;
      }
      /**
       * Get the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultNumberingSystem() {
        return defaultNumberingSystem2;
      }
      /**
       * Set the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultNumberingSystem(numberingSystem) {
        defaultNumberingSystem2 = numberingSystem;
      }
      /**
       * Get the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultOutputCalendar() {
        return defaultOutputCalendar2;
      }
      /**
       * Set the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultOutputCalendar(outputCalendar) {
        defaultOutputCalendar2 = outputCalendar;
      }
      /**
       * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       */
      static get twoDigitCutoffYear() {
        return twoDigitCutoffYear2;
      }
      /**
       * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
       * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
       * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
       * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
       */
      static set twoDigitCutoffYear(cutoffYear) {
        twoDigitCutoffYear2 = cutoffYear % 100;
      }
      /**
       * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static get throwOnInvalid() {
        return throwOnInvalid2;
      }
      /**
       * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static set throwOnInvalid(t) {
        throwOnInvalid2 = t;
      }
      /**
       * Reset Luxon's global caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCaches() {
        Locale2.resetCache();
        IANAZone2.resetCache();
      }
    };
    function isUndefined2(o) {
      return typeof o === "undefined";
    }
    function isNumber2(o) {
      return typeof o === "number";
    }
    function isInteger2(o) {
      return typeof o === "number" && o % 1 === 0;
    }
    function isString2(o) {
      return typeof o === "string";
    }
    function isDate2(o) {
      return Object.prototype.toString.call(o) === "[object Date]";
    }
    function hasRelative2() {
      try {
        return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
      } catch (e) {
        return false;
      }
    }
    function maybeArray2(thing) {
      return Array.isArray(thing) ? thing : [thing];
    }
    function bestBy2(arr, by, compare) {
      if (arr.length === 0) {
        return void 0;
      }
      return arr.reduce((best, next) => {
        const pair = [by(next), next];
        if (!best) {
          return pair;
        } else if (compare(best[0], pair[0]) === best[0]) {
          return best;
        } else {
          return pair;
        }
      }, null)[1];
    }
    function pick2(obj, keys) {
      return keys.reduce((a, k) => {
        a[k] = obj[k];
        return a;
      }, {});
    }
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function integerBetween2(thing, bottom, top) {
      return isInteger2(thing) && thing >= bottom && thing <= top;
    }
    function floorMod2(x, n3) {
      return x - n3 * Math.floor(x / n3);
    }
    function padStart2(input, n3 = 2) {
      const isNeg = input < 0;
      let padded;
      if (isNeg) {
        padded = "-" + ("" + -input).padStart(n3, "0");
      } else {
        padded = ("" + input).padStart(n3, "0");
      }
      return padded;
    }
    function parseInteger2(string) {
      if (isUndefined2(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseInt(string, 10);
      }
    }
    function parseFloating2(string) {
      if (isUndefined2(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseFloat(string);
      }
    }
    function parseMillis2(fraction) {
      if (isUndefined2(fraction) || fraction === null || fraction === "") {
        return void 0;
      } else {
        const f = parseFloat("0." + fraction) * 1e3;
        return Math.floor(f);
      }
    }
    function roundTo2(number, digits, towardZero = false) {
      const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
      return rounder(number * factor) / factor;
    }
    function isLeapYear2(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function daysInYear2(year) {
      return isLeapYear2(year) ? 366 : 365;
    }
    function daysInMonth2(year, month) {
      const modMonth = floorMod2(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
      if (modMonth === 2) {
        return isLeapYear2(modYear) ? 29 : 28;
      } else {
        return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
      }
    }
    function objToLocalTS2(obj) {
      let d = Date.UTC(
        obj.year,
        obj.month - 1,
        obj.day,
        obj.hour,
        obj.minute,
        obj.second,
        obj.millisecond
      );
      if (obj.year < 100 && obj.year >= 0) {
        d = new Date(d);
        d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
      }
      return +d;
    }
    function weeksInWeekYear2(weekYear) {
      const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
      return p1 === 4 || p2 === 3 ? 53 : 52;
    }
    function untruncateYear2(year) {
      if (year > 99) {
        return year;
      } else
        return year > Settings2.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
    }
    function parseZoneInfo2(ts, offsetFormat, locale, timeZone = null) {
      const date = new Date(ts), intlOpts = {
        hourCycle: "h23",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      };
      if (timeZone) {
        intlOpts.timeZone = timeZone;
      }
      const modified = { timeZoneName: offsetFormat, ...intlOpts };
      const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
      return parsed ? parsed.value : null;
    }
    function signedOffset2(offHourStr, offMinuteStr) {
      let offHour = parseInt(offHourStr, 10);
      if (Number.isNaN(offHour)) {
        offHour = 0;
      }
      const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
      return offHour * 60 + offMinSigned;
    }
    function asNumber2(value) {
      const numericValue = Number(value);
      if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
        throw new InvalidArgumentError2(`Invalid unit value ${value}`);
      return numericValue;
    }
    function normalizeObject2(obj, normalizer) {
      const normalized = {};
      for (const u in obj) {
        if (hasOwnProperty2(obj, u)) {
          const v = obj[u];
          if (v === void 0 || v === null)
            continue;
          normalized[normalizer(u)] = asNumber2(v);
        }
      }
      return normalized;
    }
    function formatOffset2(offset3, format) {
      const hours = Math.trunc(Math.abs(offset3 / 60)), minutes = Math.trunc(Math.abs(offset3 % 60)), sign = offset3 >= 0 ? "+" : "-";
      switch (format) {
        case "short":
          return `${sign}${padStart2(hours, 2)}:${padStart2(minutes, 2)}`;
        case "narrow":
          return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
        case "techie":
          return `${sign}${padStart2(hours, 2)}${padStart2(minutes, 2)}`;
        default:
          throw new RangeError(`Value format ${format} is out of range for property format`);
      }
    }
    function timeObject2(obj) {
      return pick2(obj, ["hour", "minute", "second", "millisecond"]);
    }
    var monthsLong2 = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    var monthsShort2 = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var monthsNarrow2 = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
    function months2(length) {
      switch (length) {
        case "narrow":
          return [...monthsNarrow2];
        case "short":
          return [...monthsShort2];
        case "long":
          return [...monthsLong2];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
        case "2-digit":
          return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
        default:
          return null;
      }
    }
    var weekdaysLong2 = [
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
      "Sunday"
    ];
    var weekdaysShort2 = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    var weekdaysNarrow2 = ["M", "T", "W", "T", "F", "S", "S"];
    function weekdays2(length) {
      switch (length) {
        case "narrow":
          return [...weekdaysNarrow2];
        case "short":
          return [...weekdaysShort2];
        case "long":
          return [...weekdaysLong2];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7"];
        default:
          return null;
      }
    }
    var meridiems2 = ["AM", "PM"];
    var erasLong2 = ["Before Christ", "Anno Domini"];
    var erasShort2 = ["BC", "AD"];
    var erasNarrow2 = ["B", "A"];
    function eras2(length) {
      switch (length) {
        case "narrow":
          return [...erasNarrow2];
        case "short":
          return [...erasShort2];
        case "long":
          return [...erasLong2];
        default:
          return null;
      }
    }
    function meridiemForDateTime2(dt) {
      return meridiems2[dt.hour < 12 ? 0 : 1];
    }
    function weekdayForDateTime2(dt, length) {
      return weekdays2(length)[dt.weekday - 1];
    }
    function monthForDateTime2(dt, length) {
      return months2(length)[dt.month - 1];
    }
    function eraForDateTime2(dt, length) {
      return eras2(length)[dt.year < 0 ? 0 : 1];
    }
    function formatRelativeTime2(unit, count, numeric = "always", narrow = false) {
      const units = {
        years: ["year", "yr."],
        quarters: ["quarter", "qtr."],
        months: ["month", "mo."],
        weeks: ["week", "wk."],
        days: ["day", "day", "days"],
        hours: ["hour", "hr."],
        minutes: ["minute", "min."],
        seconds: ["second", "sec."]
      };
      const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
      if (numeric === "auto" && lastable) {
        const isDay = unit === "days";
        switch (count) {
          case 1:
            return isDay ? "tomorrow" : `next ${units[unit][0]}`;
          case -1:
            return isDay ? "yesterday" : `last ${units[unit][0]}`;
          case 0:
            return isDay ? "today" : `this ${units[unit][0]}`;
        }
      }
      const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
      return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
    }
    function stringifyTokens2(splits, tokenToString) {
      let s3 = "";
      for (const token of splits) {
        if (token.literal) {
          s3 += token.val;
        } else {
          s3 += tokenToString(token.val);
        }
      }
      return s3;
    }
    var macroTokenToFormatOpts2 = {
      D: DATE_SHORT2,
      DD: DATE_MED2,
      DDD: DATE_FULL2,
      DDDD: DATE_HUGE2,
      t: TIME_SIMPLE2,
      tt: TIME_WITH_SECONDS2,
      ttt: TIME_WITH_SHORT_OFFSET2,
      tttt: TIME_WITH_LONG_OFFSET2,
      T: TIME_24_SIMPLE2,
      TT: TIME_24_WITH_SECONDS2,
      TTT: TIME_24_WITH_SHORT_OFFSET2,
      TTTT: TIME_24_WITH_LONG_OFFSET2,
      f: DATETIME_SHORT2,
      ff: DATETIME_MED2,
      fff: DATETIME_FULL2,
      ffff: DATETIME_HUGE2,
      F: DATETIME_SHORT_WITH_SECONDS2,
      FF: DATETIME_MED_WITH_SECONDS2,
      FFF: DATETIME_FULL_WITH_SECONDS2,
      FFFF: DATETIME_HUGE_WITH_SECONDS2
    };
    var Formatter2 = class _Formatter {
      static create(locale, opts = {}) {
        return new _Formatter(locale, opts);
      }
      static parseFormat(fmt) {
        let current = null, currentFull = "", bracketed = false;
        const splits = [];
        for (let i = 0; i < fmt.length; i++) {
          const c = fmt.charAt(i);
          if (c === "'") {
            if (currentFull.length > 0) {
              splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
            }
            current = null;
            currentFull = "";
            bracketed = !bracketed;
          } else if (bracketed) {
            currentFull += c;
          } else if (c === current) {
            currentFull += c;
          } else {
            if (currentFull.length > 0) {
              splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
            }
            currentFull = c;
            current = c;
          }
        }
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        return splits;
      }
      static macroTokenToFormatOpts(token) {
        return macroTokenToFormatOpts2[token];
      }
      constructor(locale, formatOpts) {
        this.opts = formatOpts;
        this.loc = locale;
        this.systemLoc = null;
      }
      formatWithSystemDefault(dt, opts) {
        if (this.systemLoc === null) {
          this.systemLoc = this.loc.redefaultToSystem();
        }
        const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
        return df.format();
      }
      dtFormatter(dt, opts = {}) {
        return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
      }
      formatDateTime(dt, opts) {
        return this.dtFormatter(dt, opts).format();
      }
      formatDateTimeParts(dt, opts) {
        return this.dtFormatter(dt, opts).formatToParts();
      }
      formatInterval(interval, opts) {
        const df = this.dtFormatter(interval.start, opts);
        return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
      }
      resolvedOptions(dt, opts) {
        return this.dtFormatter(dt, opts).resolvedOptions();
      }
      num(n3, p = 0) {
        if (this.opts.forceSimple) {
          return padStart2(n3, p);
        }
        const opts = { ...this.opts };
        if (p > 0) {
          opts.padTo = p;
        }
        return this.loc.numberFormatter(opts).format(n3);
      }
      formatDateTimeFromString(dt, fmt) {
        const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset3 = (opts) => {
          if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
            return "Z";
          }
          return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
        }, meridiem = () => knownEnglish ? meridiemForDateTime2(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime2(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime2(dt, length) : string(
          standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
          "weekday"
        ), maybeMacro = (token) => {
          const formatOpts = _Formatter.macroTokenToFormatOpts(token);
          if (formatOpts) {
            return this.formatWithSystemDefault(dt, formatOpts);
          } else {
            return token;
          }
        }, era = (length) => knownEnglish ? eraForDateTime2(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
          switch (token) {
            case "S":
              return this.num(dt.millisecond);
            case "u":
            case "SSS":
              return this.num(dt.millisecond, 3);
            case "s":
              return this.num(dt.second);
            case "ss":
              return this.num(dt.second, 2);
            case "uu":
              return this.num(Math.floor(dt.millisecond / 10), 2);
            case "uuu":
              return this.num(Math.floor(dt.millisecond / 100));
            case "m":
              return this.num(dt.minute);
            case "mm":
              return this.num(dt.minute, 2);
            case "h":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
            case "hh":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
            case "H":
              return this.num(dt.hour);
            case "HH":
              return this.num(dt.hour, 2);
            case "Z":
              return formatOffset3({ format: "narrow", allowZ: this.opts.allowZ });
            case "ZZ":
              return formatOffset3({ format: "short", allowZ: this.opts.allowZ });
            case "ZZZ":
              return formatOffset3({ format: "techie", allowZ: this.opts.allowZ });
            case "ZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
            case "ZZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
            case "z":
              return dt.zoneName;
            case "a":
              return meridiem();
            case "d":
              return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
            case "dd":
              return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
            case "c":
              return this.num(dt.weekday);
            case "ccc":
              return weekday("short", true);
            case "cccc":
              return weekday("long", true);
            case "ccccc":
              return weekday("narrow", true);
            case "E":
              return this.num(dt.weekday);
            case "EEE":
              return weekday("short", false);
            case "EEEE":
              return weekday("long", false);
            case "EEEEE":
              return weekday("narrow", false);
            case "L":
              return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
            case "LL":
              return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
            case "LLL":
              return month("short", true);
            case "LLLL":
              return month("long", true);
            case "LLLLL":
              return month("narrow", true);
            case "M":
              return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
            case "MM":
              return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
            case "MMM":
              return month("short", false);
            case "MMMM":
              return month("long", false);
            case "MMMMM":
              return month("narrow", false);
            case "y":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
            case "yy":
              return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
            case "yyyy":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
            case "yyyyyy":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
            case "G":
              return era("short");
            case "GG":
              return era("long");
            case "GGGGG":
              return era("narrow");
            case "kk":
              return this.num(dt.weekYear.toString().slice(-2), 2);
            case "kkkk":
              return this.num(dt.weekYear, 4);
            case "W":
              return this.num(dt.weekNumber);
            case "WW":
              return this.num(dt.weekNumber, 2);
            case "o":
              return this.num(dt.ordinal);
            case "ooo":
              return this.num(dt.ordinal, 3);
            case "q":
              return this.num(dt.quarter);
            case "qq":
              return this.num(dt.quarter, 2);
            case "X":
              return this.num(Math.floor(dt.ts / 1e3));
            case "x":
              return this.num(dt.ts);
            default:
              return maybeMacro(token);
          }
        };
        return stringifyTokens2(_Formatter.parseFormat(fmt), tokenToString);
      }
      formatDurationFromString(dur, fmt) {
        const tokenToField = (token) => {
          switch (token[0]) {
            case "S":
              return "millisecond";
            case "s":
              return "second";
            case "m":
              return "minute";
            case "h":
              return "hour";
            case "d":
              return "day";
            case "w":
              return "week";
            case "M":
              return "month";
            case "y":
              return "year";
            default:
              return null;
          }
        }, tokenToString = (lildur) => (token) => {
          const mapped = tokenToField(token);
          if (mapped) {
            return this.num(lildur.get(mapped), token.length);
          } else {
            return token;
          }
        }, tokens = _Formatter.parseFormat(fmt), realTokens = tokens.reduce(
          (found, { literal, val }) => literal ? found : found.concat(val),
          []
        ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
        return stringifyTokens2(tokens, tokenToString(collapsed));
      }
    };
    var Invalid2 = class {
      constructor(reason, explanation) {
        this.reason = reason;
        this.explanation = explanation;
      }
      toMessage() {
        if (this.explanation) {
          return `${this.reason}: ${this.explanation}`;
        } else {
          return this.reason;
        }
      }
    };
    var ianaRegex2 = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
    function combineRegexes2(...regexes) {
      const full = regexes.reduce((f, r) => f + r.source, "");
      return RegExp(`^${full}$`);
    }
    function combineExtractors2(...extractors) {
      return (m) => extractors.reduce(
        ([mergedVals, mergedZone, cursor], ex) => {
          const [val, zone, next] = ex(m, cursor);
          return [{ ...mergedVals, ...val }, zone || mergedZone, next];
        },
        [{}, null, 1]
      ).slice(0, 2);
    }
    function parse2(s3, ...patterns) {
      if (s3 == null) {
        return [null, null];
      }
      for (const [regex2, extractor] of patterns) {
        const m = regex2.exec(s3);
        if (m) {
          return extractor(m);
        }
      }
      return [null, null];
    }
    function simpleParse2(...keys) {
      return (match3, cursor) => {
        const ret = {};
        let i;
        for (i = 0; i < keys.length; i++) {
          ret[keys[i]] = parseInteger2(match3[cursor + i]);
        }
        return [ret, null, cursor + i];
      };
    }
    var offsetRegex2 = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
    var isoExtendedZone2 = `(?:${offsetRegex2.source}?(?:\\[(${ianaRegex2.source})\\])?)?`;
    var isoTimeBaseRegex2 = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
    var isoTimeRegex2 = RegExp(`${isoTimeBaseRegex2.source}${isoExtendedZone2}`);
    var isoTimeExtensionRegex2 = RegExp(`(?:T${isoTimeRegex2.source})?`);
    var isoYmdRegex2 = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
    var isoWeekRegex2 = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
    var isoOrdinalRegex2 = /(\d{4})-?(\d{3})/;
    var extractISOWeekData2 = simpleParse2("weekYear", "weekNumber", "weekDay");
    var extractISOOrdinalData2 = simpleParse2("year", "ordinal");
    var sqlYmdRegex2 = /(\d{4})-(\d\d)-(\d\d)/;
    var sqlTimeRegex2 = RegExp(
      `${isoTimeBaseRegex2.source} ?(?:${offsetRegex2.source}|(${ianaRegex2.source}))?`
    );
    var sqlTimeExtensionRegex2 = RegExp(`(?: ${sqlTimeRegex2.source})?`);
    function int2(match3, pos, fallback) {
      const m = match3[pos];
      return isUndefined2(m) ? fallback : parseInteger2(m);
    }
    function extractISOYmd2(match3, cursor) {
      const item = {
        year: int2(match3, cursor),
        month: int2(match3, cursor + 1, 1),
        day: int2(match3, cursor + 2, 1)
      };
      return [item, null, cursor + 3];
    }
    function extractISOTime2(match3, cursor) {
      const item = {
        hours: int2(match3, cursor, 0),
        minutes: int2(match3, cursor + 1, 0),
        seconds: int2(match3, cursor + 2, 0),
        milliseconds: parseMillis2(match3[cursor + 3])
      };
      return [item, null, cursor + 4];
    }
    function extractISOOffset2(match3, cursor) {
      const local = !match3[cursor] && !match3[cursor + 1], fullOffset = signedOffset2(match3[cursor + 1], match3[cursor + 2]), zone = local ? null : FixedOffsetZone2.instance(fullOffset);
      return [{}, zone, cursor + 3];
    }
    function extractIANAZone2(match3, cursor) {
      const zone = match3[cursor] ? IANAZone2.create(match3[cursor]) : null;
      return [{}, zone, cursor + 1];
    }
    var isoTimeOnly2 = RegExp(`^T?${isoTimeBaseRegex2.source}$`);
    var isoDuration2 = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
    function extractISODuration2(match3) {
      const [s3, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match3;
      const hasNegativePrefix = s3[0] === "-";
      const negativeSeconds = secondStr && secondStr[0] === "-";
      const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
      return [
        {
          years: maybeNegate(parseFloating2(yearStr)),
          months: maybeNegate(parseFloating2(monthStr)),
          weeks: maybeNegate(parseFloating2(weekStr)),
          days: maybeNegate(parseFloating2(dayStr)),
          hours: maybeNegate(parseFloating2(hourStr)),
          minutes: maybeNegate(parseFloating2(minuteStr)),
          seconds: maybeNegate(parseFloating2(secondStr), secondStr === "-0"),
          milliseconds: maybeNegate(parseMillis2(millisecondsStr), negativeSeconds)
        }
      ];
    }
    var obsOffsets2 = {
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function fromStrings2(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      const result = {
        year: yearStr.length === 2 ? untruncateYear2(parseInteger2(yearStr)) : parseInteger2(yearStr),
        month: monthsShort2.indexOf(monthStr) + 1,
        day: parseInteger2(dayStr),
        hour: parseInteger2(hourStr),
        minute: parseInteger2(minuteStr)
      };
      if (secondStr)
        result.second = parseInteger2(secondStr);
      if (weekdayStr) {
        result.weekday = weekdayStr.length > 3 ? weekdaysLong2.indexOf(weekdayStr) + 1 : weekdaysShort2.indexOf(weekdayStr) + 1;
      }
      return result;
    }
    var rfc28222 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
    function extractRFC28222(match3) {
      const [
        ,
        weekdayStr,
        dayStr,
        monthStr,
        yearStr,
        hourStr,
        minuteStr,
        secondStr,
        obsOffset,
        milOffset,
        offHourStr,
        offMinuteStr
      ] = match3, result = fromStrings2(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      let offset3;
      if (obsOffset) {
        offset3 = obsOffsets2[obsOffset];
      } else if (milOffset) {
        offset3 = 0;
      } else {
        offset3 = signedOffset2(offHourStr, offMinuteStr);
      }
      return [result, new FixedOffsetZone2(offset3)];
    }
    function preprocessRFC28222(s3) {
      return s3.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
    }
    var rfc11232 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
    var rfc8502 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
    var ascii2 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
    function extractRFC1123Or8502(match3) {
      const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match3, result = fromStrings2(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone2.utcInstance];
    }
    function extractASCII2(match3) {
      const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match3, result = fromStrings2(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone2.utcInstance];
    }
    var isoYmdWithTimeExtensionRegex2 = combineRegexes2(isoYmdRegex2, isoTimeExtensionRegex2);
    var isoWeekWithTimeExtensionRegex2 = combineRegexes2(isoWeekRegex2, isoTimeExtensionRegex2);
    var isoOrdinalWithTimeExtensionRegex2 = combineRegexes2(isoOrdinalRegex2, isoTimeExtensionRegex2);
    var isoTimeCombinedRegex2 = combineRegexes2(isoTimeRegex2);
    var extractISOYmdTimeAndOffset2 = combineExtractors2(
      extractISOYmd2,
      extractISOTime2,
      extractISOOffset2,
      extractIANAZone2
    );
    var extractISOWeekTimeAndOffset2 = combineExtractors2(
      extractISOWeekData2,
      extractISOTime2,
      extractISOOffset2,
      extractIANAZone2
    );
    var extractISOOrdinalDateAndTime2 = combineExtractors2(
      extractISOOrdinalData2,
      extractISOTime2,
      extractISOOffset2,
      extractIANAZone2
    );
    var extractISOTimeAndOffset2 = combineExtractors2(
      extractISOTime2,
      extractISOOffset2,
      extractIANAZone2
    );
    function parseISODate2(s3) {
      return parse2(
        s3,
        [isoYmdWithTimeExtensionRegex2, extractISOYmdTimeAndOffset2],
        [isoWeekWithTimeExtensionRegex2, extractISOWeekTimeAndOffset2],
        [isoOrdinalWithTimeExtensionRegex2, extractISOOrdinalDateAndTime2],
        [isoTimeCombinedRegex2, extractISOTimeAndOffset2]
      );
    }
    function parseRFC2822Date2(s3) {
      return parse2(preprocessRFC28222(s3), [rfc28222, extractRFC28222]);
    }
    function parseHTTPDate2(s3) {
      return parse2(
        s3,
        [rfc11232, extractRFC1123Or8502],
        [rfc8502, extractRFC1123Or8502],
        [ascii2, extractASCII2]
      );
    }
    function parseISODuration2(s3) {
      return parse2(s3, [isoDuration2, extractISODuration2]);
    }
    var extractISOTimeOnly2 = combineExtractors2(extractISOTime2);
    function parseISOTimeOnly2(s3) {
      return parse2(s3, [isoTimeOnly2, extractISOTimeOnly2]);
    }
    var sqlYmdWithTimeExtensionRegex2 = combineRegexes2(sqlYmdRegex2, sqlTimeExtensionRegex2);
    var sqlTimeCombinedRegex2 = combineRegexes2(sqlTimeRegex2);
    var extractISOTimeOffsetAndIANAZone2 = combineExtractors2(
      extractISOTime2,
      extractISOOffset2,
      extractIANAZone2
    );
    function parseSQL2(s3) {
      return parse2(
        s3,
        [sqlYmdWithTimeExtensionRegex2, extractISOYmdTimeAndOffset2],
        [sqlTimeCombinedRegex2, extractISOTimeOffsetAndIANAZone2]
      );
    }
    var INVALID$2 = "Invalid Duration";
    var lowOrderMatrix2 = {
      weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1e3
      },
      days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1e3
      },
      hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
      minutes: { seconds: 60, milliseconds: 60 * 1e3 },
      seconds: { milliseconds: 1e3 }
    };
    var casualMatrix2 = {
      years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1e3
      },
      months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix2
    };
    var daysInYearAccurate2 = 146097 / 400;
    var daysInMonthAccurate2 = 146097 / 4800;
    var accurateMatrix2 = {
      years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate2 / 7,
        days: daysInYearAccurate2,
        hours: daysInYearAccurate2 * 24,
        minutes: daysInYearAccurate2 * 24 * 60,
        seconds: daysInYearAccurate2 * 24 * 60 * 60,
        milliseconds: daysInYearAccurate2 * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: daysInYearAccurate2 / 28,
        days: daysInYearAccurate2 / 4,
        hours: daysInYearAccurate2 * 24 / 4,
        minutes: daysInYearAccurate2 * 24 * 60 / 4,
        seconds: daysInYearAccurate2 * 24 * 60 * 60 / 4,
        milliseconds: daysInYearAccurate2 * 24 * 60 * 60 * 1e3 / 4
      },
      months: {
        weeks: daysInMonthAccurate2 / 7,
        days: daysInMonthAccurate2,
        hours: daysInMonthAccurate2 * 24,
        minutes: daysInMonthAccurate2 * 24 * 60,
        seconds: daysInMonthAccurate2 * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate2 * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix2
    };
    var orderedUnits$1 = [
      "years",
      "quarters",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ];
    var reverseUnits2 = orderedUnits$1.slice(0).reverse();
    function clone$1(dur, alts, clear = false) {
      const conf = {
        values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
        loc: dur.loc.clone(alts.loc),
        conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
        matrix: alts.matrix || dur.matrix
      };
      return new Duration2(conf);
    }
    function durationToMillis2(matrix, vals) {
      var _a;
      let sum = (_a = vals.milliseconds) != null ? _a : 0;
      for (const unit of reverseUnits2.slice(1)) {
        if (vals[unit]) {
          sum += vals[unit] * matrix[unit]["milliseconds"];
        }
      }
      return sum;
    }
    function normalizeValues2(matrix, vals) {
      const factor = durationToMillis2(matrix, vals) < 0 ? -1 : 1;
      orderedUnits$1.reduceRight((previous, current) => {
        if (!isUndefined2(vals[current])) {
          if (previous) {
            const previousVal = vals[previous] * factor;
            const conv = matrix[current][previous];
            const rollUp = Math.floor(previousVal / conv);
            vals[current] += rollUp * factor;
            vals[previous] -= rollUp * conv * factor;
          }
          return current;
        } else {
          return previous;
        }
      }, null);
      orderedUnits$1.reduce((previous, current) => {
        if (!isUndefined2(vals[current])) {
          if (previous) {
            const fraction = vals[previous] % 1;
            vals[previous] -= fraction;
            vals[current] += fraction * matrix[previous][current];
          }
          return current;
        } else {
          return previous;
        }
      }, null);
    }
    function removeZeroes2(vals) {
      const newVals = {};
      for (const [key, value] of Object.entries(vals)) {
        if (value !== 0) {
          newVals[key] = value;
        }
      }
      return newVals;
    }
    var Duration2 = class _Duration {
      /**
       * @private
       */
      constructor(config) {
        const accurate = config.conversionAccuracy === "longterm" || false;
        let matrix = accurate ? accurateMatrix2 : casualMatrix2;
        if (config.matrix) {
          matrix = config.matrix;
        }
        this.values = config.values;
        this.loc = config.loc || Locale2.create();
        this.conversionAccuracy = accurate ? "longterm" : "casual";
        this.invalid = config.invalid || null;
        this.matrix = matrix;
        this.isLuxonDuration = true;
      }
      /**
       * Create Duration from a number of milliseconds.
       * @param {number} count of milliseconds
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      static fromMillis(count, opts) {
        return _Duration.fromObject({ milliseconds: count }, opts);
      }
      /**
       * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
       * If this object is empty then a zero milliseconds duration is returned.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.years
       * @param {number} obj.quarters
       * @param {number} obj.months
       * @param {number} obj.weeks
       * @param {number} obj.days
       * @param {number} obj.hours
       * @param {number} obj.minutes
       * @param {number} obj.seconds
       * @param {number} obj.milliseconds
       * @param {Object} [opts=[]] - options for creating this Duration
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the custom conversion system to use
       * @return {Duration}
       */
      static fromObject(obj, opts = {}) {
        if (obj == null || typeof obj !== "object") {
          throw new InvalidArgumentError2(
            `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
          );
        }
        return new _Duration({
          values: normalizeObject2(obj, _Duration.normalizeUnit),
          loc: Locale2.fromObject(opts),
          conversionAccuracy: opts.conversionAccuracy,
          matrix: opts.matrix
        });
      }
      /**
       * Create a Duration from DurationLike.
       *
       * @param {Object | number | Duration} durationLike
       * One of:
       * - object with keys like 'years' and 'hours'.
       * - number representing milliseconds
       * - Duration instance
       * @return {Duration}
       */
      static fromDurationLike(durationLike) {
        if (isNumber2(durationLike)) {
          return _Duration.fromMillis(durationLike);
        } else if (_Duration.isDuration(durationLike)) {
          return durationLike;
        } else if (typeof durationLike === "object") {
          return _Duration.fromObject(durationLike);
        } else {
          throw new InvalidArgumentError2(
            `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
          );
        }
      }
      /**
       * Create a Duration from an ISO 8601 duration string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the preset conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
       * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
       * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
       * @return {Duration}
       */
      static fromISO(text2, opts) {
        const [parsed] = parseISODuration2(text2);
        if (parsed) {
          return _Duration.fromObject(parsed, opts);
        } else {
          return _Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create a Duration from an ISO 8601 time string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
       * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @return {Duration}
       */
      static fromISOTime(text2, opts) {
        const [parsed] = parseISOTimeOnly2(text2);
        if (parsed) {
          return _Duration.fromObject(parsed, opts);
        } else {
          return _Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create an invalid Duration.
       * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Duration}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError2("need to specify a reason the Duration is invalid");
        }
        const invalid = reason instanceof Invalid2 ? reason : new Invalid2(reason, explanation);
        if (Settings2.throwOnInvalid) {
          throw new InvalidDurationError2(invalid);
        } else {
          return new _Duration({ invalid });
        }
      }
      /**
       * @private
       */
      static normalizeUnit(unit) {
        const normalized = {
          year: "years",
          years: "years",
          quarter: "quarters",
          quarters: "quarters",
          month: "months",
          months: "months",
          week: "weeks",
          weeks: "weeks",
          day: "days",
          days: "days",
          hour: "hours",
          hours: "hours",
          minute: "minutes",
          minutes: "minutes",
          second: "seconds",
          seconds: "seconds",
          millisecond: "milliseconds",
          milliseconds: "milliseconds"
        }[unit ? unit.toLowerCase() : unit];
        if (!normalized)
          throw new InvalidUnitError2(unit);
        return normalized;
      }
      /**
       * Check if an object is a Duration. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDuration(o) {
        return o && o.isLuxonDuration || false;
      }
      /**
       * Get  the locale of a Duration, such 'en-GB'
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
       * * `S` for milliseconds
       * * `s` for seconds
       * * `m` for minutes
       * * `h` for hours
       * * `d` for days
       * * `w` for weeks
       * * `M` for months
       * * `y` for years
       * Notes:
       * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
       * * Tokens can be escaped by wrapping with single quotes.
       * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
       * @param {string} fmt - the format string
       * @param {Object} opts - options
       * @param {boolean} [opts.floor=true] - floor numerical values
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        const fmtOpts = {
          ...opts,
          floor: opts.round !== false && opts.floor !== false
        };
        return this.isValid ? Formatter2.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
      }
      /**
       * Returns a string representation of a Duration with all units included.
       * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
       * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
       * @example
       * ```js
       * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
       * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
       * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
       * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
       * ```
       */
      toHuman(opts = {}) {
        if (!this.isValid)
          return INVALID$2;
        const l3 = orderedUnits$1.map((unit) => {
          const val = this.values[unit];
          if (isUndefined2(val)) {
            return null;
          }
          return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
        }).filter((n3) => n3);
        return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l3);
      }
      /**
       * Returns a JavaScript object with this Duration's values.
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
       * @return {Object}
       */
      toObject() {
        if (!this.isValid)
          return {};
        return { ...this.values };
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
       * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
       * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
       * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
       * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
       * @return {string}
       */
      toISO() {
        if (!this.isValid)
          return null;
        let s3 = "P";
        if (this.years !== 0)
          s3 += this.years + "Y";
        if (this.months !== 0 || this.quarters !== 0)
          s3 += this.months + this.quarters * 3 + "M";
        if (this.weeks !== 0)
          s3 += this.weeks + "W";
        if (this.days !== 0)
          s3 += this.days + "D";
        if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
          s3 += "T";
        if (this.hours !== 0)
          s3 += this.hours + "H";
        if (this.minutes !== 0)
          s3 += this.minutes + "M";
        if (this.seconds !== 0 || this.milliseconds !== 0)
          s3 += roundTo2(this.seconds + this.milliseconds / 1e3, 3) + "S";
        if (s3 === "P")
          s3 += "T0S";
        return s3;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
       * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
       * @return {string}
       */
      toISOTime(opts = {}) {
        if (!this.isValid)
          return null;
        const millis = this.toMillis();
        if (millis < 0 || millis >= 864e5)
          return null;
        opts = {
          suppressMilliseconds: false,
          suppressSeconds: false,
          includePrefix: false,
          format: "extended",
          ...opts,
          includeOffset: false
        };
        const dateTime = DateTime2.fromMillis(millis, { zone: "UTC" });
        return dateTime.toISOTime(opts);
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
       * @return {string}
       */
      toString() {
        return this.toISO();
      }
      /**
       * Returns an milliseconds value of this Duration.
       * @return {number}
       */
      toMillis() {
        if (!this.isValid)
          return NaN;
        return durationToMillis2(this.matrix, this.values);
      }
      /**
       * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = _Duration.fromDurationLike(duration), result = {};
        for (const k of orderedUnits$1) {
          if (hasOwnProperty2(dur.values, k) || hasOwnProperty2(this.values, k)) {
            result[k] = dur.get(k) + this.get(k);
          }
        }
        return clone$1(this, { values: result }, true);
      }
      /**
       * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = _Duration.fromDurationLike(duration);
        return this.plus(dur.negate());
      }
      /**
       * Scale this Duration by the specified amount. Return a newly-constructed Duration.
       * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
       * @return {Duration}
       */
      mapUnits(fn) {
        if (!this.isValid)
          return this;
        const result = {};
        for (const k of Object.keys(this.values)) {
          result[k] = asNumber2(fn(this.values[k], k));
        }
        return clone$1(this, { values: result }, true);
      }
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
       * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
       * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
       * @return {number}
       */
      get(unit) {
        return this[_Duration.normalizeUnit(unit)];
      }
      /**
       * "Set" the values of specified units. Return a newly-constructed Duration.
       * @param {Object} values - a mapping of units to numbers
       * @example dur.set({ years: 2017 })
       * @example dur.set({ hours: 8, minutes: 30 })
       * @return {Duration}
       */
      set(values) {
        if (!this.isValid)
          return this;
        const mixed = { ...this.values, ...normalizeObject2(values, _Duration.normalizeUnit) };
        return clone$1(this, { values: mixed });
      }
      /**
       * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
       * @example dur.reconfigure({ locale: 'en-GB' })
       * @return {Duration}
       */
      reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem });
        const opts = { loc, matrix, conversionAccuracy };
        return clone$1(this, opts);
      }
      /**
       * Return the length of the duration in the specified unit.
       * @param {string} unit - a unit such as 'minutes' or 'days'
       * @example Duration.fromObject({years: 1}).as('days') //=> 365
       * @example Duration.fromObject({years: 1}).as('months') //=> 12
       * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
       * @return {number}
       */
      as(unit) {
        return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
      }
      /**
       * Reduce this Duration to its canonical representation in its current units.
       * Assuming the overall value of the Duration is positive, this means:
       * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
       * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
       *   the overall value would be negative, see second example)
       * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
       *
       * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
       * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
       * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
       * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
       * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
       * @return {Duration}
       */
      normalize() {
        if (!this.isValid)
          return this;
        const vals = this.toObject();
        normalizeValues2(this.matrix, vals);
        return clone$1(this, { values: vals }, true);
      }
      /**
       * Rescale units to its largest representation
       * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
       * @return {Duration}
       */
      rescale() {
        if (!this.isValid)
          return this;
        const vals = removeZeroes2(this.normalize().shiftToAll().toObject());
        return clone$1(this, { values: vals }, true);
      }
      /**
       * Convert this Duration into its representation in a different set of units.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
       * @return {Duration}
       */
      shiftTo(...units) {
        if (!this.isValid)
          return this;
        if (units.length === 0) {
          return this;
        }
        units = units.map((u) => _Duration.normalizeUnit(u));
        const built = {}, accumulated = {}, vals = this.toObject();
        let lastUnit;
        for (const k of orderedUnits$1) {
          if (units.indexOf(k) >= 0) {
            lastUnit = k;
            let own = 0;
            for (const ak in accumulated) {
              own += this.matrix[ak][k] * accumulated[ak];
              accumulated[ak] = 0;
            }
            if (isNumber2(vals[k])) {
              own += vals[k];
            }
            const i = Math.trunc(own);
            built[k] = i;
            accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
          } else if (isNumber2(vals[k])) {
            accumulated[k] = vals[k];
          }
        }
        for (const key in accumulated) {
          if (accumulated[key] !== 0) {
            built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
          }
        }
        normalizeValues2(this.matrix, built);
        return clone$1(this, { values: built }, true);
      }
      /**
       * Shift this Duration to all available units.
       * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
       * @return {Duration}
       */
      shiftToAll() {
        if (!this.isValid)
          return this;
        return this.shiftTo(
          "years",
          "months",
          "weeks",
          "days",
          "hours",
          "minutes",
          "seconds",
          "milliseconds"
        );
      }
      /**
       * Return the negative of this Duration.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
       * @return {Duration}
       */
      negate() {
        if (!this.isValid)
          return this;
        const negated = {};
        for (const k of Object.keys(this.values)) {
          negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
        }
        return clone$1(this, { values: negated }, true);
      }
      /**
       * Get the years.
       * @type {number}
       */
      get years() {
        return this.isValid ? this.values.years || 0 : NaN;
      }
      /**
       * Get the quarters.
       * @type {number}
       */
      get quarters() {
        return this.isValid ? this.values.quarters || 0 : NaN;
      }
      /**
       * Get the months.
       * @type {number}
       */
      get months() {
        return this.isValid ? this.values.months || 0 : NaN;
      }
      /**
       * Get the weeks
       * @type {number}
       */
      get weeks() {
        return this.isValid ? this.values.weeks || 0 : NaN;
      }
      /**
       * Get the days.
       * @type {number}
       */
      get days() {
        return this.isValid ? this.values.days || 0 : NaN;
      }
      /**
       * Get the hours.
       * @type {number}
       */
      get hours() {
        return this.isValid ? this.values.hours || 0 : NaN;
      }
      /**
       * Get the minutes.
       * @type {number}
       */
      get minutes() {
        return this.isValid ? this.values.minutes || 0 : NaN;
      }
      /**
       * Get the seconds.
       * @return {number}
       */
      get seconds() {
        return this.isValid ? this.values.seconds || 0 : NaN;
      }
      /**
       * Get the milliseconds.
       * @return {number}
       */
      get milliseconds() {
        return this.isValid ? this.values.milliseconds || 0 : NaN;
      }
      /**
       * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
       * on invalid DateTimes or Intervals.
       * @return {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this Duration became invalid, or null if the Duration is valid
       * @return {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Equality check
       * Two Durations are equal iff they have the same units and the same values for each unit.
       * @param {Duration} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        if (!this.loc.equals(other.loc)) {
          return false;
        }
        function eq(v1, v2) {
          if (v1 === void 0 || v1 === 0)
            return v2 === void 0 || v2 === 0;
          return v1 === v2;
        }
        for (const u of orderedUnits$1) {
          if (!eq(this.values[u], other.values[u])) {
            return false;
          }
        }
        return true;
      }
    };
    var INVALID$1 = "Invalid Interval";
    function validateStartEnd2(start, end) {
      if (!start || !start.isValid) {
        return Interval2.invalid("missing or invalid start");
      } else if (!end || !end.isValid) {
        return Interval2.invalid("missing or invalid end");
      } else if (end < start) {
        return Interval2.invalid(
          "end before start",
          `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
        );
      } else {
        return null;
      }
    }
    var Interval2 = class _Interval {
      /**
       * @private
       */
      constructor(config) {
        this.s = config.start;
        this.e = config.end;
        this.invalid = config.invalid || null;
        this.isLuxonInterval = true;
      }
      /**
       * Create an invalid Interval.
       * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Interval}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError2("need to specify a reason the Interval is invalid");
        }
        const invalid = reason instanceof Invalid2 ? reason : new Invalid2(reason, explanation);
        if (Settings2.throwOnInvalid) {
          throw new InvalidIntervalError2(invalid);
        } else {
          return new _Interval({ invalid });
        }
      }
      /**
       * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
       * @param {DateTime|Date|Object} start
       * @param {DateTime|Date|Object} end
       * @return {Interval}
       */
      static fromDateTimes(start, end) {
        const builtStart = friendlyDateTime2(start), builtEnd = friendlyDateTime2(end);
        const validateError = validateStartEnd2(builtStart, builtEnd);
        if (validateError == null) {
          return new _Interval({
            start: builtStart,
            end: builtEnd
          });
        } else {
          return validateError;
        }
      }
      /**
       * Create an Interval from a start DateTime and a Duration to extend to.
       * @param {DateTime|Date|Object} start
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static after(start, duration) {
        const dur = Duration2.fromDurationLike(duration), dt = friendlyDateTime2(start);
        return _Interval.fromDateTimes(dt, dt.plus(dur));
      }
      /**
       * Create an Interval from an end DateTime and a Duration to extend backwards to.
       * @param {DateTime|Date|Object} end
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static before(end, duration) {
        const dur = Duration2.fromDurationLike(duration), dt = friendlyDateTime2(end);
        return _Interval.fromDateTimes(dt.minus(dur), dt);
      }
      /**
       * Create an Interval from an ISO 8601 string.
       * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
       * @param {string} text - the ISO string to parse
       * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {Interval}
       */
      static fromISO(text2, opts) {
        const [s3, e] = (text2 || "").split("/", 2);
        if (s3 && e) {
          let start, startIsValid;
          try {
            start = DateTime2.fromISO(s3, opts);
            startIsValid = start.isValid;
          } catch (e2) {
            startIsValid = false;
          }
          let end, endIsValid;
          try {
            end = DateTime2.fromISO(e, opts);
            endIsValid = end.isValid;
          } catch (e2) {
            endIsValid = false;
          }
          if (startIsValid && endIsValid) {
            return _Interval.fromDateTimes(start, end);
          }
          if (startIsValid) {
            const dur = Duration2.fromISO(e, opts);
            if (dur.isValid) {
              return _Interval.after(start, dur);
            }
          } else if (endIsValid) {
            const dur = Duration2.fromISO(s3, opts);
            if (dur.isValid) {
              return _Interval.before(end, dur);
            }
          }
        }
        return _Interval.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
      }
      /**
       * Check if an object is an Interval. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isInterval(o) {
        return o && o.isLuxonInterval || false;
      }
      /**
       * Returns the start of the Interval
       * @type {DateTime}
       */
      get start() {
        return this.isValid ? this.s : null;
      }
      /**
       * Returns the end of the Interval
       * @type {DateTime}
       */
      get end() {
        return this.isValid ? this.e : null;
      }
      /**
       * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
       * @type {boolean}
       */
      get isValid() {
        return this.invalidReason === null;
      }
      /**
       * Returns an error code if this Interval is invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Returns the length of the Interval in the specified unit.
       * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
       * @return {number}
       */
      length(unit = "milliseconds") {
        return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
      }
      /**
       * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
       * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
       * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
       * @param {string} [unit='milliseconds'] - the unit of time to count.
       * @return {number}
       */
      count(unit = "milliseconds") {
        if (!this.isValid)
          return NaN;
        const start = this.start.startOf(unit), end = this.end.startOf(unit);
        return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
      }
      /**
       * Returns whether this Interval's start and end are both in the same unit of time
       * @param {string} unit - the unit of time to check sameness on
       * @return {boolean}
       */
      hasSame(unit) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
      }
      /**
       * Return whether this Interval has the same start and end DateTimes.
       * @return {boolean}
       */
      isEmpty() {
        return this.s.valueOf() === this.e.valueOf();
      }
      /**
       * Return whether this Interval's start is after the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isAfter(dateTime) {
        if (!this.isValid)
          return false;
        return this.s > dateTime;
      }
      /**
       * Return whether this Interval's end is before the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isBefore(dateTime) {
        if (!this.isValid)
          return false;
        return this.e <= dateTime;
      }
      /**
       * Return whether this Interval contains the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      contains(dateTime) {
        if (!this.isValid)
          return false;
        return this.s <= dateTime && this.e > dateTime;
      }
      /**
       * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
       * @param {Object} values - the values to set
       * @param {DateTime} values.start - the starting DateTime
       * @param {DateTime} values.end - the ending DateTime
       * @return {Interval}
       */
      set({ start, end } = {}) {
        if (!this.isValid)
          return this;
        return _Interval.fromDateTimes(start || this.s, end || this.e);
      }
      /**
       * Split this Interval at each of the specified DateTimes
       * @param {...DateTime} dateTimes - the unit of time to count.
       * @return {Array}
       */
      splitAt(...dateTimes) {
        if (!this.isValid)
          return [];
        const sorted = dateTimes.map(friendlyDateTime2).filter((d) => this.contains(d)).sort(), results = [];
        let { s: s3 } = this, i = 0;
        while (s3 < this.e) {
          const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
          results.push(_Interval.fromDateTimes(s3, next));
          s3 = next;
          i += 1;
        }
        return results;
      }
      /**
       * Split this Interval into smaller Intervals, each of the specified length.
       * Left over time is grouped into a smaller interval
       * @param {Duration|Object|number} duration - The length of each resulting interval.
       * @return {Array}
       */
      splitBy(duration) {
        const dur = Duration2.fromDurationLike(duration);
        if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
          return [];
        }
        let { s: s3 } = this, idx = 1, next;
        const results = [];
        while (s3 < this.e) {
          const added = this.start.plus(dur.mapUnits((x) => x * idx));
          next = +added > +this.e ? this.e : added;
          results.push(_Interval.fromDateTimes(s3, next));
          s3 = next;
          idx += 1;
        }
        return results;
      }
      /**
       * Split this Interval into the specified number of smaller intervals.
       * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
       * @return {Array}
       */
      divideEqually(numberOfParts) {
        if (!this.isValid)
          return [];
        return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
      }
      /**
       * Return whether this Interval overlaps with the specified Interval
       * @param {Interval} other
       * @return {boolean}
       */
      overlaps(other) {
        return this.e > other.s && this.s < other.e;
      }
      /**
       * Return whether this Interval's end is adjacent to the specified Interval's start.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsStart(other) {
        if (!this.isValid)
          return false;
        return +this.e === +other.s;
      }
      /**
       * Return whether this Interval's start is adjacent to the specified Interval's end.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsEnd(other) {
        if (!this.isValid)
          return false;
        return +other.e === +this.s;
      }
      /**
       * Return whether this Interval engulfs the start and end of the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      engulfs(other) {
        if (!this.isValid)
          return false;
        return this.s <= other.s && this.e >= other.e;
      }
      /**
       * Return whether this Interval has the same start and end as the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        return this.s.equals(other.s) && this.e.equals(other.e);
      }
      /**
       * Return an Interval representing the intersection of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
       * Returns null if the intersection is empty, meaning, the intervals don't intersect.
       * @param {Interval} other
       * @return {Interval}
       */
      intersection(other) {
        if (!this.isValid)
          return this;
        const s3 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
        if (s3 >= e) {
          return null;
        } else {
          return _Interval.fromDateTimes(s3, e);
        }
      }
      /**
       * Return an Interval representing the union of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
       * @param {Interval} other
       * @return {Interval}
       */
      union(other) {
        if (!this.isValid)
          return this;
        const s3 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
        return _Interval.fromDateTimes(s3, e);
      }
      /**
       * Merge an array of Intervals into a equivalent minimal set of Intervals.
       * Combines overlapping and adjacent Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static merge(intervals) {
        const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(
          ([sofar, current], item) => {
            if (!current) {
              return [sofar, item];
            } else if (current.overlaps(item) || current.abutsStart(item)) {
              return [sofar, current.union(item)];
            } else {
              return [sofar.concat([current]), item];
            }
          },
          [[], null]
        );
        if (final) {
          found.push(final);
        }
        return found;
      }
      /**
       * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static xor(intervals) {
        let start = null, currentCount = 0;
        const results = [], ends = intervals.map((i) => [
          { time: i.s, type: "s" },
          { time: i.e, type: "e" }
        ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
        for (const i of arr) {
          currentCount += i.type === "s" ? 1 : -1;
          if (currentCount === 1) {
            start = i.time;
          } else {
            if (start && +start !== +i.time) {
              results.push(_Interval.fromDateTimes(start, i.time));
            }
            start = null;
          }
        }
        return _Interval.merge(results);
      }
      /**
       * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
       * @param {...Interval} intervals
       * @return {Array}
       */
      difference(...intervals) {
        return _Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
      }
      /**
       * Returns a string representation of this Interval appropriate for debugging.
       * @return {string}
       */
      toString() {
        if (!this.isValid)
          return INVALID$1;
        return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
      }
      /**
       * Returns a localized string representing this Interval. Accepts the same options as the
       * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
       * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
       * is browser-specific, but in general it will return an appropriate representation of the
       * Interval in the assigned locale. Defaults to the system's locale if no locale has been
       * specified.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
       * Intl.DateTimeFormat constructor options.
       * @param {Object} opts - Options to override the configuration of the start DateTime.
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT2, opts = {}) {
        return this.isValid ? Formatter2.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Interval.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISO(opts) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of date of this Interval.
       * The time components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {string}
       */
      toISODate() {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISODate()}/${this.e.toISODate()}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of time of this Interval.
       * The date components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISOTime(opts) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
      }
      /**
       * Returns a string representation of this Interval formatted according to the specified format
       * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
       * formatting tool.
       * @param {string} dateFormat - The format string. This string formats the start and end time.
       * See {@link DateTime#toFormat} for details.
       * @param {Object} opts - Options.
       * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
       * representations.
       * @return {string}
       */
      toFormat(dateFormat, { separator = " \u2013 " } = {}) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
      }
      /**
       * Return a Duration representing the time spanned by this interval.
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
       * @return {Duration}
       */
      toDuration(unit, opts) {
        if (!this.isValid) {
          return Duration2.invalid(this.invalidReason);
        }
        return this.e.diff(this.s, unit, opts);
      }
      /**
       * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
       * @param {function} mapFn
       * @return {Interval}
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
       */
      mapEndpoints(mapFn) {
        return _Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
      }
    };
    var Info2 = class {
      /**
       * Return whether the specified zone contains a DST.
       * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
       * @return {boolean}
       */
      static hasDST(zone = Settings2.defaultZone) {
        const proto = DateTime2.now().setZone(zone).set({ month: 12 });
        return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
      }
      /**
       * Return whether the specified zone is a valid IANA specifier.
       * @param {string} zone - Zone to check
       * @return {boolean}
       */
      static isValidIANAZone(zone) {
        return IANAZone2.isValidZone(zone);
      }
      /**
       * Converts the input into a {@link Zone} instance.
       *
       * * If `input` is already a Zone instance, it is returned unchanged.
       * * If `input` is a string containing a valid time zone name, a Zone instance
       *   with that name is returned.
       * * If `input` is a string that doesn't refer to a known time zone, a Zone
       *   instance with {@link Zone#isValid} == false is returned.
       * * If `input is a number, a Zone instance with the specified fixed offset
       *   in minutes is returned.
       * * If `input` is `null` or `undefined`, the default zone is returned.
       * @param {string|Zone|number} [input] - the value to be converted
       * @return {Zone}
       */
      static normalizeZone(input) {
        return normalizeZone2(input, Settings2.defaultZone);
      }
      /**
       * Return an array of standalone month names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @example Info.months()[0] //=> 'January'
       * @example Info.months('short')[0] //=> 'Jan'
       * @example Info.months('numeric')[0] //=> '1'
       * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
       * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
       * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
       * @return {Array}
       */
      static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale2.create(locale, numberingSystem, outputCalendar)).months(length);
      }
      /**
       * Return an array of format month names.
       * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
       * changes the string.
       * See {@link Info#months}
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @return {Array}
       */
      static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale2.create(locale, numberingSystem, outputCalendar)).months(length, true);
      }
      /**
       * Return an array of standalone week names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @example Info.weekdays()[0] //=> 'Monday'
       * @example Info.weekdays('short')[0] //=> 'Mon'
       * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
       * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
       * @return {Array}
       */
      static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale2.create(locale, numberingSystem, null)).weekdays(length);
      }
      /**
       * Return an array of format week names.
       * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
       * changes the string.
       * See {@link Info#weekdays}
       * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale=null] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @return {Array}
       */
      static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale2.create(locale, numberingSystem, null)).weekdays(length, true);
      }
      /**
       * Return an array of meridiems.
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.meridiems() //=> [ 'AM', 'PM' ]
       * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
       * @return {Array}
       */
      static meridiems({ locale = null } = {}) {
        return Locale2.create(locale).meridiems();
      }
      /**
       * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
       * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.eras() //=> [ 'BC', 'AD' ]
       * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
       * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
       * @return {Array}
       */
      static eras(length = "short", { locale = null } = {}) {
        return Locale2.create(locale, null, "gregory").eras(length);
      }
      /**
       * Return the set of available features in this environment.
       * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
       * Keys:
       * * `relative`: whether this environment supports relative time formatting
       * @example Info.features() //=> { relative: false }
       * @return {Object}
       */
      static features() {
        return { relative: hasRelative2() };
      }
    };
    function dayDiff2(earlier, later) {
      const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
      return Math.floor(Duration2.fromMillis(ms).as("days"));
    }
    function highOrderDiffs2(cursor, later, units) {
      const differs = [
        ["years", (a, b) => b.year - a.year],
        ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
        ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
        [
          "weeks",
          (a, b) => {
            const days = dayDiff2(a, b);
            return (days - days % 7) / 7;
          }
        ],
        ["days", dayDiff2]
      ];
      const results = {};
      const earlier = cursor;
      let lowestOrder, highWater;
      for (const [unit, differ] of differs) {
        if (units.indexOf(unit) >= 0) {
          lowestOrder = unit;
          results[unit] = differ(cursor, later);
          highWater = earlier.plus(results);
          if (highWater > later) {
            results[unit]--;
            cursor = earlier.plus(results);
            if (cursor > later) {
              highWater = cursor;
              results[unit]--;
              cursor = earlier.plus(results);
            }
          } else {
            cursor = highWater;
          }
        }
      }
      return [cursor, results, highWater, lowestOrder];
    }
    function diff(earlier, later, units, opts) {
      let [cursor, results, highWater, lowestOrder] = highOrderDiffs2(earlier, later, units);
      const remainingMillis = later - cursor;
      const lowerOrderUnits = units.filter(
        (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
      );
      if (lowerOrderUnits.length === 0) {
        if (highWater < later) {
          highWater = cursor.plus({ [lowestOrder]: 1 });
        }
        if (highWater !== cursor) {
          results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
        }
      }
      const duration = Duration2.fromObject(results, opts);
      if (lowerOrderUnits.length > 0) {
        return Duration2.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
      } else {
        return duration;
      }
    }
    var numberingSystems2 = {
      arab: "[\u0660-\u0669]",
      arabext: "[\u06F0-\u06F9]",
      bali: "[\u1B50-\u1B59]",
      beng: "[\u09E6-\u09EF]",
      deva: "[\u0966-\u096F]",
      fullwide: "[\uFF10-\uFF19]",
      gujr: "[\u0AE6-\u0AEF]",
      hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
      khmr: "[\u17E0-\u17E9]",
      knda: "[\u0CE6-\u0CEF]",
      laoo: "[\u0ED0-\u0ED9]",
      limb: "[\u1946-\u194F]",
      mlym: "[\u0D66-\u0D6F]",
      mong: "[\u1810-\u1819]",
      mymr: "[\u1040-\u1049]",
      orya: "[\u0B66-\u0B6F]",
      tamldec: "[\u0BE6-\u0BEF]",
      telu: "[\u0C66-\u0C6F]",
      thai: "[\u0E50-\u0E59]",
      tibt: "[\u0F20-\u0F29]",
      latn: "\\d"
    };
    var numberingSystemsUTF162 = {
      arab: [1632, 1641],
      arabext: [1776, 1785],
      bali: [6992, 7001],
      beng: [2534, 2543],
      deva: [2406, 2415],
      fullwide: [65296, 65303],
      gujr: [2790, 2799],
      khmr: [6112, 6121],
      knda: [3302, 3311],
      laoo: [3792, 3801],
      limb: [6470, 6479],
      mlym: [3430, 3439],
      mong: [6160, 6169],
      mymr: [4160, 4169],
      orya: [2918, 2927],
      tamldec: [3046, 3055],
      telu: [3174, 3183],
      thai: [3664, 3673],
      tibt: [3872, 3881]
    };
    var hanidecChars2 = numberingSystems2.hanidec.replace(/[\[|\]]/g, "").split("");
    function parseDigits2(str) {
      let value = parseInt(str, 10);
      if (isNaN(value)) {
        value = "";
        for (let i = 0; i < str.length; i++) {
          const code = str.charCodeAt(i);
          if (str[i].search(numberingSystems2.hanidec) !== -1) {
            value += hanidecChars2.indexOf(str[i]);
          } else {
            for (const key in numberingSystemsUTF162) {
              const [min, max] = numberingSystemsUTF162[key];
              if (code >= min && code <= max) {
                value += code - min;
              }
            }
          }
        }
        return parseInt(value, 10);
      } else {
        return value;
      }
    }
    function digitRegex2({ numberingSystem }, append2 = "") {
      return new RegExp(`${numberingSystems2[numberingSystem || "latn"]}${append2}`);
    }
    var MISSING_FTP2 = "missing Intl.DateTimeFormat.formatToParts support";
    function intUnit2(regex2, post = (i) => i) {
      return { regex: regex2, deser: ([s3]) => post(parseDigits2(s3)) };
    }
    var NBSP2 = String.fromCharCode(160);
    var spaceOrNBSP2 = `[ ${NBSP2}]`;
    var spaceOrNBSPRegExp2 = new RegExp(spaceOrNBSP2, "g");
    function fixListRegex2(s3) {
      return s3.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp2, spaceOrNBSP2);
    }
    function stripInsensitivities2(s3) {
      return s3.replace(/\./g, "").replace(spaceOrNBSPRegExp2, " ").toLowerCase();
    }
    function oneOf2(strings, startIndex) {
      if (strings === null) {
        return null;
      } else {
        return {
          regex: RegExp(strings.map(fixListRegex2).join("|")),
          deser: ([s3]) => strings.findIndex((i) => stripInsensitivities2(s3) === stripInsensitivities2(i)) + startIndex
        };
      }
    }
    function offset2(regex2, groups) {
      return { regex: regex2, deser: ([, h, m]) => signedOffset2(h, m), groups };
    }
    function simple2(regex2) {
      return { regex: regex2, deser: ([s3]) => s3 };
    }
    function escapeToken2(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function unitForToken2(token, loc) {
      const one = digitRegex2(loc), two = digitRegex2(loc, "{2}"), three = digitRegex2(loc, "{3}"), four = digitRegex2(loc, "{4}"), six = digitRegex2(loc, "{6}"), oneOrTwo = digitRegex2(loc, "{1,2}"), oneToThree = digitRegex2(loc, "{1,3}"), oneToSix = digitRegex2(loc, "{1,6}"), oneToNine = digitRegex2(loc, "{1,9}"), twoToFour = digitRegex2(loc, "{2,4}"), fourToSix = digitRegex2(loc, "{4,6}"), literal = (t) => ({ regex: RegExp(escapeToken2(t.val)), deser: ([s3]) => s3, literal: true }), unitate = (t) => {
        if (token.literal) {
          return literal(t);
        }
        switch (t.val) {
          case "G":
            return oneOf2(loc.eras("short"), 0);
          case "GG":
            return oneOf2(loc.eras("long"), 0);
          case "y":
            return intUnit2(oneToSix);
          case "yy":
            return intUnit2(twoToFour, untruncateYear2);
          case "yyyy":
            return intUnit2(four);
          case "yyyyy":
            return intUnit2(fourToSix);
          case "yyyyyy":
            return intUnit2(six);
          case "M":
            return intUnit2(oneOrTwo);
          case "MM":
            return intUnit2(two);
          case "MMM":
            return oneOf2(loc.months("short", true), 1);
          case "MMMM":
            return oneOf2(loc.months("long", true), 1);
          case "L":
            return intUnit2(oneOrTwo);
          case "LL":
            return intUnit2(two);
          case "LLL":
            return oneOf2(loc.months("short", false), 1);
          case "LLLL":
            return oneOf2(loc.months("long", false), 1);
          case "d":
            return intUnit2(oneOrTwo);
          case "dd":
            return intUnit2(two);
          case "o":
            return intUnit2(oneToThree);
          case "ooo":
            return intUnit2(three);
          case "HH":
            return intUnit2(two);
          case "H":
            return intUnit2(oneOrTwo);
          case "hh":
            return intUnit2(two);
          case "h":
            return intUnit2(oneOrTwo);
          case "mm":
            return intUnit2(two);
          case "m":
            return intUnit2(oneOrTwo);
          case "q":
            return intUnit2(oneOrTwo);
          case "qq":
            return intUnit2(two);
          case "s":
            return intUnit2(oneOrTwo);
          case "ss":
            return intUnit2(two);
          case "S":
            return intUnit2(oneToThree);
          case "SSS":
            return intUnit2(three);
          case "u":
            return simple2(oneToNine);
          case "uu":
            return simple2(oneOrTwo);
          case "uuu":
            return intUnit2(one);
          case "a":
            return oneOf2(loc.meridiems(), 0);
          case "kkkk":
            return intUnit2(four);
          case "kk":
            return intUnit2(twoToFour, untruncateYear2);
          case "W":
            return intUnit2(oneOrTwo);
          case "WW":
            return intUnit2(two);
          case "E":
          case "c":
            return intUnit2(one);
          case "EEE":
            return oneOf2(loc.weekdays("short", false), 1);
          case "EEEE":
            return oneOf2(loc.weekdays("long", false), 1);
          case "ccc":
            return oneOf2(loc.weekdays("short", true), 1);
          case "cccc":
            return oneOf2(loc.weekdays("long", true), 1);
          case "Z":
          case "ZZ":
            return offset2(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
          case "ZZZ":
            return offset2(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
          case "z":
            return simple2(/[a-z_+-/]{1,256}?/i);
          case " ":
            return simple2(/[^\S\n\r]/);
          default:
            return literal(t);
        }
      };
      const unit = unitate(token) || {
        invalidReason: MISSING_FTP2
      };
      unit.token = token;
      return unit;
    }
    var partTypeStyleToTokenVal2 = {
      year: {
        "2-digit": "yy",
        numeric: "yyyyy"
      },
      month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
      },
      day: {
        numeric: "d",
        "2-digit": "dd"
      },
      weekday: {
        short: "EEE",
        long: "EEEE"
      },
      dayperiod: "a",
      dayPeriod: "a",
      hour12: {
        numeric: "h",
        "2-digit": "hh"
      },
      hour24: {
        numeric: "H",
        "2-digit": "HH"
      },
      minute: {
        numeric: "m",
        "2-digit": "mm"
      },
      second: {
        numeric: "s",
        "2-digit": "ss"
      },
      timeZoneName: {
        long: "ZZZZZ",
        short: "ZZZ"
      }
    };
    function tokenForPart2(part, formatOpts, resolvedOpts) {
      const { type, value } = part;
      if (type === "literal") {
        const isSpace = /^\s+$/.test(value);
        return {
          literal: !isSpace,
          val: isSpace ? " " : value
        };
      }
      const style = formatOpts[type];
      let actualType = type;
      if (type === "hour") {
        if (formatOpts.hour12 != null) {
          actualType = formatOpts.hour12 ? "hour12" : "hour24";
        } else if (formatOpts.hourCycle != null) {
          if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
            actualType = "hour12";
          } else {
            actualType = "hour24";
          }
        } else {
          actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
        }
      }
      let val = partTypeStyleToTokenVal2[actualType];
      if (typeof val === "object") {
        val = val[style];
      }
      if (val) {
        return {
          literal: false,
          val
        };
      }
      return void 0;
    }
    function buildRegex2(units) {
      const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
      return [`^${re}$`, units];
    }
    function match2(input, regex2, handlers) {
      const matches = input.match(regex2);
      if (matches) {
        const all = {};
        let matchIndex = 1;
        for (const i in handlers) {
          if (hasOwnProperty2(handlers, i)) {
            const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
            if (!h.literal && h.token) {
              all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
            }
            matchIndex += groups;
          }
        }
        return [matches, all];
      } else {
        return [matches, {}];
      }
    }
    function dateTimeFromMatches2(matches) {
      const toField = (token) => {
        switch (token) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
          case "H":
            return "hour";
          case "d":
            return "day";
          case "o":
            return "ordinal";
          case "L":
          case "M":
            return "month";
          case "y":
            return "year";
          case "E":
          case "c":
            return "weekday";
          case "W":
            return "weekNumber";
          case "k":
            return "weekYear";
          case "q":
            return "quarter";
          default:
            return null;
        }
      };
      let zone = null;
      let specificOffset;
      if (!isUndefined2(matches.z)) {
        zone = IANAZone2.create(matches.z);
      }
      if (!isUndefined2(matches.Z)) {
        if (!zone) {
          zone = new FixedOffsetZone2(matches.Z);
        }
        specificOffset = matches.Z;
      }
      if (!isUndefined2(matches.q)) {
        matches.M = (matches.q - 1) * 3 + 1;
      }
      if (!isUndefined2(matches.h)) {
        if (matches.h < 12 && matches.a === 1) {
          matches.h += 12;
        } else if (matches.h === 12 && matches.a === 0) {
          matches.h = 0;
        }
      }
      if (matches.G === 0 && matches.y) {
        matches.y = -matches.y;
      }
      if (!isUndefined2(matches.u)) {
        matches.S = parseMillis2(matches.u);
      }
      const vals = Object.keys(matches).reduce((r, k) => {
        const f = toField(k);
        if (f) {
          r[f] = matches[k];
        }
        return r;
      }, {});
      return [vals, zone, specificOffset];
    }
    var dummyDateTimeCache2 = null;
    function getDummyDateTime2() {
      if (!dummyDateTimeCache2) {
        dummyDateTimeCache2 = DateTime2.fromMillis(1555555555555);
      }
      return dummyDateTimeCache2;
    }
    function maybeExpandMacroToken2(token, locale) {
      if (token.literal) {
        return token;
      }
      const formatOpts = Formatter2.macroTokenToFormatOpts(token.val);
      const tokens = formatOptsToTokens2(formatOpts, locale);
      if (tokens == null || tokens.includes(void 0)) {
        return token;
      }
      return tokens;
    }
    function expandMacroTokens2(tokens, locale) {
      return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken2(t, locale)));
    }
    function explainFromTokens2(locale, input, format) {
      const tokens = expandMacroTokens2(Formatter2.parseFormat(format), locale), units = tokens.map((t) => unitForToken2(t, locale)), disqualifyingUnit = units.find((t) => t.invalidReason);
      if (disqualifyingUnit) {
        return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
      } else {
        const [regexString, handlers] = buildRegex2(units), regex2 = RegExp(regexString, "i"), [rawMatches, matches] = match2(input, regex2, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches2(matches) : [null, null, void 0];
        if (hasOwnProperty2(matches, "a") && hasOwnProperty2(matches, "H")) {
          throw new ConflictingSpecificationError2(
            "Can't include meridiem when specifying 24-hour format"
          );
        }
        return { input, tokens, regex: regex2, rawMatches, matches, result, zone, specificOffset };
      }
    }
    function parseFromTokens2(locale, input, format) {
      const { result, zone, specificOffset, invalidReason } = explainFromTokens2(locale, input, format);
      return [result, zone, specificOffset, invalidReason];
    }
    function formatOptsToTokens2(formatOpts, locale) {
      if (!formatOpts) {
        return null;
      }
      const formatter = Formatter2.create(locale, formatOpts);
      const df = formatter.dtFormatter(getDummyDateTime2());
      const parts = df.formatToParts();
      const resolvedOpts = df.resolvedOptions();
      return parts.map((p) => tokenForPart2(p, formatOpts, resolvedOpts));
    }
    var nonLeapLadder2 = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    var leapLadder2 = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    function unitOutOfRange2(unit, value) {
      return new Invalid2(
        "unit out of range",
        `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
      );
    }
    function dayOfWeek2(year, month, day) {
      const d = new Date(Date.UTC(year, month - 1, day));
      if (year < 100 && year >= 0) {
        d.setUTCFullYear(d.getUTCFullYear() - 1900);
      }
      const js = d.getUTCDay();
      return js === 0 ? 7 : js;
    }
    function computeOrdinal2(year, month, day) {
      return day + (isLeapYear2(year) ? leapLadder2 : nonLeapLadder2)[month - 1];
    }
    function uncomputeOrdinal2(year, ordinal) {
      const table = isLeapYear2(year) ? leapLadder2 : nonLeapLadder2, month0 = table.findIndex((i) => i < ordinal), day = ordinal - table[month0];
      return { month: month0 + 1, day };
    }
    function gregorianToWeek2(gregObj) {
      const { year, month, day } = gregObj, ordinal = computeOrdinal2(year, month, day), weekday = dayOfWeek2(year, month, day);
      let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
      if (weekNumber < 1) {
        weekYear = year - 1;
        weekNumber = weeksInWeekYear2(weekYear);
      } else if (weekNumber > weeksInWeekYear2(year)) {
        weekYear = year + 1;
        weekNumber = 1;
      } else {
        weekYear = year;
      }
      return { weekYear, weekNumber, weekday, ...timeObject2(gregObj) };
    }
    function weekToGregorian2(weekData) {
      const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek2(weekYear, 1, 4), yearInDays = daysInYear2(weekYear);
      let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
      if (ordinal < 1) {
        year = weekYear - 1;
        ordinal += daysInYear2(year);
      } else if (ordinal > yearInDays) {
        year = weekYear + 1;
        ordinal -= daysInYear2(weekYear);
      } else {
        year = weekYear;
      }
      const { month, day } = uncomputeOrdinal2(year, ordinal);
      return { year, month, day, ...timeObject2(weekData) };
    }
    function gregorianToOrdinal2(gregData) {
      const { year, month, day } = gregData;
      const ordinal = computeOrdinal2(year, month, day);
      return { year, ordinal, ...timeObject2(gregData) };
    }
    function ordinalToGregorian2(ordinalData) {
      const { year, ordinal } = ordinalData;
      const { month, day } = uncomputeOrdinal2(year, ordinal);
      return { year, month, day, ...timeObject2(ordinalData) };
    }
    function hasInvalidWeekData2(obj) {
      const validYear = isInteger2(obj.weekYear), validWeek = integerBetween2(obj.weekNumber, 1, weeksInWeekYear2(obj.weekYear)), validWeekday = integerBetween2(obj.weekday, 1, 7);
      if (!validYear) {
        return unitOutOfRange2("weekYear", obj.weekYear);
      } else if (!validWeek) {
        return unitOutOfRange2("week", obj.week);
      } else if (!validWeekday) {
        return unitOutOfRange2("weekday", obj.weekday);
      } else
        return false;
    }
    function hasInvalidOrdinalData2(obj) {
      const validYear = isInteger2(obj.year), validOrdinal = integerBetween2(obj.ordinal, 1, daysInYear2(obj.year));
      if (!validYear) {
        return unitOutOfRange2("year", obj.year);
      } else if (!validOrdinal) {
        return unitOutOfRange2("ordinal", obj.ordinal);
      } else
        return false;
    }
    function hasInvalidGregorianData2(obj) {
      const validYear = isInteger2(obj.year), validMonth = integerBetween2(obj.month, 1, 12), validDay = integerBetween2(obj.day, 1, daysInMonth2(obj.year, obj.month));
      if (!validYear) {
        return unitOutOfRange2("year", obj.year);
      } else if (!validMonth) {
        return unitOutOfRange2("month", obj.month);
      } else if (!validDay) {
        return unitOutOfRange2("day", obj.day);
      } else
        return false;
    }
    function hasInvalidTimeData2(obj) {
      const { hour, minute, second, millisecond } = obj;
      const validHour = integerBetween2(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween2(minute, 0, 59), validSecond = integerBetween2(second, 0, 59), validMillisecond = integerBetween2(millisecond, 0, 999);
      if (!validHour) {
        return unitOutOfRange2("hour", hour);
      } else if (!validMinute) {
        return unitOutOfRange2("minute", minute);
      } else if (!validSecond) {
        return unitOutOfRange2("second", second);
      } else if (!validMillisecond) {
        return unitOutOfRange2("millisecond", millisecond);
      } else
        return false;
    }
    var INVALID5 = "Invalid DateTime";
    var MAX_DATE2 = 864e13;
    function unsupportedZone2(zone) {
      return new Invalid2("unsupported zone", `the zone "${zone.name}" is not supported`);
    }
    function possiblyCachedWeekData2(dt) {
      if (dt.weekData === null) {
        dt.weekData = gregorianToWeek2(dt.c);
      }
      return dt.weekData;
    }
    function clone3(inst, alts) {
      const current = {
        ts: inst.ts,
        zone: inst.zone,
        c: inst.c,
        o: inst.o,
        loc: inst.loc,
        invalid: inst.invalid
      };
      return new DateTime2({ ...current, ...alts, old: current });
    }
    function fixOffset2(localTS, o, tz) {
      let utcGuess = localTS - o * 60 * 1e3;
      const o2 = tz.offset(utcGuess);
      if (o === o2) {
        return [utcGuess, o];
      }
      utcGuess -= (o2 - o) * 60 * 1e3;
      const o3 = tz.offset(utcGuess);
      if (o2 === o3) {
        return [utcGuess, o2];
      }
      return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
    }
    function tsToObj2(ts, offset3) {
      ts += offset3 * 60 * 1e3;
      const d = new Date(ts);
      return {
        year: d.getUTCFullYear(),
        month: d.getUTCMonth() + 1,
        day: d.getUTCDate(),
        hour: d.getUTCHours(),
        minute: d.getUTCMinutes(),
        second: d.getUTCSeconds(),
        millisecond: d.getUTCMilliseconds()
      };
    }
    function objToTS2(obj, offset3, zone) {
      return fixOffset2(objToLocalTS2(obj), offset3, zone);
    }
    function adjustTime2(inst, dur) {
      const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
        ...inst.c,
        year,
        month,
        day: Math.min(inst.c.day, daysInMonth2(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
      }, millisToAdd = Duration2.fromObject({
        years: dur.years - Math.trunc(dur.years),
        quarters: dur.quarters - Math.trunc(dur.quarters),
        months: dur.months - Math.trunc(dur.months),
        weeks: dur.weeks - Math.trunc(dur.weeks),
        days: dur.days - Math.trunc(dur.days),
        hours: dur.hours,
        minutes: dur.minutes,
        seconds: dur.seconds,
        milliseconds: dur.milliseconds
      }).as("milliseconds"), localTS = objToLocalTS2(c);
      let [ts, o] = fixOffset2(localTS, oPre, inst.zone);
      if (millisToAdd !== 0) {
        ts += millisToAdd;
        o = inst.zone.offset(ts);
      }
      return { ts, o };
    }
    function parseDataToDateTime2(parsed, parsedZone, opts, format, text2, specificOffset) {
      const { setZone, zone } = opts;
      if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
        const interpretationZone = parsedZone || zone, inst = DateTime2.fromObject(parsed, {
          ...opts,
          zone: interpretationZone,
          specificOffset
        });
        return setZone ? inst : inst.setZone(zone);
      } else {
        return DateTime2.invalid(
          new Invalid2("unparsable", `the input "${text2}" can't be parsed as ${format}`)
        );
      }
    }
    function toTechFormat2(dt, format, allowZ = true) {
      return dt.isValid ? Formatter2.create(Locale2.create("en-US"), {
        allowZ,
        forceSimple: true
      }).formatDateTimeFromString(dt, format) : null;
    }
    function toISODate2(o, extended) {
      const longFormat = o.c.year > 9999 || o.c.year < 0;
      let c = "";
      if (longFormat && o.c.year >= 0)
        c += "+";
      c += padStart2(o.c.year, longFormat ? 6 : 4);
      if (extended) {
        c += "-";
        c += padStart2(o.c.month);
        c += "-";
        c += padStart2(o.c.day);
      } else {
        c += padStart2(o.c.month);
        c += padStart2(o.c.day);
      }
      return c;
    }
    function toISOTime2(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
      let c = padStart2(o.c.hour);
      if (extended) {
        c += ":";
        c += padStart2(o.c.minute);
        if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
          c += ":";
        }
      } else {
        c += padStart2(o.c.minute);
      }
      if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
        c += padStart2(o.c.second);
        if (o.c.millisecond !== 0 || !suppressMilliseconds) {
          c += ".";
          c += padStart2(o.c.millisecond, 3);
        }
      }
      if (includeOffset) {
        if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
          c += "Z";
        } else if (o.o < 0) {
          c += "-";
          c += padStart2(Math.trunc(-o.o / 60));
          c += ":";
          c += padStart2(Math.trunc(-o.o % 60));
        } else {
          c += "+";
          c += padStart2(Math.trunc(o.o / 60));
          c += ":";
          c += padStart2(Math.trunc(o.o % 60));
        }
      }
      if (extendedZone) {
        c += "[" + o.zone.ianaName + "]";
      }
      return c;
    }
    var defaultUnitValues2 = {
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultWeekUnitValues2 = {
      weekNumber: 1,
      weekday: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultOrdinalUnitValues2 = {
      ordinal: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var orderedUnits3 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
    var orderedWeekUnits2 = [
      "weekYear",
      "weekNumber",
      "weekday",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    var orderedOrdinalUnits2 = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
    function normalizeUnit2(unit) {
      const normalized = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
      }[unit.toLowerCase()];
      if (!normalized)
        throw new InvalidUnitError2(unit);
      return normalized;
    }
    function quickDT2(obj, opts) {
      const zone = normalizeZone2(opts.zone, Settings2.defaultZone), loc = Locale2.fromObject(opts), tsNow = Settings2.now();
      let ts, o;
      if (!isUndefined2(obj.year)) {
        for (const u of orderedUnits3) {
          if (isUndefined2(obj[u])) {
            obj[u] = defaultUnitValues2[u];
          }
        }
        const invalid = hasInvalidGregorianData2(obj) || hasInvalidTimeData2(obj);
        if (invalid) {
          return DateTime2.invalid(invalid);
        }
        const offsetProvis = zone.offset(tsNow);
        [ts, o] = objToTS2(obj, offsetProvis, zone);
      } else {
        ts = tsNow;
      }
      return new DateTime2({ ts, zone, loc, o });
    }
    function diffRelative2(start, end, opts) {
      const round = isUndefined2(opts.round) ? true : opts.round, format = (c, unit) => {
        c = roundTo2(c, round || opts.calendary ? 0 : 2, true);
        const formatter = end.loc.clone(opts).relFormatter(opts);
        return formatter.format(c, unit);
      }, differ = (unit) => {
        if (opts.calendary) {
          if (!end.hasSame(start, unit)) {
            return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
          } else
            return 0;
        } else {
          return end.diff(start, unit).get(unit);
        }
      };
      if (opts.unit) {
        return format(differ(opts.unit), opts.unit);
      }
      for (const unit of opts.units) {
        const count = differ(unit);
        if (Math.abs(count) >= 1) {
          return format(count, unit);
        }
      }
      return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
    }
    function lastOpts2(argList) {
      let opts = {}, args;
      if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
        opts = argList[argList.length - 1];
        args = Array.from(argList).slice(0, argList.length - 1);
      } else {
        args = Array.from(argList);
      }
      return [opts, args];
    }
    var DateTime2 = class _DateTime {
      /**
       * @access private
       */
      constructor(config) {
        const zone = config.zone || Settings2.defaultZone;
        let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid2("invalid input") : null) || (!zone.isValid ? unsupportedZone2(zone) : null);
        this.ts = isUndefined2(config.ts) ? Settings2.now() : config.ts;
        let c = null, o = null;
        if (!invalid) {
          const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
          if (unchanged) {
            [c, o] = [config.old.c, config.old.o];
          } else {
            const ot = zone.offset(this.ts);
            c = tsToObj2(this.ts, ot);
            invalid = Number.isNaN(c.year) ? new Invalid2("invalid input") : null;
            c = invalid ? null : c;
            o = invalid ? null : ot;
          }
        }
        this._zone = zone;
        this.loc = config.loc || Locale2.create();
        this.invalid = invalid;
        this.weekData = null;
        this.c = c;
        this.o = o;
        this.isLuxonDateTime = true;
      }
      // CONSTRUCT
      /**
       * Create a DateTime for the current instant, in the system's time zone.
       *
       * Use Settings to override these default values if needed.
       * @example DateTime.now().toISO() //~> now in the ISO format
       * @return {DateTime}
       */
      static now() {
        return new _DateTime({});
      }
      /**
       * Create a local DateTime
       * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month, 1-indexed
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @example DateTime.local()                                  //~> now
       * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
       * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
       * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
       * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
       * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
       * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
       * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
       * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
       * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
       * @return {DateTime}
       */
      static local() {
        const [opts, args] = lastOpts2(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        return quickDT2({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime in UTC
       * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @param {Object} options - configuration options for the DateTime
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.utc()                                              //~> now
       * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
       * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
       * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
       * @return {DateTime}
       */
      static utc() {
        const [opts, args] = lastOpts2(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        opts.zone = FixedOffsetZone2.utcInstance;
        return quickDT2({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime from a JavaScript Date object. Uses the default zone.
       * @param {Date} date - a JavaScript Date object
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @return {DateTime}
       */
      static fromJSDate(date, options = {}) {
        const ts = isDate2(date) ? date.valueOf() : NaN;
        if (Number.isNaN(ts)) {
          return _DateTime.invalid("invalid input");
        }
        const zoneToUse = normalizeZone2(options.zone, Settings2.defaultZone);
        if (!zoneToUse.isValid) {
          return _DateTime.invalid(unsupportedZone2(zoneToUse));
        }
        return new _DateTime({
          ts,
          zone: zoneToUse,
          loc: Locale2.fromObject(options)
        });
      }
      /**
       * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} milliseconds - a number of milliseconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromMillis(milliseconds, options = {}) {
        if (!isNumber2(milliseconds)) {
          throw new InvalidArgumentError2(
            `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
          );
        } else if (milliseconds < -MAX_DATE2 || milliseconds > MAX_DATE2) {
          return _DateTime.invalid("Timestamp out of range");
        } else {
          return new _DateTime({
            ts: milliseconds,
            zone: normalizeZone2(options.zone, Settings2.defaultZone),
            loc: Locale2.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} seconds - a number of seconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromSeconds(seconds, options = {}) {
        if (!isNumber2(seconds)) {
          throw new InvalidArgumentError2("fromSeconds requires a numerical input");
        } else {
          return new _DateTime({
            ts: seconds * 1e3,
            zone: normalizeZone2(options.zone, Settings2.defaultZone),
            loc: Locale2.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.year - a year, such as 1987
       * @param {number} obj.month - a month, 1-12
       * @param {number} obj.day - a day of the month, 1-31, depending on the month
       * @param {number} obj.ordinal - day of the year, 1-365 or 366
       * @param {number} obj.weekYear - an ISO week year
       * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
       * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
       * @param {number} obj.hour - hour of the day, 0-23
       * @param {number} obj.minute - minute of the hour, 0-59
       * @param {number} obj.second - second of the minute, 0-59
       * @param {number} obj.millisecond - millisecond of the second, 0-999
       * @param {Object} opts - options for creating this DateTime
       * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
       * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
       * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
       * @return {DateTime}
       */
      static fromObject(obj, opts = {}) {
        obj = obj || {};
        const zoneToUse = normalizeZone2(opts.zone, Settings2.defaultZone);
        if (!zoneToUse.isValid) {
          return _DateTime.invalid(unsupportedZone2(zoneToUse));
        }
        const tsNow = Settings2.now(), offsetProvis = !isUndefined2(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject2(obj, normalizeUnit2), containsOrdinal = !isUndefined2(normalized.ordinal), containsGregorYear = !isUndefined2(normalized.year), containsGregorMD = !isUndefined2(normalized.month) || !isUndefined2(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale2.fromObject(opts);
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError2(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError2("Can't mix ordinal dates with month/day");
        }
        const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
        let units, defaultValues, objNow = tsToObj2(tsNow, offsetProvis);
        if (useWeekData) {
          units = orderedWeekUnits2;
          defaultValues = defaultWeekUnitValues2;
          objNow = gregorianToWeek2(objNow);
        } else if (containsOrdinal) {
          units = orderedOrdinalUnits2;
          defaultValues = defaultOrdinalUnitValues2;
          objNow = gregorianToOrdinal2(objNow);
        } else {
          units = orderedUnits3;
          defaultValues = defaultUnitValues2;
        }
        let foundFirst = false;
        for (const u of units) {
          const v = normalized[u];
          if (!isUndefined2(v)) {
            foundFirst = true;
          } else if (foundFirst) {
            normalized[u] = defaultValues[u];
          } else {
            normalized[u] = objNow[u];
          }
        }
        const higherOrderInvalid = useWeekData ? hasInvalidWeekData2(normalized) : containsOrdinal ? hasInvalidOrdinalData2(normalized) : hasInvalidGregorianData2(normalized), invalid = higherOrderInvalid || hasInvalidTimeData2(normalized);
        if (invalid) {
          return _DateTime.invalid(invalid);
        }
        const gregorian = useWeekData ? weekToGregorian2(normalized) : containsOrdinal ? ordinalToGregorian2(normalized) : normalized, [tsFinal, offsetFinal] = objToTS2(gregorian, offsetProvis, zoneToUse), inst = new _DateTime({
          ts: tsFinal,
          zone: zoneToUse,
          o: offsetFinal,
          loc
        });
        if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
          return _DateTime.invalid(
            "mismatched weekday",
            `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
          );
        }
        return inst;
      }
      /**
       * Create a DateTime from an ISO 8601 string
       * @param {string} text - the ISO string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromISO('2016-05-25T09:08:34.123')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
       * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
       * @example DateTime.fromISO('2016-W05-4')
       * @return {DateTime}
       */
      static fromISO(text2, opts = {}) {
        const [vals, parsedZone] = parseISODate2(text2);
        return parseDataToDateTime2(vals, parsedZone, opts, "ISO 8601", text2);
      }
      /**
       * Create a DateTime from an RFC 2822 string
       * @param {string} text - the RFC 2822 string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
       * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
       * @return {DateTime}
       */
      static fromRFC2822(text2, opts = {}) {
        const [vals, parsedZone] = parseRFC2822Date2(text2);
        return parseDataToDateTime2(vals, parsedZone, opts, "RFC 2822", text2);
      }
      /**
       * Create a DateTime from an HTTP header date
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @param {string} text - the HTTP header date
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
       * @return {DateTime}
       */
      static fromHTTP(text2, opts = {}) {
        const [vals, parsedZone] = parseHTTPDate2(text2);
        return parseDataToDateTime2(vals, parsedZone, opts, "HTTP", opts);
      }
      /**
       * Create a DateTime from an input string and format string.
       * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromFormat(text2, fmt, opts = {}) {
        if (isUndefined2(text2) || isUndefined2(fmt)) {
          throw new InvalidArgumentError2("fromFormat requires an input string and a format");
        }
        const { locale = null, numberingSystem = null } = opts, localeToUse = Locale2.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens2(localeToUse, text2, fmt);
        if (invalid) {
          return _DateTime.invalid(invalid);
        } else {
          return parseDataToDateTime2(vals, parsedZone, opts, `format ${fmt}`, text2, specificOffset);
        }
      }
      /**
       * @deprecated use fromFormat instead
       */
      static fromString(text2, fmt, opts = {}) {
        return _DateTime.fromFormat(text2, fmt, opts);
      }
      /**
       * Create a DateTime from a SQL date, time, or datetime
       * Defaults to en-US if no locale has been specified, regardless of the system's locale
       * @param {string} text - the string to parse
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @example DateTime.fromSQL('2017-05-15')
       * @example DateTime.fromSQL('2017-05-15 09:12:34')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
       * @example DateTime.fromSQL('09:12:34.342')
       * @return {DateTime}
       */
      static fromSQL(text2, opts = {}) {
        const [vals, parsedZone] = parseSQL2(text2);
        return parseDataToDateTime2(vals, parsedZone, opts, "SQL", text2);
      }
      /**
       * Create an invalid DateTime.
       * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {DateTime}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError2("need to specify a reason the DateTime is invalid");
        }
        const invalid = reason instanceof Invalid2 ? reason : new Invalid2(reason, explanation);
        if (Settings2.throwOnInvalid) {
          throw new InvalidDateTimeError2(invalid);
        } else {
          return new _DateTime({ invalid });
        }
      }
      /**
       * Check if an object is an instance of DateTime. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDateTime(o) {
        return o && o.isLuxonDateTime || false;
      }
      /**
       * Produce the format string for a set of options
       * @param formatOpts
       * @param localeOpts
       * @returns {string}
       */
      static parseFormatForOpts(formatOpts, localeOpts = {}) {
        const tokenList = formatOptsToTokens2(formatOpts, Locale2.fromObject(localeOpts));
        return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
      }
      /**
       * Produce the the fully expanded format token for the locale
       * Does NOT quote characters, so quoted tokens will not round trip correctly
       * @param fmt
       * @param localeOpts
       * @returns {string}
       */
      static expandFormat(fmt, localeOpts = {}) {
        const expanded = expandMacroTokens2(Formatter2.parseFormat(fmt), Locale2.fromObject(localeOpts));
        return expanded.map((t) => t.val).join("");
      }
      // INFO
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
       * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
       * @return {number}
       */
      get(unit) {
        return this[unit];
      }
      /**
       * Returns whether the DateTime is valid. Invalid DateTimes occur when:
       * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
       * * The DateTime was created by an operation on another invalid date
       * @type {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
       *
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
       *
       * @type {string}
       */
      get outputCalendar() {
        return this.isValid ? this.loc.outputCalendar : null;
      }
      /**
       * Get the time zone associated with this DateTime.
       * @type {Zone}
       */
      get zone() {
        return this._zone;
      }
      /**
       * Get the name of the time zone.
       * @type {string}
       */
      get zoneName() {
        return this.isValid ? this.zone.name : null;
      }
      /**
       * Get the year
       * @example DateTime.local(2017, 5, 25).year //=> 2017
       * @type {number}
       */
      get year() {
        return this.isValid ? this.c.year : NaN;
      }
      /**
       * Get the quarter
       * @example DateTime.local(2017, 5, 25).quarter //=> 2
       * @type {number}
       */
      get quarter() {
        return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
      }
      /**
       * Get the month (1-12).
       * @example DateTime.local(2017, 5, 25).month //=> 5
       * @type {number}
       */
      get month() {
        return this.isValid ? this.c.month : NaN;
      }
      /**
       * Get the day of the month (1-30ish).
       * @example DateTime.local(2017, 5, 25).day //=> 25
       * @type {number}
       */
      get day() {
        return this.isValid ? this.c.day : NaN;
      }
      /**
       * Get the hour of the day (0-23).
       * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
       * @type {number}
       */
      get hour() {
        return this.isValid ? this.c.hour : NaN;
      }
      /**
       * Get the minute of the hour (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
       * @type {number}
       */
      get minute() {
        return this.isValid ? this.c.minute : NaN;
      }
      /**
       * Get the second of the minute (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
       * @type {number}
       */
      get second() {
        return this.isValid ? this.c.second : NaN;
      }
      /**
       * Get the millisecond of the second (0-999).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
       * @type {number}
       */
      get millisecond() {
        return this.isValid ? this.c.millisecond : NaN;
      }
      /**
       * Get the week year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
       * @type {number}
       */
      get weekYear() {
        return this.isValid ? possiblyCachedWeekData2(this).weekYear : NaN;
      }
      /**
       * Get the week number of the week year (1-52ish).
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
       * @type {number}
       */
      get weekNumber() {
        return this.isValid ? possiblyCachedWeekData2(this).weekNumber : NaN;
      }
      /**
       * Get the day of the week.
       * 1 is Monday and 7 is Sunday
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 11, 31).weekday //=> 4
       * @type {number}
       */
      get weekday() {
        return this.isValid ? possiblyCachedWeekData2(this).weekday : NaN;
      }
      /**
       * Get the ordinal (meaning the day of the year)
       * @example DateTime.local(2017, 5, 25).ordinal //=> 145
       * @type {number|DateTime}
       */
      get ordinal() {
        return this.isValid ? gregorianToOrdinal2(this.c).ordinal : NaN;
      }
      /**
       * Get the human readable short month name, such as 'Oct'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
       * @type {string}
       */
      get monthShort() {
        return this.isValid ? Info2.months("short", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable long month name, such as 'October'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthLong //=> October
       * @type {string}
       */
      get monthLong() {
        return this.isValid ? Info2.months("long", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable short weekday, such as 'Mon'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
       * @type {string}
       */
      get weekdayShort() {
        return this.isValid ? Info2.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the human readable long weekday, such as 'Monday'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
       * @type {string}
       */
      get weekdayLong() {
        return this.isValid ? Info2.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the UTC offset of this DateTime in minutes
       * @example DateTime.now().offset //=> -240
       * @example DateTime.utc().offset //=> 0
       * @type {number}
       */
      get offset() {
        return this.isValid ? +this.o : NaN;
      }
      /**
       * Get the short human name for the zone's current offset, for example "EST" or "EDT".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameShort() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "short",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameLong() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "long",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get whether this zone's offset ever changes, as in a DST.
       * @type {boolean}
       */
      get isOffsetFixed() {
        return this.isValid ? this.zone.isUniversal : null;
      }
      /**
       * Get whether the DateTime is in a DST.
       * @type {boolean}
       */
      get isInDST() {
        if (this.isOffsetFixed) {
          return false;
        } else {
          return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
        }
      }
      /**
       * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
       * in this DateTime's zone. During DST changes local time can be ambiguous, for example
       * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
       * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
       * @returns {DateTime[]}
       */
      getPossibleOffsets() {
        if (!this.isValid || this.isOffsetFixed) {
          return [this];
        }
        const dayMs = 864e5;
        const minuteMs = 6e4;
        const localTS = objToLocalTS2(this.c);
        const oEarlier = this.zone.offset(localTS - dayMs);
        const oLater = this.zone.offset(localTS + dayMs);
        const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
        const o2 = this.zone.offset(localTS - oLater * minuteMs);
        if (o1 === o2) {
          return [this];
        }
        const ts1 = localTS - o1 * minuteMs;
        const ts2 = localTS - o2 * minuteMs;
        const c1 = tsToObj2(ts1, o1);
        const c2 = tsToObj2(ts2, o2);
        if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
          return [clone3(this, { ts: ts1 }), clone3(this, { ts: ts2 })];
        }
        return [this];
      }
      /**
       * Returns true if this DateTime is in a leap year, false otherwise
       * @example DateTime.local(2016).isInLeapYear //=> true
       * @example DateTime.local(2013).isInLeapYear //=> false
       * @type {boolean}
       */
      get isInLeapYear() {
        return isLeapYear2(this.year);
      }
      /**
       * Returns the number of days in this DateTime's month
       * @example DateTime.local(2016, 2).daysInMonth //=> 29
       * @example DateTime.local(2016, 3).daysInMonth //=> 31
       * @type {number}
       */
      get daysInMonth() {
        return daysInMonth2(this.year, this.month);
      }
      /**
       * Returns the number of days in this DateTime's year
       * @example DateTime.local(2016).daysInYear //=> 366
       * @example DateTime.local(2013).daysInYear //=> 365
       * @type {number}
       */
      get daysInYear() {
        return this.isValid ? daysInYear2(this.year) : NaN;
      }
      /**
       * Returns the number of weeks in this DateTime's year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2004).weeksInWeekYear //=> 53
       * @example DateTime.local(2013).weeksInWeekYear //=> 52
       * @type {number}
       */
      get weeksInWeekYear() {
        return this.isValid ? weeksInWeekYear2(this.weekYear) : NaN;
      }
      /**
       * Returns the resolved Intl options for this DateTime.
       * This is useful in understanding the behavior of formatting methods
       * @param {Object} opts - the same options as toLocaleString
       * @return {Object}
       */
      resolvedLocaleOptions(opts = {}) {
        const { locale, numberingSystem, calendar } = Formatter2.create(
          this.loc.clone(opts),
          opts
        ).resolvedOptions(this);
        return { locale, numberingSystem, outputCalendar: calendar };
      }
      // TRANSFORM
      /**
       * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
       *
       * Equivalent to {@link DateTime#setZone}('utc')
       * @param {number} [offset=0] - optionally, an offset from UTC in minutes
       * @param {Object} [opts={}] - options to pass to `setZone()`
       * @return {DateTime}
       */
      toUTC(offset3 = 0, opts = {}) {
        return this.setZone(FixedOffsetZone2.instance(offset3), opts);
      }
      /**
       * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
       *
       * Equivalent to `setZone('local')`
       * @return {DateTime}
       */
      toLocal() {
        return this.setZone(Settings2.defaultZone);
      }
      /**
       * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
       *
       * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
       * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
       * @param {Object} opts - options
       * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
       * @return {DateTime}
       */
      setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
        zone = normalizeZone2(zone, Settings2.defaultZone);
        if (zone.equals(this.zone)) {
          return this;
        } else if (!zone.isValid) {
          return _DateTime.invalid(unsupportedZone2(zone));
        } else {
          let newTS = this.ts;
          if (keepLocalTime || keepCalendarTime) {
            const offsetGuess = zone.offset(this.ts);
            const asObj = this.toObject();
            [newTS] = objToTS2(asObj, offsetGuess, zone);
          }
          return clone3(this, { ts: newTS, zone });
        }
      }
      /**
       * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
       * @param {Object} properties - the properties to set
       * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
       * @return {DateTime}
       */
      reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
        return clone3(this, { loc });
      }
      /**
       * "Set" the locale. Returns a newly-constructed DateTime.
       * Just a convenient alias for reconfigure({ locale })
       * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
       * @return {DateTime}
       */
      setLocale(locale) {
        return this.reconfigure({ locale });
      }
      /**
       * "Set" the values of specified units. Returns a newly-constructed DateTime.
       * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
       * @param {Object} values - a mapping of units to numbers
       * @example dt.set({ year: 2017 })
       * @example dt.set({ hour: 8, minute: 30 })
       * @example dt.set({ weekday: 5 })
       * @example dt.set({ year: 2005, ordinal: 234 })
       * @return {DateTime}
       */
      set(values) {
        if (!this.isValid)
          return this;
        const normalized = normalizeObject2(values, normalizeUnit2), settingWeekStuff = !isUndefined2(normalized.weekYear) || !isUndefined2(normalized.weekNumber) || !isUndefined2(normalized.weekday), containsOrdinal = !isUndefined2(normalized.ordinal), containsGregorYear = !isUndefined2(normalized.year), containsGregorMD = !isUndefined2(normalized.month) || !isUndefined2(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError2(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError2("Can't mix ordinal dates with month/day");
        }
        let mixed;
        if (settingWeekStuff) {
          mixed = weekToGregorian2({ ...gregorianToWeek2(this.c), ...normalized });
        } else if (!isUndefined2(normalized.ordinal)) {
          mixed = ordinalToGregorian2({ ...gregorianToOrdinal2(this.c), ...normalized });
        } else {
          mixed = { ...this.toObject(), ...normalized };
          if (isUndefined2(normalized.day)) {
            mixed.day = Math.min(daysInMonth2(mixed.year, mixed.month), mixed.day);
          }
        }
        const [ts, o] = objToTS2(mixed, this.o, this.zone);
        return clone3(this, { ts, o });
      }
      /**
       * Add a period of time to this DateTime and return the resulting DateTime
       *
       * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @example DateTime.now().plus(123) //~> in 123 milliseconds
       * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
       * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
       * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
       * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
       * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
       * @return {DateTime}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration2.fromDurationLike(duration);
        return clone3(this, adjustTime2(this, dur));
      }
      /**
       * Subtract a period of time to this DateTime and return the resulting DateTime
       * See {@link DateTime#plus}
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       @return {DateTime}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration2.fromDurationLike(duration).negate();
        return clone3(this, adjustTime2(this, dur));
      }
      /**
       * "Set" this DateTime to the beginning of a unit of time.
       * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
       * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
       * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
       * @return {DateTime}
       */
      startOf(unit) {
        if (!this.isValid)
          return this;
        const o = {}, normalizedUnit = Duration2.normalizeUnit(unit);
        switch (normalizedUnit) {
          case "years":
            o.month = 1;
          case "quarters":
          case "months":
            o.day = 1;
          case "weeks":
          case "days":
            o.hour = 0;
          case "hours":
            o.minute = 0;
          case "minutes":
            o.second = 0;
          case "seconds":
            o.millisecond = 0;
            break;
        }
        if (normalizedUnit === "weeks") {
          o.weekday = 1;
        }
        if (normalizedUnit === "quarters") {
          const q = Math.ceil(this.month / 3);
          o.month = (q - 1) * 3 + 1;
        }
        return this.set(o);
      }
      /**
       * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
       * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
       * @return {DateTime}
       */
      endOf(unit) {
        return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit).minus(1) : this;
      }
      // OUTPUT
      /**
       * Returns a string representation of this DateTime formatted according to the specified format string.
       * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
       * Defaults to en-US if no locale has been specified, regardless of the system's locale.
       * @param {string} fmt - the format string
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
       * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
       * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
       * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        return this.isValid ? Formatter2.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID5;
      }
      /**
       * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
       * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
       * of the DateTime in the assigned locale.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toLocaleString(); //=> 4/20/2017
       * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
       * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
       * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
       * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
       * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
       * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT2, opts = {}) {
        return this.isValid ? Formatter2.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID5;
      }
      /**
       * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
       * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
       * @example DateTime.now().toLocaleParts(); //=> [
       *                                   //=>   { type: 'day', value: '25' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'month', value: '05' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'year', value: '1982' }
       *                                   //=> ]
       */
      toLocaleParts(opts = {}) {
        return this.isValid ? Formatter2.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
       * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
       * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
       * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
       * @return {string}
       */
      toISO({
        format = "extended",
        suppressSeconds = false,
        suppressMilliseconds = false,
        includeOffset = true,
        extendedZone = false
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        const ext = format === "extended";
        let c = toISODate2(this, ext);
        c += "T";
        c += toISOTime2(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
        return c;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's date component
       * @param {Object} opts - options
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
       * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
       * @return {string}
       */
      toISODate({ format = "extended" } = {}) {
        if (!this.isValid) {
          return null;
        }
        return toISODate2(this, format === "extended");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's week date
       * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
       * @return {string}
       */
      toISOWeekDate() {
        return toTechFormat2(this, "kkkk-'W'WW-c");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's time component
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
       * @return {string}
       */
      toISOTime({
        suppressMilliseconds = false,
        suppressSeconds = false,
        includeOffset = true,
        includePrefix = false,
        extendedZone = false,
        format = "extended"
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        let c = includePrefix ? "T" : "";
        return c + toISOTime2(
          this,
          format === "extended",
          suppressSeconds,
          suppressMilliseconds,
          includeOffset,
          extendedZone
        );
      }
      /**
       * Returns an RFC 2822-compatible string representation of this DateTime
       * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
       * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
       * @return {string}
       */
      toRFC2822() {
        return toTechFormat2(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
       * Specifically, the string conforms to RFC 1123.
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
       * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
       * @return {string}
       */
      toHTTP() {
        return toTechFormat2(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Date
       * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
       * @return {string}
       */
      toSQLDate() {
        if (!this.isValid) {
          return null;
        }
        return toISODate2(this, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Time
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc().toSQL() //=> '05:15:16.345'
       * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
       * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
       * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
       * @return {string}
       */
      toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
        let fmt = "HH:mm:ss.SSS";
        if (includeZone || includeOffset) {
          if (includeOffsetSpace) {
            fmt += " ";
          }
          if (includeZone) {
            fmt += "z";
          } else if (includeOffset) {
            fmt += "ZZ";
          }
        }
        return toTechFormat2(this, fmt, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
       * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
       * @return {string}
       */
      toSQL(opts = {}) {
        if (!this.isValid) {
          return null;
        }
        return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
      }
      /**
       * Returns a string representation of this DateTime appropriate for debugging
       * @return {string}
       */
      toString() {
        return this.isValid ? this.toISO() : INVALID5;
      }
      /**
       * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Returns the epoch milliseconds of this DateTime.
       * @return {number}
       */
      toMillis() {
        return this.isValid ? this.ts : NaN;
      }
      /**
       * Returns the epoch seconds of this DateTime.
       * @return {number}
       */
      toSeconds() {
        return this.isValid ? this.ts / 1e3 : NaN;
      }
      /**
       * Returns the epoch seconds (as a whole number) of this DateTime.
       * @return {number}
       */
      toUnixInteger() {
        return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
      }
      /**
       * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns a BSON serializable equivalent to this DateTime.
       * @return {Date}
       */
      toBSON() {
        return this.toJSDate();
      }
      /**
       * Returns a JavaScript object with this DateTime's year, month, day, and so on.
       * @param opts - options for generating the object
       * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
       * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
       * @return {Object}
       */
      toObject(opts = {}) {
        if (!this.isValid)
          return {};
        const base = { ...this.c };
        if (opts.includeConfig) {
          base.outputCalendar = this.outputCalendar;
          base.numberingSystem = this.loc.numberingSystem;
          base.locale = this.loc.locale;
        }
        return base;
      }
      /**
       * Returns a JavaScript Date equivalent to this DateTime.
       * @return {Date}
       */
      toJSDate() {
        return new Date(this.isValid ? this.ts : NaN);
      }
      // COMPARE
      /**
       * Return the difference between two DateTimes as a Duration.
       * @param {DateTime} otherDateTime - the DateTime to compare this one to
       * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example
       * var i1 = DateTime.fromISO('1982-05-25T09:45'),
       *     i2 = DateTime.fromISO('1983-10-14T10:30');
       * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
       * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
       * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
       * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
       * @return {Duration}
       */
      diff(otherDateTime, unit = "milliseconds", opts = {}) {
        if (!this.isValid || !otherDateTime.isValid) {
          return Duration2.invalid("created by diffing an invalid DateTime");
        }
        const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
        const units = maybeArray2(unit).map(Duration2.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
        return otherIsLater ? diffed.negate() : diffed;
      }
      /**
       * Return the difference between this DateTime and right now.
       * See {@link DateTime#diff}
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      diffNow(unit = "milliseconds", opts = {}) {
        return this.diff(_DateTime.now(), unit, opts);
      }
      /**
       * Return an Interval spanning between this DateTime and another DateTime
       * @param {DateTime} otherDateTime - the other end point of the Interval
       * @return {Interval}
       */
      until(otherDateTime) {
        return this.isValid ? Interval2.fromDateTimes(this, otherDateTime) : this;
      }
      /**
       * Return whether this DateTime is in the same unit of time as another DateTime.
       * Higher-order units must also be identical for this function to return `true`.
       * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
       * @param {DateTime} otherDateTime - the other DateTime
       * @param {string} unit - the unit of time to check sameness on
       * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
       * @return {boolean}
       */
      hasSame(otherDateTime, unit) {
        if (!this.isValid)
          return false;
        const inputMs = otherDateTime.valueOf();
        const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
        return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
      }
      /**
       * Equality check
       * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
       * To compare just the millisecond values, use `+dt1 === +dt2`.
       * @param {DateTime} other - the other DateTime
       * @return {boolean}
       */
      equals(other) {
        return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
      }
      /**
       * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
       * platform supports Intl.RelativeTimeFormat. Rounds down by default.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
       * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
       * @param {boolean} [options.round=true] - whether to round the numbers in the output.
       * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
       * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
       * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
       * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
       * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
       * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
       */
      toRelative(options = {}) {
        if (!this.isValid)
          return null;
        const base = options.base || _DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
        let units = ["years", "months", "days", "hours", "minutes", "seconds"];
        let unit = options.unit;
        if (Array.isArray(options.unit)) {
          units = options.unit;
          unit = void 0;
        }
        return diffRelative2(base, this.plus(padding), {
          ...options,
          numeric: "always",
          units,
          unit
        });
      }
      /**
       * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
       * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
       * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
       * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
       */
      toRelativeCalendar(options = {}) {
        if (!this.isValid)
          return null;
        return diffRelative2(options.base || _DateTime.fromObject({}, { zone: this.zone }), this, {
          ...options,
          numeric: "auto",
          units: ["years", "months", "days"],
          calendary: true
        });
      }
      /**
       * Return the min of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
       * @return {DateTime} the min DateTime, or undefined if called with no argument
       */
      static min(...dateTimes) {
        if (!dateTimes.every(_DateTime.isDateTime)) {
          throw new InvalidArgumentError2("min requires all arguments be DateTimes");
        }
        return bestBy2(dateTimes, (i) => i.valueOf(), Math.min);
      }
      /**
       * Return the max of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
       * @return {DateTime} the max DateTime, or undefined if called with no argument
       */
      static max(...dateTimes) {
        if (!dateTimes.every(_DateTime.isDateTime)) {
          throw new InvalidArgumentError2("max requires all arguments be DateTimes");
        }
        return bestBy2(dateTimes, (i) => i.valueOf(), Math.max);
      }
      // MISC
      /**
       * Explain how a string would be parsed by fromFormat()
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see description)
       * @param {Object} options - options taken by fromFormat()
       * @return {Object}
       */
      static fromFormatExplain(text2, fmt, options = {}) {
        const { locale = null, numberingSystem = null } = options, localeToUse = Locale2.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        });
        return explainFromTokens2(localeToUse, text2, fmt);
      }
      /**
       * @deprecated use fromFormatExplain instead
       */
      static fromStringExplain(text2, fmt, options = {}) {
        return _DateTime.fromFormatExplain(text2, fmt, options);
      }
      // FORMAT PRESETS
      /**
       * {@link DateTime#toLocaleString} format like 10/14/1983
       * @type {Object}
       */
      static get DATE_SHORT() {
        return DATE_SHORT2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED() {
        return DATE_MED2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED_WITH_WEEKDAY() {
        return DATE_MED_WITH_WEEKDAY2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983'
       * @type {Object}
       */
      static get DATE_FULL() {
        return DATE_FULL2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
       * @type {Object}
       */
      static get DATE_HUGE() {
        return DATE_HUGE2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_SIMPLE() {
        return TIME_SIMPLE2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SECONDS() {
        return TIME_WITH_SECONDS2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SHORT_OFFSET() {
        return TIME_WITH_SHORT_OFFSET2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_LONG_OFFSET() {
        return TIME_WITH_LONG_OFFSET2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_SIMPLE() {
        return TIME_24_SIMPLE2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SECONDS() {
        return TIME_24_WITH_SECONDS2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SHORT_OFFSET() {
        return TIME_24_WITH_SHORT_OFFSET2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_LONG_OFFSET() {
        return TIME_24_WITH_LONG_OFFSET2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT() {
        return DATETIME_SHORT2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT_WITH_SECONDS() {
        return DATETIME_SHORT_WITH_SECONDS2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED() {
        return DATETIME_MED2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_SECONDS() {
        return DATETIME_MED_WITH_SECONDS2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_WEEKDAY() {
        return DATETIME_MED_WITH_WEEKDAY2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL() {
        return DATETIME_FULL2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL_WITH_SECONDS() {
        return DATETIME_FULL_WITH_SECONDS2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE() {
        return DATETIME_HUGE2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE_WITH_SECONDS() {
        return DATETIME_HUGE_WITH_SECONDS2;
      }
    };
    function friendlyDateTime2(dateTimeish) {
      if (DateTime2.isDateTime(dateTimeish)) {
        return dateTimeish;
      } else if (dateTimeish && dateTimeish.valueOf && isNumber2(dateTimeish.valueOf())) {
        return DateTime2.fromJSDate(dateTimeish);
      } else if (dateTimeish && typeof dateTimeish === "object") {
        return DateTime2.fromObject(dateTimeish);
      } else {
        throw new InvalidArgumentError2(
          `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
        );
      }
    }
    var DEFAULT_QUERY_SETTINGS = {
      renderNullAs: "\\-",
      taskCompletionTracking: false,
      taskCompletionUseEmojiShorthand: false,
      taskCompletionText: "completion",
      taskCompletionDateFormat: "yyyy-MM-dd",
      recursiveSubTaskCompletion: false,
      warnOnEmptyResult: true,
      refreshEnabled: true,
      refreshInterval: 2500,
      defaultDateFormat: "MMMM dd, yyyy",
      defaultDateTimeFormat: "h:mm a - MMMM dd, yyyy",
      maxRecursiveRenderDepth: 4,
      tableIdColumnName: "File",
      tableGroupColumnName: "Group",
      showResultCount: true
    };
    var DEFAULT_EXPORT_SETTINGS = {
      allowHtml: true
    };
    ({
      ...DEFAULT_QUERY_SETTINGS,
      ...DEFAULT_EXPORT_SETTINGS,
      ...{
        inlineQueryPrefix: "=",
        inlineJsQueryPrefix: "$=",
        inlineQueriesInCodeblocks: true,
        enableInlineDataview: true,
        enableDataviewJs: false,
        enableInlineDataviewJs: false,
        prettyRenderInlineFields: true,
        prettyRenderInlineFieldsInLivePreview: true,
        dataviewJsKeyword: "dataviewjs"
      }
    });
    var Success = class _Success {
      constructor(value) {
        this.value = value;
        this.successful = true;
      }
      map(f) {
        return new _Success(f(this.value));
      }
      flatMap(f) {
        return f(this.value);
      }
      mapErr(f) {
        return this;
      }
      bimap(succ2, _fail) {
        return this.map(succ2);
      }
      orElse(_value) {
        return this.value;
      }
      cast() {
        return this;
      }
      orElseThrow(_message) {
        return this.value;
      }
    };
    var Failure = class _Failure {
      constructor(error) {
        this.error = error;
        this.successful = false;
      }
      map(_f) {
        return this;
      }
      flatMap(_f) {
        return this;
      }
      mapErr(f) {
        return new _Failure(f(this.error));
      }
      bimap(_succ, fail2) {
        return this.mapErr(fail2);
      }
      orElse(value) {
        return value;
      }
      cast() {
        return this;
      }
      orElseThrow(message) {
        if (message)
          throw new Error(message(this.error));
        else
          throw new Error("" + this.error);
      }
    };
    var Result;
    (function(Result2) {
      function success(value) {
        return new Success(value);
      }
      Result2.success = success;
      function failure(error) {
        return new Failure(error);
      }
      Result2.failure = failure;
      function flatMap2(first, second, f) {
        if (first.successful) {
          if (second.successful)
            return f(first.value, second.value);
          else
            return failure(second.error);
        } else {
          return failure(first.error);
        }
      }
      Result2.flatMap2 = flatMap2;
      function map2(first, second, f) {
        return flatMap2(first, second, (a, b) => success(f(a, b)));
      }
      Result2.map2 = map2;
    })(Result || (Result = {}));
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    var parsimmon_umd_min = { exports: {} };
    parsimmon_umd_min.exports;
    (function(module3, exports2) {
      !function(n3, t) {
        module3.exports = t();
      }("undefined" != typeof self ? self : commonjsGlobal, function() {
        return function(n3) {
          var t = {};
          function r(e) {
            if (t[e])
              return t[e].exports;
            var u = t[e] = { i: e, l: false, exports: {} };
            return n3[e].call(u.exports, u, u.exports, r), u.l = true, u.exports;
          }
          return r.m = n3, r.c = t, r.d = function(n4, t2, e) {
            r.o(n4, t2) || Object.defineProperty(n4, t2, { configurable: false, enumerable: true, get: e });
          }, r.r = function(n4) {
            Object.defineProperty(n4, "__esModule", { value: true });
          }, r.n = function(n4) {
            var t2 = n4 && n4.__esModule ? function() {
              return n4.default;
            } : function() {
              return n4;
            };
            return r.d(t2, "a", t2), t2;
          }, r.o = function(n4, t2) {
            return Object.prototype.hasOwnProperty.call(n4, t2);
          }, r.p = "", r(r.s = 0);
        }([function(n3, t, r) {
          function e(n4) {
            if (!(this instanceof e))
              return new e(n4);
            this._ = n4;
          }
          var u = e.prototype;
          function o(n4, t2) {
            for (var r2 = 0; r2 < n4; r2++)
              t2(r2);
          }
          function i(n4, t2, r2) {
            return function(n5, t3) {
              o(t3.length, function(r3) {
                n5(t3[r3], r3, t3);
              });
            }(function(r3, e2, u2) {
              t2 = n4(t2, r3, e2, u2);
            }, r2), t2;
          }
          function a(n4, t2) {
            return i(function(t3, r2, e2, u2) {
              return t3.concat([n4(r2, e2, u2)]);
            }, [], t2);
          }
          function f(n4, t2) {
            var r2 = { v: 0, buf: t2 };
            return o(n4, function() {
              var n5;
              r2 = { v: r2.v << 1 | (n5 = r2.buf, n5[0] >> 7), buf: function(n6) {
                var t3 = i(function(n7, t4, r3, e2) {
                  return n7.concat(r3 === e2.length - 1 ? Buffer.from([t4, 0]).readUInt16BE(0) : e2.readUInt16BE(r3));
                }, [], n6);
                return Buffer.from(a(function(n7) {
                  return (n7 << 1 & 65535) >> 8;
                }, t3));
              }(r2.buf) };
            }), r2;
          }
          function c() {
            return "undefined" != typeof Buffer;
          }
          function s3() {
            if (!c())
              throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
          }
          function l3(n4) {
            s3();
            var t2 = i(function(n5, t3) {
              return n5 + t3;
            }, 0, n4);
            if (t2 % 8 != 0)
              throw new Error("The bits [" + n4.join(", ") + "] add up to " + t2 + " which is not an even number of bytes; the total should be divisible by 8");
            var r2, u2 = t2 / 8, o2 = (r2 = function(n5) {
              return n5 > 48;
            }, i(function(n5, t3) {
              return n5 || (r2(t3) ? t3 : n5);
            }, null, n4));
            if (o2)
              throw new Error(o2 + " bit range requested exceeds 48 bit (6 byte) Number max.");
            return new e(function(t3, r3) {
              var e2 = u2 + r3;
              return e2 > t3.length ? x(r3, u2.toString() + " bytes") : b(e2, i(function(n5, t4) {
                var r4 = f(t4, n5.buf);
                return { coll: n5.coll.concat(r4.v), buf: r4.buf };
              }, { coll: [], buf: t3.slice(r3, e2) }, n4).coll);
            });
          }
          function h(n4, t2) {
            return new e(function(r2, e2) {
              return s3(), e2 + t2 > r2.length ? x(e2, t2 + " bytes for " + n4) : b(e2 + t2, r2.slice(e2, e2 + t2));
            });
          }
          function p(n4, t2) {
            if ("number" != typeof (r2 = t2) || Math.floor(r2) !== r2 || t2 < 0 || t2 > 6)
              throw new Error(n4 + " requires integer length in range [0, 6].");
            var r2;
          }
          function d(n4) {
            return p("uintBE", n4), h("uintBE(" + n4 + ")", n4).map(function(t2) {
              return t2.readUIntBE(0, n4);
            });
          }
          function v(n4) {
            return p("uintLE", n4), h("uintLE(" + n4 + ")", n4).map(function(t2) {
              return t2.readUIntLE(0, n4);
            });
          }
          function g(n4) {
            return p("intBE", n4), h("intBE(" + n4 + ")", n4).map(function(t2) {
              return t2.readIntBE(0, n4);
            });
          }
          function m(n4) {
            return p("intLE", n4), h("intLE(" + n4 + ")", n4).map(function(t2) {
              return t2.readIntLE(0, n4);
            });
          }
          function y(n4) {
            return n4 instanceof e;
          }
          function E(n4) {
            return "[object Array]" === {}.toString.call(n4);
          }
          function w(n4) {
            return c() && Buffer.isBuffer(n4);
          }
          function b(n4, t2) {
            return { status: true, index: n4, value: t2, furthest: -1, expected: [] };
          }
          function x(n4, t2) {
            return E(t2) || (t2 = [t2]), { status: false, index: -1, value: null, furthest: n4, expected: t2 };
          }
          function B(n4, t2) {
            if (!t2)
              return n4;
            if (n4.furthest > t2.furthest)
              return n4;
            var r2 = n4.furthest === t2.furthest ? function(n5, t3) {
              if (function() {
                if (void 0 !== e._supportsSet)
                  return e._supportsSet;
                var n6 = "undefined" != typeof Set;
                return e._supportsSet = n6, n6;
              }() && Array.from) {
                for (var r3 = new Set(n5), u2 = 0; u2 < t3.length; u2++)
                  r3.add(t3[u2]);
                var o2 = Array.from(r3);
                return o2.sort(), o2;
              }
              for (var i2 = {}, a2 = 0; a2 < n5.length; a2++)
                i2[n5[a2]] = true;
              for (var f2 = 0; f2 < t3.length; f2++)
                i2[t3[f2]] = true;
              var c2 = [];
              for (var s4 in i2)
                ({}).hasOwnProperty.call(i2, s4) && c2.push(s4);
              return c2.sort(), c2;
            }(n4.expected, t2.expected) : t2.expected;
            return { status: n4.status, index: n4.index, value: n4.value, furthest: t2.furthest, expected: r2 };
          }
          var j = {};
          function S(n4, t2) {
            if (w(n4))
              return { offset: t2, line: -1, column: -1 };
            n4 in j || (j[n4] = {});
            for (var r2 = j[n4], e2 = 0, u2 = 0, o2 = 0, i2 = t2; i2 >= 0; ) {
              if (i2 in r2) {
                e2 = r2[i2].line, 0 === o2 && (o2 = r2[i2].lineStart);
                break;
              }
              ("\n" === n4.charAt(i2) || "\r" === n4.charAt(i2) && "\n" !== n4.charAt(i2 + 1)) && (u2++, 0 === o2 && (o2 = i2 + 1)), i2--;
            }
            var a2 = e2 + u2, f2 = t2 - o2;
            return r2[t2] = { line: a2, lineStart: o2 }, { offset: t2, line: a2 + 1, column: f2 + 1 };
          }
          function _(n4) {
            if (!y(n4))
              throw new Error("not a parser: " + n4);
          }
          function L(n4, t2) {
            return "string" == typeof n4 ? n4.charAt(t2) : n4[t2];
          }
          function O(n4) {
            if ("number" != typeof n4)
              throw new Error("not a number: " + n4);
          }
          function k(n4) {
            if ("function" != typeof n4)
              throw new Error("not a function: " + n4);
          }
          function P(n4) {
            if ("string" != typeof n4)
              throw new Error("not a string: " + n4);
          }
          var q = 2, A = 3, I = 8, F = 5 * I, M = 4 * I, z2 = "  ";
          function R(n4, t2) {
            return new Array(t2 + 1).join(n4);
          }
          function U(n4, t2, r2) {
            var e2 = t2 - n4.length;
            return e2 <= 0 ? n4 : R(r2, e2) + n4;
          }
          function W(n4, t2, r2, e2) {
            return { from: n4 - t2 > 0 ? n4 - t2 : 0, to: n4 + r2 > e2 ? e2 : n4 + r2 };
          }
          function D(n4, t2) {
            var r2, e2, u2, o2, f2, c2 = t2.index, s4 = c2.offset, l4 = 1;
            if (s4 === n4.length)
              return "Got the end of the input";
            if (w(n4)) {
              var h2 = s4 - s4 % I, p2 = s4 - h2, d2 = W(h2, F, M + I, n4.length), v2 = a(function(n5) {
                return a(function(n6) {
                  return U(n6.toString(16), 2, "0");
                }, n5);
              }, function(n5, t3) {
                var r3 = n5.length, e3 = [], u3 = 0;
                if (r3 <= t3)
                  return [n5.slice()];
                for (var o3 = 0; o3 < r3; o3++)
                  e3[u3] || e3.push([]), e3[u3].push(n5[o3]), (o3 + 1) % t3 == 0 && u3++;
                return e3;
              }(n4.slice(d2.from, d2.to).toJSON().data, I));
              o2 = function(n5) {
                return 0 === n5.from && 1 === n5.to ? { from: n5.from, to: n5.to } : { from: n5.from / I, to: Math.floor(n5.to / I) };
              }(d2), e2 = h2 / I, r2 = 3 * p2, p2 >= 4 && (r2 += 1), l4 = 2, u2 = a(function(n5) {
                return n5.length <= 4 ? n5.join(" ") : n5.slice(0, 4).join(" ") + "  " + n5.slice(4).join(" ");
              }, v2), (f2 = (8 * (o2.to > 0 ? o2.to - 1 : o2.to)).toString(16).length) < 2 && (f2 = 2);
            } else {
              var g2 = n4.split(/\r\n|[\n\r\u2028\u2029]/);
              r2 = c2.column - 1, e2 = c2.line - 1, o2 = W(e2, q, A, g2.length), u2 = g2.slice(o2.from, o2.to), f2 = o2.to.toString().length;
            }
            var m2 = e2 - o2.from;
            return w(n4) && (f2 = (8 * (o2.to > 0 ? o2.to - 1 : o2.to)).toString(16).length) < 2 && (f2 = 2), i(function(t3, e3, u3) {
              var i2, a2 = u3 === m2, c3 = a2 ? "> " : z2;
              return i2 = w(n4) ? U((8 * (o2.from + u3)).toString(16), f2, "0") : U((o2.from + u3 + 1).toString(), f2, " "), [].concat(t3, [c3 + i2 + " | " + e3], a2 ? [z2 + R(" ", f2) + " | " + U("", r2, " ") + R("^", l4)] : []);
            }, [], u2).join("\n");
          }
          function N(n4, t2) {
            return ["\n", "-- PARSING FAILED " + R("-", 50), "\n\n", D(n4, t2), "\n\n", (r2 = t2.expected, 1 === r2.length ? "Expected:\n\n" + r2[0] : "Expected one of the following: \n\n" + r2.join(", ")), "\n"].join("");
            var r2;
          }
          function G(n4) {
            return void 0 !== n4.flags ? n4.flags : [n4.global ? "g" : "", n4.ignoreCase ? "i" : "", n4.multiline ? "m" : "", n4.unicode ? "u" : "", n4.sticky ? "y" : ""].join("");
          }
          function C() {
            for (var n4 = [].slice.call(arguments), t2 = n4.length, r2 = 0; r2 < t2; r2 += 1)
              _(n4[r2]);
            return e(function(r3, e2) {
              for (var u2, o2 = new Array(t2), i2 = 0; i2 < t2; i2 += 1) {
                if (!(u2 = B(n4[i2]._(r3, e2), u2)).status)
                  return u2;
                o2[i2] = u2.value, e2 = u2.index;
              }
              return B(b(e2, o2), u2);
            });
          }
          function J() {
            var n4 = [].slice.call(arguments);
            if (0 === n4.length)
              throw new Error("seqMap needs at least one argument");
            var t2 = n4.pop();
            return k(t2), C.apply(null, n4).map(function(n5) {
              return t2.apply(null, n5);
            });
          }
          function T() {
            var n4 = [].slice.call(arguments), t2 = n4.length;
            if (0 === t2)
              return Y("zero alternates");
            for (var r2 = 0; r2 < t2; r2 += 1)
              _(n4[r2]);
            return e(function(t3, r3) {
              for (var e2, u2 = 0; u2 < n4.length; u2 += 1)
                if ((e2 = B(n4[u2]._(t3, r3), e2)).status)
                  return e2;
              return e2;
            });
          }
          function V(n4, t2) {
            return H(n4, t2).or(X([]));
          }
          function H(n4, t2) {
            return _(n4), _(t2), J(n4, t2.then(n4).many(), function(n5, t3) {
              return [n5].concat(t3);
            });
          }
          function K(n4) {
            P(n4);
            var t2 = "'" + n4 + "'";
            return e(function(r2, e2) {
              var u2 = e2 + n4.length, o2 = r2.slice(e2, u2);
              return o2 === n4 ? b(u2, o2) : x(e2, t2);
            });
          }
          function Q(n4, t2) {
            !function(n5) {
              if (!(n5 instanceof RegExp))
                throw new Error("not a regexp: " + n5);
              for (var t3 = G(n5), r3 = 0; r3 < t3.length; r3++) {
                var e2 = t3.charAt(r3);
                if ("i" !== e2 && "m" !== e2 && "u" !== e2 && "s" !== e2)
                  throw new Error('unsupported regexp flag "' + e2 + '": ' + n5);
              }
            }(n4), arguments.length >= 2 ? O(t2) : t2 = 0;
            var r2 = function(n5) {
              return RegExp("^(?:" + n5.source + ")", G(n5));
            }(n4), u2 = "" + n4;
            return e(function(n5, e2) {
              var o2 = r2.exec(n5.slice(e2));
              if (o2) {
                if (0 <= t2 && t2 <= o2.length) {
                  var i2 = o2[0], a2 = o2[t2];
                  return b(e2 + i2.length, a2);
                }
                return x(e2, "valid match group (0 to " + o2.length + ") in " + u2);
              }
              return x(e2, u2);
            });
          }
          function X(n4) {
            return e(function(t2, r2) {
              return b(r2, n4);
            });
          }
          function Y(n4) {
            return e(function(t2, r2) {
              return x(r2, n4);
            });
          }
          function Z(n4) {
            if (y(n4))
              return e(function(t2, r2) {
                var e2 = n4._(t2, r2);
                return e2.index = r2, e2.value = "", e2;
              });
            if ("string" == typeof n4)
              return Z(K(n4));
            if (n4 instanceof RegExp)
              return Z(Q(n4));
            throw new Error("not a string, regexp, or parser: " + n4);
          }
          function $(n4) {
            return _(n4), e(function(t2, r2) {
              var e2 = n4._(t2, r2), u2 = t2.slice(r2, e2.index);
              return e2.status ? x(r2, 'not "' + u2 + '"') : b(r2, null);
            });
          }
          function nn(n4) {
            return k(n4), e(function(t2, r2) {
              var e2 = L(t2, r2);
              return r2 < t2.length && n4(e2) ? b(r2 + 1, e2) : x(r2, "a character/byte matching " + n4);
            });
          }
          function tn(n4, t2) {
            arguments.length < 2 && (t2 = n4, n4 = void 0);
            var r2 = e(function(n5, e2) {
              return r2._ = t2()._, r2._(n5, e2);
            });
            return n4 ? r2.desc(n4) : r2;
          }
          function rn() {
            return Y("fantasy-land/empty");
          }
          u.parse = function(n4) {
            if ("string" != typeof n4 && !w(n4))
              throw new Error(".parse must be called with a string or Buffer as its argument");
            var t2, r2 = this.skip(an)._(n4, 0);
            return t2 = r2.status ? { status: true, value: r2.value } : { status: false, index: S(n4, r2.furthest), expected: r2.expected }, delete j[n4], t2;
          }, u.tryParse = function(n4) {
            var t2 = this.parse(n4);
            if (t2.status)
              return t2.value;
            var r2 = N(n4, t2), e2 = new Error(r2);
            throw e2.type = "ParsimmonError", e2.result = t2, e2;
          }, u.assert = function(n4, t2) {
            return this.chain(function(r2) {
              return n4(r2) ? X(r2) : Y(t2);
            });
          }, u.or = function(n4) {
            return T(this, n4);
          }, u.trim = function(n4) {
            return this.wrap(n4, n4);
          }, u.wrap = function(n4, t2) {
            return J(n4, this, t2, function(n5, t3) {
              return t3;
            });
          }, u.thru = function(n4) {
            return n4(this);
          }, u.then = function(n4) {
            return _(n4), C(this, n4).map(function(n5) {
              return n5[1];
            });
          }, u.many = function() {
            var n4 = this;
            return e(function(t2, r2) {
              for (var e2 = [], u2 = void 0; ; ) {
                if (!(u2 = B(n4._(t2, r2), u2)).status)
                  return B(b(r2, e2), u2);
                if (r2 === u2.index)
                  throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
                r2 = u2.index, e2.push(u2.value);
              }
            });
          }, u.tieWith = function(n4) {
            return P(n4), this.map(function(t2) {
              if (function(n5) {
                if (!E(n5))
                  throw new Error("not an array: " + n5);
              }(t2), t2.length) {
                P(t2[0]);
                for (var r2 = t2[0], e2 = 1; e2 < t2.length; e2++)
                  P(t2[e2]), r2 += n4 + t2[e2];
                return r2;
              }
              return "";
            });
          }, u.tie = function() {
            return this.tieWith("");
          }, u.times = function(n4, t2) {
            var r2 = this;
            return arguments.length < 2 && (t2 = n4), O(n4), O(t2), e(function(e2, u2) {
              for (var o2 = [], i2 = void 0, a2 = void 0, f2 = 0; f2 < n4; f2 += 1) {
                if (a2 = B(i2 = r2._(e2, u2), a2), !i2.status)
                  return a2;
                u2 = i2.index, o2.push(i2.value);
              }
              for (; f2 < t2 && (a2 = B(i2 = r2._(e2, u2), a2), i2.status); f2 += 1)
                u2 = i2.index, o2.push(i2.value);
              return B(b(u2, o2), a2);
            });
          }, u.result = function(n4) {
            return this.map(function() {
              return n4;
            });
          }, u.atMost = function(n4) {
            return this.times(0, n4);
          }, u.atLeast = function(n4) {
            return J(this.times(n4), this.many(), function(n5, t2) {
              return n5.concat(t2);
            });
          }, u.map = function(n4) {
            k(n4);
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2._(r2, e2);
              return u2.status ? B(b(u2.index, n4(u2.value)), u2) : u2;
            });
          }, u.contramap = function(n4) {
            k(n4);
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2.parse(n4(r2.slice(e2)));
              return u2.status ? b(e2 + r2.length, u2.value) : u2;
            });
          }, u.promap = function(n4, t2) {
            return k(n4), k(t2), this.contramap(n4).map(t2);
          }, u.skip = function(n4) {
            return C(this, n4).map(function(n5) {
              return n5[0];
            });
          }, u.mark = function() {
            return J(en, this, en, function(n4, t2, r2) {
              return { start: n4, value: t2, end: r2 };
            });
          }, u.node = function(n4) {
            return J(en, this, en, function(t2, r2, e2) {
              return { name: n4, value: r2, start: t2, end: e2 };
            });
          }, u.sepBy = function(n4) {
            return V(this, n4);
          }, u.sepBy1 = function(n4) {
            return H(this, n4);
          }, u.lookahead = function(n4) {
            return this.skip(Z(n4));
          }, u.notFollowedBy = function(n4) {
            return this.skip($(n4));
          }, u.desc = function(n4) {
            E(n4) || (n4 = [n4]);
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2._(r2, e2);
              return u2.status || (u2.expected = n4), u2;
            });
          }, u.fallback = function(n4) {
            return this.or(X(n4));
          }, u.ap = function(n4) {
            return J(n4, this, function(n5, t2) {
              return n5(t2);
            });
          }, u.chain = function(n4) {
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2._(r2, e2);
              return u2.status ? B(n4(u2.value)._(r2, u2.index), u2) : u2;
            });
          }, u.concat = u.or, u.empty = rn, u.of = X, u["fantasy-land/ap"] = u.ap, u["fantasy-land/chain"] = u.chain, u["fantasy-land/concat"] = u.concat, u["fantasy-land/empty"] = u.empty, u["fantasy-land/of"] = u.of, u["fantasy-land/map"] = u.map;
          var en = e(function(n4, t2) {
            return b(t2, S(n4, t2));
          }), un = e(function(n4, t2) {
            return t2 >= n4.length ? x(t2, "any character/byte") : b(t2 + 1, L(n4, t2));
          }), on = e(function(n4, t2) {
            return b(n4.length, n4.slice(t2));
          }), an = e(function(n4, t2) {
            return t2 < n4.length ? x(t2, "EOF") : b(t2, null);
          }), fn = Q(/[0-9]/).desc("a digit"), cn = Q(/[0-9]*/).desc("optional digits"), sn = Q(/[a-z]/i).desc("a letter"), ln = Q(/[a-z]*/i).desc("optional letters"), hn = Q(/\s*/).desc("optional whitespace"), pn = Q(/\s+/).desc("whitespace"), dn = K("\r"), vn = K("\n"), gn = K("\r\n"), mn = T(gn, vn, dn).desc("newline"), yn = T(mn, an);
          e.all = on, e.alt = T, e.any = un, e.cr = dn, e.createLanguage = function(n4) {
            var t2 = {};
            for (var r2 in n4)
              ({}).hasOwnProperty.call(n4, r2) && function(r3) {
                t2[r3] = tn(function() {
                  return n4[r3](t2);
                });
              }(r2);
            return t2;
          }, e.crlf = gn, e.custom = function(n4) {
            return e(n4(b, x));
          }, e.digit = fn, e.digits = cn, e.empty = rn, e.end = yn, e.eof = an, e.fail = Y, e.formatError = N, e.index = en, e.isParser = y, e.lazy = tn, e.letter = sn, e.letters = ln, e.lf = vn, e.lookahead = Z, e.makeFailure = x, e.makeSuccess = b, e.newline = mn, e.noneOf = function(n4) {
            return nn(function(t2) {
              return n4.indexOf(t2) < 0;
            }).desc("none of '" + n4 + "'");
          }, e.notFollowedBy = $, e.of = X, e.oneOf = function(n4) {
            for (var t2 = n4.split(""), r2 = 0; r2 < t2.length; r2++)
              t2[r2] = "'" + t2[r2] + "'";
            return nn(function(t3) {
              return n4.indexOf(t3) >= 0;
            }).desc(t2);
          }, e.optWhitespace = hn, e.Parser = e, e.range = function(n4, t2) {
            return nn(function(r2) {
              return n4 <= r2 && r2 <= t2;
            }).desc(n4 + "-" + t2);
          }, e.regex = Q, e.regexp = Q, e.sepBy = V, e.sepBy1 = H, e.seq = C, e.seqMap = J, e.seqObj = function() {
            for (var n4, t2 = {}, r2 = 0, u2 = (n4 = arguments, Array.prototype.slice.call(n4)), o2 = u2.length, i2 = 0; i2 < o2; i2 += 1) {
              var a2 = u2[i2];
              if (!y(a2)) {
                if (E(a2) && 2 === a2.length && "string" == typeof a2[0] && y(a2[1])) {
                  var f2 = a2[0];
                  if (Object.prototype.hasOwnProperty.call(t2, f2))
                    throw new Error("seqObj: duplicate key " + f2);
                  t2[f2] = true, r2++;
                  continue;
                }
                throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
              }
            }
            if (0 === r2)
              throw new Error("seqObj expects at least one named parser, found zero");
            return e(function(n5, t3) {
              for (var r3, e2 = {}, i3 = 0; i3 < o2; i3 += 1) {
                var a3, f3;
                if (E(u2[i3]) ? (a3 = u2[i3][0], f3 = u2[i3][1]) : (a3 = null, f3 = u2[i3]), !(r3 = B(f3._(n5, t3), r3)).status)
                  return r3;
                a3 && (e2[a3] = r3.value), t3 = r3.index;
              }
              return B(b(t3, e2), r3);
            });
          }, e.string = K, e.succeed = X, e.takeWhile = function(n4) {
            return k(n4), e(function(t2, r2) {
              for (var e2 = r2; e2 < t2.length && n4(L(t2, e2)); )
                e2++;
              return b(e2, t2.slice(r2, e2));
            });
          }, e.test = nn, e.whitespace = pn, e["fantasy-land/empty"] = rn, e["fantasy-land/of"] = X, e.Binary = { bitSeq: l3, bitSeqObj: function(n4) {
            s3();
            var t2 = {}, r2 = 0, e2 = a(function(n5) {
              if (E(n5)) {
                var e3 = n5;
                if (2 !== e3.length)
                  throw new Error("[" + e3.join(", ") + "] should be length 2, got length " + e3.length);
                if (P(e3[0]), O(e3[1]), Object.prototype.hasOwnProperty.call(t2, e3[0]))
                  throw new Error("duplicate key in bitSeqObj: " + e3[0]);
                return t2[e3[0]] = true, r2++, e3;
              }
              return O(n5), [null, n5];
            }, n4);
            if (r2 < 1)
              throw new Error("bitSeqObj expects at least one named pair, got [" + n4.join(", ") + "]");
            var u2 = a(function(n5) {
              return n5[0];
            }, e2);
            return l3(a(function(n5) {
              return n5[1];
            }, e2)).map(function(n5) {
              return i(function(n6, t3) {
                return null !== t3[0] && (n6[t3[0]] = t3[1]), n6;
              }, {}, a(function(t3, r3) {
                return [t3, n5[r3]];
              }, u2));
            });
          }, byte: function(n4) {
            if (s3(), O(n4), n4 > 255)
              throw new Error("Value specified to byte constructor (" + n4 + "=0x" + n4.toString(16) + ") is larger in value than a single byte.");
            var t2 = (n4 > 15 ? "0x" : "0x0") + n4.toString(16);
            return e(function(r2, e2) {
              var u2 = L(r2, e2);
              return u2 === n4 ? b(e2 + 1, u2) : x(e2, t2);
            });
          }, buffer: function(n4) {
            return h("buffer", n4).map(function(n5) {
              return Buffer.from(n5);
            });
          }, encodedString: function(n4, t2) {
            return h("string", t2).map(function(t3) {
              return t3.toString(n4);
            });
          }, uintBE: d, uint8BE: d(1), uint16BE: d(2), uint32BE: d(4), uintLE: v, uint8LE: v(1), uint16LE: v(2), uint32LE: v(4), intBE: g, int8BE: g(1), int16BE: g(2), int32BE: g(4), intLE: m, int8LE: m(1), int16LE: m(2), int32LE: m(4), floatBE: h("floatBE", 4).map(function(n4) {
            return n4.readFloatBE(0);
          }), floatLE: h("floatLE", 4).map(function(n4) {
            return n4.readFloatLE(0);
          }), doubleBE: h("doubleBE", 8).map(function(n4) {
            return n4.readDoubleBE(0);
          }), doubleLE: h("doubleLE", 8).map(function(n4) {
            return n4.readDoubleLE(0);
          }) }, n3.exports = e;
        }]);
      });
    })(parsimmon_umd_min, parsimmon_umd_min.exports);
    var parsimmon_umd_minExports = parsimmon_umd_min.exports;
    var emojiRegex2 = () => {
      return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
    };
    function normalizeDuration(dur) {
      if (dur === void 0 || dur === null)
        return dur;
      return dur.shiftToAll().normalize();
    }
    function getFileTitle(path) {
      if (path.includes("/"))
        path = path.substring(path.lastIndexOf("/") + 1);
      if (path.endsWith(".md"))
        path = path.substring(0, path.length - 3);
      return path;
    }
    parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regex(new RegExp(emojiRegex2(), "")), parsimmon_umd_minExports.regex(/[0-9\p{Letter}_-]+/u).map((str) => str.toLocaleLowerCase()), parsimmon_umd_minExports.whitespace.map((_) => "-"), parsimmon_umd_minExports.any.map((_) => "")).many().map((result) => result.join(""));
    var HEADER_CANONICALIZER = parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regex(new RegExp(emojiRegex2(), "")), parsimmon_umd_minExports.regex(/[0-9\p{Letter}_-]+/u), parsimmon_umd_minExports.whitespace.map((_) => " "), parsimmon_umd_minExports.any.map((_) => " ")).many().map((result) => {
      return result.join("").split(/\s+/).join(" ").trim();
    });
    function normalizeHeaderForLink(header) {
      return HEADER_CANONICALIZER.tryParse(header);
    }
    function renderMinimalDuration(dur) {
      dur = normalizeDuration(dur);
      dur = Duration2.fromObject(Object.fromEntries(Object.entries(dur.toObject()).filter(([, quantity]) => quantity != 0)));
      return dur.toHuman();
    }
    var Values;
    (function(Values2) {
      function toString(field, setting = DEFAULT_QUERY_SETTINGS, recursive = false) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return setting.renderNullAs;
        switch (wrapped.type) {
          case "null":
            return setting.renderNullAs;
          case "string":
            return wrapped.value;
          case "number":
          case "boolean":
            return "" + wrapped.value;
          case "html":
            return wrapped.value.outerHTML;
          case "widget":
            return wrapped.value.markdown();
          case "link":
            return wrapped.value.markdown();
          case "function":
            return "<function>";
          case "array":
            let result = "";
            if (recursive)
              result += "[";
            result += wrapped.value.map((f) => toString(f, setting, true)).join(", ");
            if (recursive)
              result += "]";
            return result;
          case "object":
            return "{ " + Object.entries(wrapped.value).map((e) => e[0] + ": " + toString(e[1], setting, true)).join(", ") + " }";
          case "date":
            if (wrapped.value.second == 0 && wrapped.value.hour == 0 && wrapped.value.minute == 0) {
              return wrapped.value.toFormat(setting.defaultDateFormat);
            }
            return wrapped.value.toFormat(setting.defaultDateTimeFormat);
          case "duration":
            return renderMinimalDuration(wrapped.value);
        }
      }
      Values2.toString = toString;
      function wrapValue(val) {
        if (isNull(val))
          return { type: "null", value: val };
        else if (isNumber3(val))
          return { type: "number", value: val };
        else if (isString3(val))
          return { type: "string", value: val };
        else if (isBoolean(val))
          return { type: "boolean", value: val };
        else if (isDuration(val))
          return { type: "duration", value: val };
        else if (isDate3(val))
          return { type: "date", value: val };
        else if (isWidget(val))
          return { type: "widget", value: val };
        else if (isArray(val))
          return { type: "array", value: val };
        else if (isLink(val))
          return { type: "link", value: val };
        else if (isFunction(val))
          return { type: "function", value: val };
        else if (isHtml(val))
          return { type: "html", value: val };
        else if (isObject(val))
          return { type: "object", value: val };
        else
          return void 0;
      }
      Values2.wrapValue = wrapValue;
      function mapLeaves(val, func) {
        if (isObject(val)) {
          let result = {};
          for (let [key, value] of Object.entries(val))
            result[key] = mapLeaves(value, func);
          return result;
        } else if (isArray(val)) {
          let result = [];
          for (let value of val)
            result.push(mapLeaves(value, func));
          return result;
        } else {
          return func(val);
        }
      }
      Values2.mapLeaves = mapLeaves;
      function compareValue(val1, val2, linkNormalizer) {
        var _a, _b;
        if (val1 === void 0)
          val1 = null;
        if (val2 === void 0)
          val2 = null;
        if (val1 === null && val2 === null)
          return 0;
        else if (val1 === null)
          return -1;
        else if (val2 === null)
          return 1;
        let wrap1 = wrapValue(val1);
        let wrap2 = wrapValue(val2);
        if (wrap1 === void 0 && wrap2 === void 0)
          return 0;
        else if (wrap1 === void 0)
          return -1;
        else if (wrap2 === void 0)
          return 1;
        if (wrap1.type != wrap2.type)
          return wrap1.type.localeCompare(wrap2.type);
        if (wrap1.value === wrap2.value)
          return 0;
        switch (wrap1.type) {
          case "string":
            return wrap1.value.localeCompare(wrap2.value);
          case "number":
            if (wrap1.value < wrap2.value)
              return -1;
            else if (wrap1.value == wrap2.value)
              return 0;
            return 1;
          case "null":
            return 0;
          case "boolean":
            if (wrap1.value == wrap2.value)
              return 0;
            else
              return wrap1.value ? 1 : -1;
          case "link":
            let link1 = wrap1.value;
            let link2 = wrap2.value;
            let normalize = linkNormalizer !== null && linkNormalizer !== void 0 ? linkNormalizer : (x) => x;
            let pathCompare = normalize(link1.path).localeCompare(normalize(link2.path));
            if (pathCompare != 0)
              return pathCompare;
            let typeCompare = link1.type.localeCompare(link2.type);
            if (typeCompare != 0)
              return typeCompare;
            if (link1.subpath && !link2.subpath)
              return 1;
            if (!link1.subpath && link2.subpath)
              return -1;
            if (!link1.subpath && !link2.subpath)
              return 0;
            return ((_a = link1.subpath) !== null && _a !== void 0 ? _a : "").localeCompare((_b = link2.subpath) !== null && _b !== void 0 ? _b : "");
          case "date":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "duration":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "array":
            let f1 = wrap1.value;
            let f2 = wrap2.value;
            for (let index = 0; index < Math.min(f1.length, f2.length); index++) {
              let comp = compareValue(f1[index], f2[index]);
              if (comp != 0)
                return comp;
            }
            return f1.length - f2.length;
          case "object":
            let o1 = wrap1.value;
            let o2 = wrap2.value;
            let k1 = Array.from(Object.keys(o1));
            let k2 = Array.from(Object.keys(o2));
            k1.sort();
            k2.sort();
            let keyCompare = compareValue(k1, k2);
            if (keyCompare != 0)
              return keyCompare;
            for (let key of k1) {
              let comp = compareValue(o1[key], o2[key]);
              if (comp != 0)
                return comp;
            }
            return 0;
          case "widget":
          case "html":
          case "function":
            return 0;
        }
      }
      Values2.compareValue = compareValue;
      function typeOf(val) {
        var _a;
        return (_a = wrapValue(val)) === null || _a === void 0 ? void 0 : _a.type;
      }
      Values2.typeOf = typeOf;
      function isTruthy(field) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return false;
        switch (wrapped.type) {
          case "number":
            return wrapped.value != 0;
          case "string":
            return wrapped.value.length > 0;
          case "boolean":
            return wrapped.value;
          case "link":
            return !!wrapped.value.path;
          case "date":
            return wrapped.value.toMillis() != 0;
          case "duration":
            return wrapped.value.as("seconds") != 0;
          case "object":
            return Object.keys(wrapped.value).length > 0;
          case "array":
            return wrapped.value.length > 0;
          case "null":
            return false;
          case "html":
          case "widget":
          case "function":
            return true;
        }
      }
      Values2.isTruthy = isTruthy;
      function deepCopy(field) {
        if (field === null || field === void 0)
          return field;
        if (Values2.isArray(field)) {
          return [].concat(field.map((v) => deepCopy(v)));
        } else if (Values2.isObject(field)) {
          let result = {};
          for (let [key, value] of Object.entries(field))
            result[key] = deepCopy(value);
          return result;
        } else {
          return field;
        }
      }
      Values2.deepCopy = deepCopy;
      function isString3(val) {
        return typeof val == "string";
      }
      Values2.isString = isString3;
      function isNumber3(val) {
        return typeof val == "number";
      }
      Values2.isNumber = isNumber3;
      function isDate3(val) {
        return val instanceof DateTime2;
      }
      Values2.isDate = isDate3;
      function isDuration(val) {
        return val instanceof Duration2;
      }
      Values2.isDuration = isDuration;
      function isNull(val) {
        return val === null || val === void 0;
      }
      Values2.isNull = isNull;
      function isArray(val) {
        return Array.isArray(val);
      }
      Values2.isArray = isArray;
      function isBoolean(val) {
        return typeof val === "boolean";
      }
      Values2.isBoolean = isBoolean;
      function isLink(val) {
        return val instanceof Link;
      }
      Values2.isLink = isLink;
      function isWidget(val) {
        return val instanceof Widget;
      }
      Values2.isWidget = isWidget;
      function isHtml(val) {
        if (typeof HTMLElement !== "undefined") {
          return val instanceof HTMLElement;
        } else {
          return false;
        }
      }
      Values2.isHtml = isHtml;
      function isObject(val) {
        return typeof val == "object" && !isHtml(val) && !isWidget(val) && !isArray(val) && !isDuration(val) && !isDate3(val) && !isLink(val) && val !== void 0 && !isNull(val);
      }
      Values2.isObject = isObject;
      function isFunction(val) {
        return typeof val == "function";
      }
      Values2.isFunction = isFunction;
    })(Values || (Values = {}));
    var Groupings;
    (function(Groupings2) {
      function isElementGroup(entry) {
        return Values.isObject(entry) && Object.keys(entry).length == 2 && "key" in entry && "rows" in entry;
      }
      Groupings2.isElementGroup = isElementGroup;
      function isGrouping(entry) {
        for (let element2 of entry)
          if (!isElementGroup(element2))
            return false;
        return true;
      }
      Groupings2.isGrouping = isGrouping;
      function count(elements) {
        if (isGrouping(elements)) {
          let result = 0;
          for (let subgroup of elements)
            result += count(subgroup.rows);
          return result;
        } else {
          return elements.length;
        }
      }
      Groupings2.count = count;
    })(Groupings || (Groupings = {}));
    var Link = class _Link {
      /** Create a link to a specific file. */
      static file(path, embed = false, display) {
        return new _Link({
          path,
          embed,
          display,
          subpath: void 0,
          type: "file"
        });
      }
      static infer(linkpath, embed = false, display) {
        if (linkpath.includes("#^")) {
          let split = linkpath.split("#^");
          return _Link.block(split[0], split[1], embed, display);
        } else if (linkpath.includes("#")) {
          let split = linkpath.split("#");
          return _Link.header(split[0], split[1], embed, display);
        } else
          return _Link.file(linkpath, embed, display);
      }
      /** Create a link to a specific file and header in that file. */
      static header(path, header, embed, display) {
        return new _Link({
          path,
          embed,
          display,
          subpath: normalizeHeaderForLink(header),
          type: "header"
        });
      }
      /** Create a link to a specific file and block in that file. */
      static block(path, blockId, embed, display) {
        return new _Link({
          path,
          embed,
          display,
          subpath: blockId,
          type: "block"
        });
      }
      static fromObject(object) {
        return new _Link(object);
      }
      constructor(fields) {
        Object.assign(this, fields);
      }
      /** Checks for link equality (i.e., that the links are pointing to the same exact location). */
      equals(other) {
        if (other == void 0 || other == null)
          return false;
        return this.path == other.path && this.type == other.type && this.subpath == other.subpath;
      }
      /** Convert this link to it's markdown representation. */
      toString() {
        return this.markdown();
      }
      /** Convert this link to a raw object which is serialization-friendly. */
      toObject() {
        return { path: this.path, type: this.type, subpath: this.subpath, display: this.display, embed: this.embed };
      }
      /** Update this link with a new path. */
      //@ts-ignore; error appeared after updating Obsidian to 0.15.4; it also updated other packages but didn't say which
      withPath(path) {
        return new _Link(Object.assign({}, this, { path }));
      }
      /** Return a new link which points to the same location but with a new display value. */
      withDisplay(display) {
        return new _Link(Object.assign({}, this, { display }));
      }
      /** Convert a file link into a link to a specific header. */
      withHeader(header) {
        return _Link.header(this.path, header, this.embed, this.display);
      }
      /** Convert any link into a link to its file. */
      toFile() {
        return _Link.file(this.path, this.embed, this.display);
      }
      /** Convert this link into an embedded link. */
      toEmbed() {
        if (this.embed) {
          return this;
        } else {
          let link = new _Link(this);
          link.embed = true;
          return link;
        }
      }
      /** Convert this link into a non-embedded link. */
      fromEmbed() {
        if (!this.embed) {
          return this;
        } else {
          let link = new _Link(this);
          link.embed = false;
          return link;
        }
      }
      /** Convert this link to markdown so it can be rendered. */
      markdown() {
        let result = (this.embed ? "!" : "") + "[[" + this.obsidianLink();
        if (this.display) {
          result += "|" + this.display;
        } else {
          result += "|" + getFileTitle(this.path);
          if (this.type == "header" || this.type == "block")
            result += " > " + this.subpath;
        }
        result += "]]";
        return result;
      }
      /** Convert the inner part of the link to something that Obsidian can open / understand. */
      obsidianLink() {
        var _a, _b;
        const escaped = this.path.replace("|", "\\|");
        if (this.type == "header")
          return escaped + "#" + ((_a = this.subpath) === null || _a === void 0 ? void 0 : _a.replace("|", "\\|"));
        if (this.type == "block")
          return escaped + "#^" + ((_b = this.subpath) === null || _b === void 0 ? void 0 : _b.replace("|", "\\|"));
        else
          return escaped;
      }
      /** The stripped name of the file this link points to. */
      fileName() {
        return getFileTitle(this.path).replace(".md", "");
      }
    };
    var Widget = class {
      constructor($widget) {
        this.$widget = $widget;
      }
    };
    var ListPairWidget = class extends Widget {
      constructor(key, value) {
        super("dataview:list-pair");
        this.key = key;
        this.value = value;
      }
      markdown() {
        return `${Values.toString(this.key)}: ${Values.toString(this.value)}`;
      }
    };
    var ExternalLinkWidget = class extends Widget {
      constructor(url, display) {
        super("dataview:external-link");
        this.url = url;
        this.display = display;
      }
      markdown() {
        var _a;
        return `[${(_a = this.display) !== null && _a !== void 0 ? _a : this.url}](${this.url})`;
      }
    };
    var Widgets;
    (function(Widgets2) {
      function listPair(key, value) {
        return new ListPairWidget(key, value);
      }
      Widgets2.listPair = listPair;
      function externalLink(url, display) {
        return new ExternalLinkWidget(url, display);
      }
      Widgets2.externalLink = externalLink;
      function isListPair(widget) {
        return widget.$widget === "dataview:list-pair";
      }
      Widgets2.isListPair = isListPair;
      function isExternalLink(widget) {
        return widget.$widget === "dataview:external-link";
      }
      Widgets2.isExternalLink = isExternalLink;
      function isBuiltin(widget) {
        return isListPair(widget) || isExternalLink(widget);
      }
      Widgets2.isBuiltin = isBuiltin;
    })(Widgets || (Widgets = {}));
    var Fields;
    (function(Fields2) {
      function variable(name) {
        return { type: "variable", name };
      }
      Fields2.variable = variable;
      function literal(value) {
        return { type: "literal", value };
      }
      Fields2.literal = literal;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Fields2.binaryOp = binaryOp;
      function index(obj, index2) {
        return { type: "index", object: obj, index: index2 };
      }
      Fields2.index = index;
      function indexVariable(name) {
        let parts = name.split(".");
        let result = Fields2.variable(parts[0]);
        for (let index2 = 1; index2 < parts.length; index2++) {
          result = Fields2.index(result, Fields2.literal(parts[index2]));
        }
        return result;
      }
      Fields2.indexVariable = indexVariable;
      function lambda(args, value) {
        return { type: "lambda", arguments: args, value };
      }
      Fields2.lambda = lambda;
      function func(func2, args) {
        return { type: "function", func: func2, arguments: args };
      }
      Fields2.func = func;
      function list(values) {
        return { type: "list", values };
      }
      Fields2.list = list;
      function object(values) {
        return { type: "object", values };
      }
      Fields2.object = object;
      function negate(child) {
        return { type: "negated", child };
      }
      Fields2.negate = negate;
      function isCompareOp(op) {
        return op == "<=" || op == "<" || op == ">" || op == ">=" || op == "!=" || op == "=";
      }
      Fields2.isCompareOp = isCompareOp;
      Fields2.NULL = Fields2.literal(null);
    })(Fields || (Fields = {}));
    var Sources;
    (function(Sources2) {
      function tag(tag2) {
        return { type: "tag", tag: tag2 };
      }
      Sources2.tag = tag;
      function csv(path) {
        return { type: "csv", path };
      }
      Sources2.csv = csv;
      function folder(prefix) {
        return { type: "folder", folder: prefix };
      }
      Sources2.folder = folder;
      function link(file, incoming) {
        return { type: "link", file, direction: incoming ? "incoming" : "outgoing" };
      }
      Sources2.link = link;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Sources2.binaryOp = binaryOp;
      function and(left, right) {
        return { type: "binaryop", left, op: "&", right };
      }
      Sources2.and = and;
      function or(left, right) {
        return { type: "binaryop", left, op: "|", right };
      }
      Sources2.or = or;
      function negate(child) {
        return { type: "negate", child };
      }
      Sources2.negate = negate;
      function empty2() {
        return { type: "empty" };
      }
      Sources2.empty = empty2;
    })(Sources || (Sources = {}));
    var EMOJI_REGEX = new RegExp(emojiRegex2(), "");
    var DURATION_TYPES = {
      year: Duration2.fromObject({ years: 1 }),
      years: Duration2.fromObject({ years: 1 }),
      yr: Duration2.fromObject({ years: 1 }),
      yrs: Duration2.fromObject({ years: 1 }),
      month: Duration2.fromObject({ months: 1 }),
      months: Duration2.fromObject({ months: 1 }),
      mo: Duration2.fromObject({ months: 1 }),
      mos: Duration2.fromObject({ months: 1 }),
      week: Duration2.fromObject({ weeks: 1 }),
      weeks: Duration2.fromObject({ weeks: 1 }),
      wk: Duration2.fromObject({ weeks: 1 }),
      wks: Duration2.fromObject({ weeks: 1 }),
      w: Duration2.fromObject({ weeks: 1 }),
      day: Duration2.fromObject({ days: 1 }),
      days: Duration2.fromObject({ days: 1 }),
      d: Duration2.fromObject({ days: 1 }),
      hour: Duration2.fromObject({ hours: 1 }),
      hours: Duration2.fromObject({ hours: 1 }),
      hr: Duration2.fromObject({ hours: 1 }),
      hrs: Duration2.fromObject({ hours: 1 }),
      h: Duration2.fromObject({ hours: 1 }),
      minute: Duration2.fromObject({ minutes: 1 }),
      minutes: Duration2.fromObject({ minutes: 1 }),
      min: Duration2.fromObject({ minutes: 1 }),
      mins: Duration2.fromObject({ minutes: 1 }),
      m: Duration2.fromObject({ minutes: 1 }),
      second: Duration2.fromObject({ seconds: 1 }),
      seconds: Duration2.fromObject({ seconds: 1 }),
      sec: Duration2.fromObject({ seconds: 1 }),
      secs: Duration2.fromObject({ seconds: 1 }),
      s: Duration2.fromObject({ seconds: 1 })
    };
    var DATE_SHORTHANDS = {
      now: () => DateTime2.local(),
      today: () => DateTime2.local().startOf("day"),
      yesterday: () => DateTime2.local().startOf("day").minus(Duration2.fromObject({ days: 1 })),
      tomorrow: () => DateTime2.local().startOf("day").plus(Duration2.fromObject({ days: 1 })),
      sow: () => DateTime2.local().startOf("week"),
      "start-of-week": () => DateTime2.local().startOf("week"),
      eow: () => DateTime2.local().endOf("week"),
      "end-of-week": () => DateTime2.local().endOf("week"),
      soy: () => DateTime2.local().startOf("year"),
      "start-of-year": () => DateTime2.local().startOf("year"),
      eoy: () => DateTime2.local().endOf("year"),
      "end-of-year": () => DateTime2.local().endOf("year"),
      som: () => DateTime2.local().startOf("month"),
      "start-of-month": () => DateTime2.local().startOf("month"),
      eom: () => DateTime2.local().endOf("month"),
      "end-of-month": () => DateTime2.local().endOf("month")
    };
    var KEYWORDS = ["FROM", "WHERE", "LIMIT", "GROUP", "FLATTEN"];
    function splitOnUnescapedPipe(link) {
      let pipe = -1;
      while ((pipe = link.indexOf("|", pipe + 1)) >= 0) {
        if (pipe > 0 && link[pipe - 1] == "\\")
          continue;
        return [link.substring(0, pipe).replace(/\\\|/g, "|"), link.substring(pipe + 1)];
      }
      return [link.replace(/\\\|/g, "|"), void 0];
    }
    function parseInnerLink(rawlink) {
      let [link, display] = splitOnUnescapedPipe(rawlink);
      return Link.infer(link, false, display);
    }
    function createBinaryParser(child, sep, combine) {
      return parsimmon_umd_minExports.seqMap(child, parsimmon_umd_minExports.seq(parsimmon_umd_minExports.optWhitespace, sep, parsimmon_umd_minExports.optWhitespace, child).many(), (first, rest) => {
        if (rest.length == 0)
          return first;
        let node = combine(first, rest[0][1], rest[0][3]);
        for (let index = 1; index < rest.length; index++) {
          node = combine(node, rest[index][1], rest[index][3]);
        }
        return node;
      });
    }
    function chainOpt(base, ...funcs) {
      return parsimmon_umd_minExports.custom((success, failure) => {
        return (input, i) => {
          let result = base._(input, i);
          if (!result.status)
            return result;
          for (let func of funcs) {
            let next = func(result.value)._(input, result.index);
            if (!next.status)
              return result;
            result = next;
          }
          return result;
        };
      });
    }
    var EXPRESSION = parsimmon_umd_minExports.createLanguage({
      // A floating point number; the decimal point is optional.
      number: (q) => parsimmon_umd_minExports.regexp(/-?[0-9]+(\.[0-9]+)?/).map((str) => Number.parseFloat(str)).desc("number"),
      // A quote-surrounded string which supports escape characters ('\').
      string: (q) => parsimmon_umd_minExports.string('"').then(parsimmon_umd_minExports.alt(q.escapeCharacter, parsimmon_umd_minExports.noneOf('"\\')).atLeast(0).map((chars) => chars.join(""))).skip(parsimmon_umd_minExports.string('"')).desc("string"),
      escapeCharacter: (_) => parsimmon_umd_minExports.string("\\").then(parsimmon_umd_minExports.any).map((escaped) => {
        if (escaped === '"')
          return '"';
        if (escaped === "\\")
          return "\\";
        else
          return "\\" + escaped;
      }),
      // A boolean true/false value.
      bool: (_) => parsimmon_umd_minExports.regexp(/true|false|True|False/).map((str) => str.toLowerCase() == "true").desc("boolean ('true' or 'false')"),
      // A tag of the form '#stuff/hello-there'.
      tag: (_) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("#"), parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/[^\u2000-\u206F\u2E00-\u2E7F'!"#$%&()*+,.:;<=>?@^`{|}~\[\]\\\s]/).desc("text")).many(), (start, rest) => start + rest.join("")).desc("tag ('#hello/stuff')"),
      // A variable identifier, which is alphanumeric and must start with a letter or... emoji.
      identifier: (_) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/\p{Letter}/u), parsimmon_umd_minExports.regexp(EMOJI_REGEX).desc("text")), parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/[0-9\p{Letter}_-]/u), parsimmon_umd_minExports.regexp(EMOJI_REGEX).desc("text")).many(), (first, rest) => first + rest.join("")).desc("variable identifier"),
      // An Obsidian link of the form [[<link>]].
      link: (_) => parsimmon_umd_minExports.regexp(/\[\[([^\[\]]*?)\]\]/u, 1).map((linkInner) => parseInnerLink(linkInner)).desc("file link"),
      // An embeddable link which can start with '!'. This overlaps with the normal negation operator, so it is only
      // provided for metadata parsing.
      embedLink: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("!").atMost(1), q.link, (p, l3) => {
        if (p.length > 0)
          l3.embed = true;
        return l3;
      }).desc("file link"),
      // Binary plus or minus operator.
      binaryPlusMinus: (_) => parsimmon_umd_minExports.regexp(/\+|-/).map((str) => str).desc("'+' or '-'"),
      // Binary times or divide operator.
      binaryMulDiv: (_) => parsimmon_umd_minExports.regexp(/\*|\/|%/).map((str) => str).desc("'*' or '/' or '%'"),
      // Binary comparison operator.
      binaryCompareOp: (_) => parsimmon_umd_minExports.regexp(/>=|<=|!=|>|<|=/).map((str) => str).desc("'>=' or '<=' or '!=' or '=' or '>' or '<'"),
      // Binary boolean combination operator.
      binaryBooleanOp: (_) => parsimmon_umd_minExports.regexp(/and|or|&|\|/i).map((str) => {
        if (str.toLowerCase() == "and")
          return "&";
        else if (str.toLowerCase() == "or")
          return "|";
        else
          return str;
      }).desc("'and' or 'or'"),
      // A date which can be YYYY-MM[-DDTHH:mm:ss].
      rootDate: (_) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/\d{4}/), parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.regexp(/\d{2}/), (year, _2, month) => {
        return DateTime2.fromObject({ year: Number.parseInt(year), month: Number.parseInt(month) });
      }).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      dateShorthand: (_) => parsimmon_umd_minExports.alt(...Object.keys(DATE_SHORTHANDS).sort((a, b) => b.length - a.length).map(parsimmon_umd_minExports.string)),
      date: (q) => chainOpt(q.rootDate, (ym) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.regexp(/\d{2}/), (_, day) => ym.set({ day: Number.parseInt(day) })), (ymd) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("T"), parsimmon_umd_minExports.regexp(/\d{2}/), (_, hour) => ymd.set({ hour: Number.parseInt(hour) })), (ymdh) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string(":"), parsimmon_umd_minExports.regexp(/\d{2}/), (_, minute) => ymdh.set({ minute: Number.parseInt(minute) })), (ymdhm) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string(":"), parsimmon_umd_minExports.regexp(/\d{2}/), (_, second) => ymdhm.set({ second: Number.parseInt(second) })), (ymdhms) => parsimmon_umd_minExports.alt(
        parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("."), parsimmon_umd_minExports.regexp(/\d{3}/), (_, millisecond) => ymdhms.set({ millisecond: Number.parseInt(millisecond) })),
        parsimmon_umd_minExports.succeed(ymdhms)
        // pass
      ), (dt) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("+").or(parsimmon_umd_minExports.string("-")), parsimmon_umd_minExports.regexp(/\d{1,2}(:\d{2})?/), (pm, hr) => dt.setZone("UTC" + pm + hr, { keepLocalTime: true })), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("Z"), () => dt.setZone("utc", { keepLocalTime: true })), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("["), parsimmon_umd_minExports.regexp(/[0-9A-Za-z+-\/]+/u), parsimmon_umd_minExports.string("]"), (_a, zone, _b) => dt.setZone(zone, { keepLocalTime: true })))).assert((dt) => dt.isValid, "valid date").desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      // A date, plus various shorthand times of day it could be.
      datePlus: (q) => parsimmon_umd_minExports.alt(q.dateShorthand.map((d) => DATE_SHORTHANDS[d]()), q.date).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS] or in shorthand"),
      // A duration of time.
      durationType: (_) => parsimmon_umd_minExports.alt(...Object.keys(DURATION_TYPES).sort((a, b) => b.length - a.length).map(parsimmon_umd_minExports.string)),
      duration: (q) => parsimmon_umd_minExports.seqMap(q.number, parsimmon_umd_minExports.optWhitespace, q.durationType, (count, _, t) => DURATION_TYPES[t].mapUnits((x) => x * count)).sepBy1(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace).or(parsimmon_umd_minExports.optWhitespace)).map((durations) => durations.reduce((p, c) => p.plus(c))).desc("duration like 4hr2min"),
      // A raw null value.
      rawNull: (_) => parsimmon_umd_minExports.string("null"),
      // Source parsing.
      tagSource: (q) => q.tag.map((tag) => Sources.tag(tag)),
      csvSource: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("csv(").skip(parsimmon_umd_minExports.optWhitespace), q.string, parsimmon_umd_minExports.string(")"), (_1, path, _2) => Sources.csv(path)),
      linkIncomingSource: (q) => q.link.map((link) => Sources.link(link.path, true)),
      linkOutgoingSource: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("outgoing(").skip(parsimmon_umd_minExports.optWhitespace), q.link, parsimmon_umd_minExports.string(")"), (_1, link, _2) => Sources.link(link.path, false)),
      folderSource: (q) => q.string.map((str) => Sources.folder(str)),
      parensSource: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q.source, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_1, _2, field, _3, _4) => field),
      negateSource: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.alt(parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.string("!")), q.atomSource, (_, source) => Sources.negate(source)),
      atomSource: (q) => parsimmon_umd_minExports.alt(q.parensSource, q.negateSource, q.linkOutgoingSource, q.linkIncomingSource, q.folderSource, q.tagSource, q.csvSource),
      binaryOpSource: (q) => createBinaryParser(q.atomSource, q.binaryBooleanOp.map((s3) => s3), Sources.binaryOp),
      source: (q) => q.binaryOpSource,
      // Field parsing.
      variableField: (q) => q.identifier.chain((r) => {
        if (KEYWORDS.includes(r.toUpperCase())) {
          return parsimmon_umd_minExports.fail("Variable fields cannot be a keyword (" + KEYWORDS.join(" or ") + ")");
        } else {
          return parsimmon_umd_minExports.succeed(Fields.variable(r));
        }
      }).desc("variable"),
      numberField: (q) => q.number.map((val) => Fields.literal(val)).desc("number"),
      stringField: (q) => q.string.map((val) => Fields.literal(val)).desc("string"),
      boolField: (q) => q.bool.map((val) => Fields.literal(val)).desc("boolean"),
      dateField: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("date("), parsimmon_umd_minExports.optWhitespace, q.datePlus, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (prefix, _1, date, _2, postfix) => Fields.literal(date)).desc("date"),
      durationField: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("dur("), parsimmon_umd_minExports.optWhitespace, q.duration, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (prefix, _1, dur, _2, postfix) => Fields.literal(dur)).desc("duration"),
      nullField: (q) => q.rawNull.map((_) => Fields.NULL),
      linkField: (q) => q.link.map((f) => Fields.literal(f)),
      listField: (q) => q.field.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("[").skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.optWhitespace.then(parsimmon_umd_minExports.string("]"))).map((l3) => Fields.list(l3)).desc("list ('[1, 2, 3]')"),
      objectField: (q) => parsimmon_umd_minExports.seqMap(q.identifier.or(q.string), parsimmon_umd_minExports.string(":").trim(parsimmon_umd_minExports.optWhitespace), q.field, (name, _sep, value) => {
        return { name, value };
      }).sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("{").skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.optWhitespace.then(parsimmon_umd_minExports.string("}"))).map((vals) => {
        let res = {};
        for (let entry of vals)
          res[entry.name] = entry.value;
        return Fields.object(res);
      }).desc("object ('{ a: 1, b: 2 }')"),
      atomInlineField: (q) => parsimmon_umd_minExports.alt(q.date, q.duration.map((d) => normalizeDuration(d)), q.string, q.tag, q.embedLink, q.bool, q.number, q.rawNull),
      inlineFieldList: (q) => q.atomInlineField.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace).lookahead(q.atomInlineField)),
      inlineField: (q) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.seqMap(q.atomInlineField, parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace), q.inlineFieldList, (f, _s, l3) => [f].concat(l3)), q.atomInlineField),
      atomField: (q) => parsimmon_umd_minExports.alt(
        // Place embed links above negated fields as they are the special parser case '![[thing]]' and are generally unambigious.
        q.embedLink.map((l3) => Fields.literal(l3)),
        q.negatedField,
        q.linkField,
        q.listField,
        q.objectField,
        q.lambdaField,
        q.parensField,
        q.boolField,
        q.numberField,
        q.stringField,
        q.dateField,
        q.durationField,
        q.nullField,
        q.variableField
      ),
      indexField: (q) => parsimmon_umd_minExports.seqMap(q.atomField, parsimmon_umd_minExports.alt(q.dotPostfix, q.indexPostfix, q.functionPostfix).many(), (obj, postfixes) => {
        let result = obj;
        for (let post of postfixes) {
          switch (post.type) {
            case "dot":
              result = Fields.index(result, Fields.literal(post.field));
              break;
            case "index":
              result = Fields.index(result, post.field);
              break;
            case "function":
              result = Fields.func(result, post.fields);
              break;
          }
        }
        return result;
      }),
      negatedField: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("!"), q.indexField, (_, field) => Fields.negate(field)).desc("negated field"),
      parensField: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q.field, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_1, _2, field, _3, _4) => field),
      lambdaField: (q) => parsimmon_umd_minExports.seqMap(q.identifier.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("(").trim(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.string(")").trim(parsimmon_umd_minExports.optWhitespace)), parsimmon_umd_minExports.string("=>").trim(parsimmon_umd_minExports.optWhitespace), q.field, (ident, _ignore, value) => {
        return { type: "lambda", arguments: ident, value };
      }),
      dotPostfix: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("."), q.identifier, (_, field) => {
        return { type: "dot", field };
      }),
      indexPostfix: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("["), parsimmon_umd_minExports.optWhitespace, q.field, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string("]"), (_, _2, field, _3, _4) => {
        return { type: "index", field };
      }),
      functionPostfix: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q.field.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_, _1, fields, _2, _3) => {
        return { type: "function", fields };
      }),
      // The precedence hierarchy of operators - multiply/divide, add/subtract, compare, and then boolean operations.
      binaryMulDivField: (q) => createBinaryParser(q.indexField, q.binaryMulDiv, Fields.binaryOp),
      binaryPlusMinusField: (q) => createBinaryParser(q.binaryMulDivField, q.binaryPlusMinus, Fields.binaryOp),
      binaryCompareField: (q) => createBinaryParser(q.binaryPlusMinusField, q.binaryCompareOp, Fields.binaryOp),
      binaryBooleanField: (q) => createBinaryParser(q.binaryCompareField, q.binaryBooleanOp, Fields.binaryOp),
      binaryOpField: (q) => q.binaryBooleanField,
      field: (q) => q.binaryOpField
    });
    function parseField(text2) {
      try {
        return Result.success(EXPRESSION.field.tryParse(text2));
      } catch (error) {
        return Result.failure("" + error);
      }
    }
    var QueryFields;
    (function(QueryFields2) {
      function named(name, field) {
        return { name, field };
      }
      QueryFields2.named = named;
      function sortBy(field, dir) {
        return { field, direction: dir };
      }
      QueryFields2.sortBy = sortBy;
    })(QueryFields || (QueryFields = {}));
    function captureRaw(base) {
      return parsimmon_umd_minExports.custom((success, failure) => {
        return (input, i) => {
          let result = base._(input, i);
          if (!result.status)
            return result;
          return Object.assign({}, result, { value: [result.value, input.substring(i, result.index)] });
        };
      });
    }
    function stripNewlines(text2) {
      return text2.split(/[\r\n]+/).map((t) => t.trim()).join("");
    }
    function precededByWhitespaceIfNotEof(if_eof, parser) {
      return parsimmon_umd_minExports.eof.map(if_eof).or(parsimmon_umd_minExports.whitespace.then(parser));
    }
    var QUERY_LANGUAGE = parsimmon_umd_minExports.createLanguage({
      // Simple atom parsing, like words, identifiers, numbers.
      queryType: (q) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/TABLE|LIST|TASK|CALENDAR/i)).map((str) => str.toLowerCase()).desc("query type ('TABLE', 'LIST', 'TASK', or 'CALENDAR')"),
      explicitNamedField: (q) => parsimmon_umd_minExports.seqMap(EXPRESSION.field.skip(parsimmon_umd_minExports.whitespace), parsimmon_umd_minExports.regexp(/AS/i).skip(parsimmon_umd_minExports.whitespace), EXPRESSION.identifier.or(EXPRESSION.string), (field, _as, ident) => QueryFields.named(ident, field)),
      namedField: (q) => parsimmon_umd_minExports.alt(q.explicitNamedField, captureRaw(EXPRESSION.field).map(([value, text2]) => QueryFields.named(stripNewlines(text2), value))),
      sortField: (q) => parsimmon_umd_minExports.seqMap(EXPRESSION.field.skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.regexp(/ASCENDING|DESCENDING|ASC|DESC/i).atMost(1), (field, dir) => {
        let direction = dir.length == 0 ? "ascending" : dir[0].toLowerCase();
        if (direction == "desc")
          direction = "descending";
        if (direction == "asc")
          direction = "ascending";
        return {
          field,
          direction
        };
      }),
      headerClause: (q) => q.queryType.chain((type) => {
        switch (type) {
          case "table": {
            return precededByWhitespaceIfNotEof(() => ({ type, fields: [], showId: true }), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_minExports.optWhitespace).atMost(1), parsimmon_umd_minExports.sepBy(q.namedField, parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), (withoutId, fields) => {
              return { type, fields, showId: withoutId.length == 0 };
            }));
          }
          case "list":
            return precededByWhitespaceIfNotEof(() => ({ type, format: void 0, showId: true }), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_minExports.optWhitespace).atMost(1), EXPRESSION.field.atMost(1), (withoutId, format) => {
              return {
                type,
                format: format.length == 1 ? format[0] : void 0,
                showId: withoutId.length == 0
              };
            }));
          case "task":
            return parsimmon_umd_minExports.succeed({ type });
          case "calendar":
            return parsimmon_umd_minExports.whitespace.then(parsimmon_umd_minExports.seqMap(q.namedField, (field) => {
              return {
                type,
                showId: true,
                field
              };
            }));
          default:
            return parsimmon_umd_minExports.fail(`Unrecognized query type '${type}'`);
        }
      }).desc("TABLE or LIST or TASK or CALENDAR"),
      fromClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/FROM/i), parsimmon_umd_minExports.whitespace, EXPRESSION.source, (_1, _2, source) => source),
      whereClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WHERE/i), parsimmon_umd_minExports.whitespace, EXPRESSION.field, (where, _, field) => {
        return { type: "where", clause: field };
      }).desc("WHERE <expression>"),
      sortByClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/SORT/i), parsimmon_umd_minExports.whitespace, q.sortField.sepBy1(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), (sort, _1, fields) => {
        return { type: "sort", fields };
      }).desc("SORT field [ASC/DESC]"),
      limitClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/LIMIT/i), parsimmon_umd_minExports.whitespace, EXPRESSION.field, (limit, _1, field) => {
        return { type: "limit", amount: field };
      }).desc("LIMIT <value>"),
      flattenClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/FLATTEN/i).skip(parsimmon_umd_minExports.whitespace), q.namedField, (_, field) => {
        return { type: "flatten", field };
      }).desc("FLATTEN <value> [AS <name>]"),
      groupByClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/GROUP BY/i).skip(parsimmon_umd_minExports.whitespace), q.namedField, (_, field) => {
        return { type: "group", field };
      }).desc("GROUP BY <value> [AS <name>]"),
      // Full query parsing.
      clause: (q) => parsimmon_umd_minExports.alt(q.fromClause, q.whereClause, q.sortByClause, q.limitClause, q.groupByClause, q.flattenClause),
      query: (q) => parsimmon_umd_minExports.seqMap(q.headerClause.trim(parsimmon_umd_minExports.optWhitespace), q.fromClause.trim(parsimmon_umd_minExports.optWhitespace).atMost(1), q.clause.trim(parsimmon_umd_minExports.optWhitespace).many(), (header, from, clauses) => {
        return {
          header,
          source: from.length == 0 ? Sources.folder("") : from[0],
          operations: clauses,
          settings: DEFAULT_QUERY_SETTINGS
        };
      })
    });
    var getAPI = (app) => {
      var _a;
      if (app)
        return (_a = app.plugins.plugins.dataview) === null || _a === void 0 ? void 0 : _a.api;
      else
        return window.DataviewAPI;
    };
    var isPluginEnabled = (app) => app.plugins.enabledPlugins.has("dataview");
    exports.DATE_SHORTHANDS = DATE_SHORTHANDS;
    exports.DURATION_TYPES = DURATION_TYPES;
    exports.EXPRESSION = EXPRESSION;
    exports.KEYWORDS = KEYWORDS;
    exports.QUERY_LANGUAGE = QUERY_LANGUAGE;
    exports.getAPI = getAPI;
    exports.isPluginEnabled = isPluginEnabled;
    exports.parseField = parseField;
  }
});

// node_modules/graphology/dist/graphology.umd.min.js
var require_graphology_umd_min = __commonJS({
  "node_modules/graphology/dist/graphology.umd.min.js"(exports, module2) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).graphology = e();
    }(exports, function() {
      "use strict";
      function t(e2) {
        return t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t2) {
          return typeof t2;
        } : function(t2) {
          return t2 && "function" == typeof Symbol && t2.constructor === Symbol && t2 !== Symbol.prototype ? "symbol" : typeof t2;
        }, t(e2);
      }
      function e(t2, e2) {
        t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, r(t2, e2);
      }
      function n2(t2) {
        return n2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        }, n2(t2);
      }
      function r(t2, e2) {
        return r = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
          return t3.__proto__ = e3, t3;
        }, r(t2, e2);
      }
      function i() {
        if ("undefined" == typeof Reflect || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if ("function" == typeof Proxy)
          return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), true;
        } catch (t2) {
          return false;
        }
      }
      function o(t2, e2, n3) {
        return o = i() ? Reflect.construct.bind() : function(t3, e3, n4) {
          var i2 = [null];
          i2.push.apply(i2, e3);
          var o2 = new (Function.bind.apply(t3, i2))();
          return n4 && r(o2, n4.prototype), o2;
        }, o.apply(null, arguments);
      }
      function a(t2) {
        var e2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
        return a = function(t3) {
          if (null === t3 || (i2 = t3, -1 === Function.toString.call(i2).indexOf("[native code]")))
            return t3;
          var i2;
          if ("function" != typeof t3)
            throw new TypeError("Super expression must either be null or a function");
          if (void 0 !== e2) {
            if (e2.has(t3))
              return e2.get(t3);
            e2.set(t3, a2);
          }
          function a2() {
            return o(t3, arguments, n2(this).constructor);
          }
          return a2.prototype = Object.create(t3.prototype, { constructor: { value: a2, enumerable: false, writable: true, configurable: true } }), r(a2, t3);
        }, a(t2);
      }
      function c(t2) {
        if (void 0 === t2)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t2;
      }
      var u = function() {
        for (var t2 = arguments[0], e2 = 1, n3 = arguments.length; e2 < n3; e2++)
          if (arguments[e2])
            for (var r2 in arguments[e2])
              t2[r2] = arguments[e2][r2];
        return t2;
      };
      function d(t2, e2, n3, r2) {
        var i2 = t2._nodes.get(e2), o2 = null;
        return i2 ? o2 = "mixed" === r2 ? i2.out && i2.out[n3] || i2.undirected && i2.undirected[n3] : "directed" === r2 ? i2.out && i2.out[n3] : i2.undirected && i2.undirected[n3] : o2;
      }
      function s2(e2) {
        return "object" === t(e2) && null !== e2;
      }
      function h(t2) {
        var e2;
        for (e2 in t2)
          return false;
        return true;
      }
      function p(t2, e2, n3) {
        Object.defineProperty(t2, e2, { enumerable: false, configurable: false, writable: true, value: n3 });
      }
      function f(t2, e2, n3) {
        var r2 = { enumerable: true, configurable: true };
        "function" == typeof n3 ? r2.get = n3 : (r2.value = n3, r2.writable = false), Object.defineProperty(t2, e2, r2);
      }
      function l2(t2) {
        return !!s2(t2) && !(t2.attributes && !Array.isArray(t2.attributes));
      }
      "function" == typeof Object.assign && (u = Object.assign);
      var g, y = { exports: {} }, w = "object" == typeof Reflect ? Reflect : null, v = w && "function" == typeof w.apply ? w.apply : function(t2, e2, n3) {
        return Function.prototype.apply.call(t2, e2, n3);
      };
      g = w && "function" == typeof w.ownKeys ? w.ownKeys : Object.getOwnPropertySymbols ? function(t2) {
        return Object.getOwnPropertyNames(t2).concat(Object.getOwnPropertySymbols(t2));
      } : function(t2) {
        return Object.getOwnPropertyNames(t2);
      };
      var b = Number.isNaN || function(t2) {
        return t2 != t2;
      };
      function m() {
        m.init.call(this);
      }
      y.exports = m, y.exports.once = function(t2, e2) {
        return new Promise(function(n3, r2) {
          function i2(n4) {
            t2.removeListener(e2, o2), r2(n4);
          }
          function o2() {
            "function" == typeof t2.removeListener && t2.removeListener("error", i2), n3([].slice.call(arguments));
          }
          U(t2, e2, o2, { once: true }), "error" !== e2 && function(t3, e3, n4) {
            "function" == typeof t3.on && U(t3, "error", e3, n4);
          }(t2, i2, { once: true });
        });
      }, m.EventEmitter = m, m.prototype._events = void 0, m.prototype._eventsCount = 0, m.prototype._maxListeners = void 0;
      var k = 10;
      function _(t2) {
        if ("function" != typeof t2)
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t2);
      }
      function G(t2) {
        return void 0 === t2._maxListeners ? m.defaultMaxListeners : t2._maxListeners;
      }
      function x(t2, e2, n3, r2) {
        var i2, o2, a2, c2;
        if (_(n3), void 0 === (o2 = t2._events) ? (o2 = t2._events = /* @__PURE__ */ Object.create(null), t2._eventsCount = 0) : (void 0 !== o2.newListener && (t2.emit("newListener", e2, n3.listener ? n3.listener : n3), o2 = t2._events), a2 = o2[e2]), void 0 === a2)
          a2 = o2[e2] = n3, ++t2._eventsCount;
        else if ("function" == typeof a2 ? a2 = o2[e2] = r2 ? [n3, a2] : [a2, n3] : r2 ? a2.unshift(n3) : a2.push(n3), (i2 = G(t2)) > 0 && a2.length > i2 && !a2.warned) {
          a2.warned = true;
          var u2 = new Error("Possible EventEmitter memory leak detected. " + a2.length + " " + String(e2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          u2.name = "MaxListenersExceededWarning", u2.emitter = t2, u2.type = e2, u2.count = a2.length, c2 = u2, console && console.warn && console.warn(c2);
        }
        return t2;
      }
      function E() {
        if (!this.fired)
          return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
      }
      function A(t2, e2, n3) {
        var r2 = { fired: false, wrapFn: void 0, target: t2, type: e2, listener: n3 }, i2 = E.bind(r2);
        return i2.listener = n3, r2.wrapFn = i2, i2;
      }
      function L(t2, e2, n3) {
        var r2 = t2._events;
        if (void 0 === r2)
          return [];
        var i2 = r2[e2];
        return void 0 === i2 ? [] : "function" == typeof i2 ? n3 ? [i2.listener || i2] : [i2] : n3 ? function(t3) {
          for (var e3 = new Array(t3.length), n4 = 0; n4 < e3.length; ++n4)
            e3[n4] = t3[n4].listener || t3[n4];
          return e3;
        }(i2) : D(i2, i2.length);
      }
      function S(t2) {
        var e2 = this._events;
        if (void 0 !== e2) {
          var n3 = e2[t2];
          if ("function" == typeof n3)
            return 1;
          if (void 0 !== n3)
            return n3.length;
        }
        return 0;
      }
      function D(t2, e2) {
        for (var n3 = new Array(e2), r2 = 0; r2 < e2; ++r2)
          n3[r2] = t2[r2];
        return n3;
      }
      function U(t2, e2, n3, r2) {
        if ("function" == typeof t2.on)
          r2.once ? t2.once(e2, n3) : t2.on(e2, n3);
        else {
          if ("function" != typeof t2.addEventListener)
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t2);
          t2.addEventListener(e2, function i2(o2) {
            r2.once && t2.removeEventListener(e2, i2), n3(o2);
          });
        }
      }
      function N(t2) {
        if ("function" != typeof t2)
          throw new Error("obliterator/iterator: expecting a function!");
        this.next = t2;
      }
      Object.defineProperty(m, "defaultMaxListeners", { enumerable: true, get: function() {
        return k;
      }, set: function(t2) {
        if ("number" != typeof t2 || t2 < 0 || b(t2))
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t2 + ".");
        k = t2;
      } }), m.init = function() {
        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, m.prototype.setMaxListeners = function(t2) {
        if ("number" != typeof t2 || t2 < 0 || b(t2))
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t2 + ".");
        return this._maxListeners = t2, this;
      }, m.prototype.getMaxListeners = function() {
        return G(this);
      }, m.prototype.emit = function(t2) {
        for (var e2 = [], n3 = 1; n3 < arguments.length; n3++)
          e2.push(arguments[n3]);
        var r2 = "error" === t2, i2 = this._events;
        if (void 0 !== i2)
          r2 = r2 && void 0 === i2.error;
        else if (!r2)
          return false;
        if (r2) {
          var o2;
          if (e2.length > 0 && (o2 = e2[0]), o2 instanceof Error)
            throw o2;
          var a2 = new Error("Unhandled error." + (o2 ? " (" + o2.message + ")" : ""));
          throw a2.context = o2, a2;
        }
        var c2 = i2[t2];
        if (void 0 === c2)
          return false;
        if ("function" == typeof c2)
          v(c2, this, e2);
        else {
          var u2 = c2.length, d2 = D(c2, u2);
          for (n3 = 0; n3 < u2; ++n3)
            v(d2[n3], this, e2);
        }
        return true;
      }, m.prototype.addListener = function(t2, e2) {
        return x(this, t2, e2, false);
      }, m.prototype.on = m.prototype.addListener, m.prototype.prependListener = function(t2, e2) {
        return x(this, t2, e2, true);
      }, m.prototype.once = function(t2, e2) {
        return _(e2), this.on(t2, A(this, t2, e2)), this;
      }, m.prototype.prependOnceListener = function(t2, e2) {
        return _(e2), this.prependListener(t2, A(this, t2, e2)), this;
      }, m.prototype.removeListener = function(t2, e2) {
        var n3, r2, i2, o2, a2;
        if (_(e2), void 0 === (r2 = this._events))
          return this;
        if (void 0 === (n3 = r2[t2]))
          return this;
        if (n3 === e2 || n3.listener === e2)
          0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r2[t2], r2.removeListener && this.emit("removeListener", t2, n3.listener || e2));
        else if ("function" != typeof n3) {
          for (i2 = -1, o2 = n3.length - 1; o2 >= 0; o2--)
            if (n3[o2] === e2 || n3[o2].listener === e2) {
              a2 = n3[o2].listener, i2 = o2;
              break;
            }
          if (i2 < 0)
            return this;
          0 === i2 ? n3.shift() : function(t3, e3) {
            for (; e3 + 1 < t3.length; e3++)
              t3[e3] = t3[e3 + 1];
            t3.pop();
          }(n3, i2), 1 === n3.length && (r2[t2] = n3[0]), void 0 !== r2.removeListener && this.emit("removeListener", t2, a2 || e2);
        }
        return this;
      }, m.prototype.off = m.prototype.removeListener, m.prototype.removeAllListeners = function(t2) {
        var e2, n3, r2;
        if (void 0 === (n3 = this._events))
          return this;
        if (void 0 === n3.removeListener)
          return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n3[t2] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n3[t2]), this;
        if (0 === arguments.length) {
          var i2, o2 = Object.keys(n3);
          for (r2 = 0; r2 < o2.length; ++r2)
            "removeListener" !== (i2 = o2[r2]) && this.removeAllListeners(i2);
          return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if ("function" == typeof (e2 = n3[t2]))
          this.removeListener(t2, e2);
        else if (void 0 !== e2)
          for (r2 = e2.length - 1; r2 >= 0; r2--)
            this.removeListener(t2, e2[r2]);
        return this;
      }, m.prototype.listeners = function(t2) {
        return L(this, t2, true);
      }, m.prototype.rawListeners = function(t2) {
        return L(this, t2, false);
      }, m.listenerCount = function(t2, e2) {
        return "function" == typeof t2.listenerCount ? t2.listenerCount(e2) : S.call(t2, e2);
      }, m.prototype.listenerCount = S, m.prototype.eventNames = function() {
        return this._eventsCount > 0 ? g(this._events) : [];
      }, "undefined" != typeof Symbol && (N.prototype[Symbol.iterator] = function() {
        return this;
      }), N.of = function() {
        var t2 = arguments, e2 = t2.length, n3 = 0;
        return new N(function() {
          return n3 >= e2 ? { done: true } : { done: false, value: t2[n3++] };
        });
      }, N.empty = function() {
        return new N(function() {
          return { done: true };
        });
      }, N.fromSequence = function(t2) {
        var e2 = 0, n3 = t2.length;
        return new N(function() {
          return e2 >= n3 ? { done: true } : { done: false, value: t2[e2++] };
        });
      }, N.is = function(t2) {
        return t2 instanceof N || "object" == typeof t2 && null !== t2 && "function" == typeof t2.next;
      };
      var O = N, j = {};
      j.ARRAY_BUFFER_SUPPORT = "undefined" != typeof ArrayBuffer, j.SYMBOL_SUPPORT = "undefined" != typeof Symbol;
      var C = O, M = j, z2 = M.ARRAY_BUFFER_SUPPORT, W = M.SYMBOL_SUPPORT;
      var P = function(t2) {
        var e2 = function(t3) {
          return "string" == typeof t3 || Array.isArray(t3) || z2 && ArrayBuffer.isView(t3) ? C.fromSequence(t3) : "object" != typeof t3 || null === t3 ? null : W && "function" == typeof t3[Symbol.iterator] ? t3[Symbol.iterator]() : "function" == typeof t3.next ? t3 : null;
        }(t2);
        if (!e2)
          throw new Error("obliterator: target is not iterable nor a valid iterator.");
        return e2;
      }, R = P, K = function(t2, e2) {
        for (var n3, r2 = arguments.length > 1 ? e2 : 1 / 0, i2 = r2 !== 1 / 0 ? new Array(r2) : [], o2 = 0, a2 = R(t2); ; ) {
          if (o2 === r2)
            return i2;
          if ((n3 = a2.next()).done)
            return o2 !== e2 && (i2.length = o2), i2;
          i2[o2++] = n3.value;
        }
      }, T = function(t2) {
        function n3(e2) {
          var n4;
          return (n4 = t2.call(this) || this).name = "GraphError", n4.message = e2, n4;
        }
        return e(n3, t2), n3;
      }(a(Error)), B = function(t2) {
        function n3(e2) {
          var r2;
          return (r2 = t2.call(this, e2) || this).name = "InvalidArgumentsGraphError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(c(r2), n3.prototype.constructor), r2;
        }
        return e(n3, t2), n3;
      }(T), F = function(t2) {
        function n3(e2) {
          var r2;
          return (r2 = t2.call(this, e2) || this).name = "NotFoundGraphError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(c(r2), n3.prototype.constructor), r2;
        }
        return e(n3, t2), n3;
      }(T), I = function(t2) {
        function n3(e2) {
          var r2;
          return (r2 = t2.call(this, e2) || this).name = "UsageGraphError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(c(r2), n3.prototype.constructor), r2;
        }
        return e(n3, t2), n3;
      }(T);
      function Y(t2, e2) {
        this.key = t2, this.attributes = e2, this.clear();
      }
      function q(t2, e2) {
        this.key = t2, this.attributes = e2, this.clear();
      }
      function J(t2, e2) {
        this.key = t2, this.attributes = e2, this.clear();
      }
      function V(t2, e2, n3, r2, i2) {
        this.key = e2, this.attributes = i2, this.undirected = t2, this.source = n3, this.target = r2;
      }
      Y.prototype.clear = function() {
        this.inDegree = 0, this.outDegree = 0, this.undirectedDegree = 0, this.undirectedLoops = 0, this.directedLoops = 0, this.in = {}, this.out = {}, this.undirected = {};
      }, q.prototype.clear = function() {
        this.inDegree = 0, this.outDegree = 0, this.directedLoops = 0, this.in = {}, this.out = {};
      }, J.prototype.clear = function() {
        this.undirectedDegree = 0, this.undirectedLoops = 0, this.undirected = {};
      }, V.prototype.attach = function() {
        var t2 = "out", e2 = "in";
        this.undirected && (t2 = e2 = "undirected");
        var n3 = this.source.key, r2 = this.target.key;
        this.source[t2][r2] = this, this.undirected && n3 === r2 || (this.target[e2][n3] = this);
      }, V.prototype.attachMulti = function() {
        var t2 = "out", e2 = "in", n3 = this.source.key, r2 = this.target.key;
        this.undirected && (t2 = e2 = "undirected");
        var i2 = this.source[t2], o2 = i2[r2];
        if (void 0 === o2)
          return i2[r2] = this, void (this.undirected && n3 === r2 || (this.target[e2][n3] = this));
        o2.previous = this, this.next = o2, i2[r2] = this, this.target[e2][n3] = this;
      }, V.prototype.detach = function() {
        var t2 = this.source.key, e2 = this.target.key, n3 = "out", r2 = "in";
        this.undirected && (n3 = r2 = "undirected"), delete this.source[n3][e2], delete this.target[r2][t2];
      }, V.prototype.detachMulti = function() {
        var t2 = this.source.key, e2 = this.target.key, n3 = "out", r2 = "in";
        this.undirected && (n3 = r2 = "undirected"), void 0 === this.previous ? void 0 === this.next ? (delete this.source[n3][e2], delete this.target[r2][t2]) : (this.next.previous = void 0, this.source[n3][e2] = this.next, this.target[r2][t2] = this.next) : (this.previous.next = this.next, void 0 !== this.next && (this.next.previous = this.previous));
      };
      function H(t2, e2, n3, r2, i2, o2, a2) {
        var c2, u2, d2, s3;
        if (r2 = "" + r2, 0 === n3) {
          if (!(c2 = t2._nodes.get(r2)))
            throw new F("Graph.".concat(e2, ': could not find the "').concat(r2, '" node in the graph.'));
          d2 = i2, s3 = o2;
        } else if (3 === n3) {
          if (i2 = "" + i2, !(u2 = t2._edges.get(i2)))
            throw new F("Graph.".concat(e2, ': could not find the "').concat(i2, '" edge in the graph.'));
          var h2 = u2.source.key, p2 = u2.target.key;
          if (r2 === h2)
            c2 = u2.target;
          else {
            if (r2 !== p2)
              throw new F("Graph.".concat(e2, ': the "').concat(r2, '" node is not attached to the "').concat(i2, '" edge (').concat(h2, ", ").concat(p2, ")."));
            c2 = u2.source;
          }
          d2 = o2, s3 = a2;
        } else {
          if (!(u2 = t2._edges.get(r2)))
            throw new F("Graph.".concat(e2, ': could not find the "').concat(r2, '" edge in the graph.'));
          c2 = 1 === n3 ? u2.source : u2.target, d2 = i2, s3 = o2;
        }
        return [c2, d2, s3];
      }
      var Q = [{ name: function(t2) {
        return "get".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2) {
          var o2 = H(this, e2, n3, t3, r2, i2), a2 = o2[0], c2 = o2[1];
          return a2.attributes[c2];
        };
      } }, { name: function(t2) {
        return "get".concat(t2, "Attributes");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2) {
          return H(this, e2, n3, t3, r2)[0].attributes;
        };
      } }, { name: function(t2) {
        return "has".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2) {
          var o2 = H(this, e2, n3, t3, r2, i2), a2 = o2[0], c2 = o2[1];
          return a2.attributes.hasOwnProperty(c2);
        };
      } }, { name: function(t2) {
        return "set".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2, o2) {
          var a2 = H(this, e2, n3, t3, r2, i2, o2), c2 = a2[0], u2 = a2[1], d2 = a2[2];
          return c2.attributes[u2] = d2, this.emit("nodeAttributesUpdated", { key: c2.key, type: "set", attributes: c2.attributes, name: u2 }), this;
        };
      } }, { name: function(t2) {
        return "update".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2, o2) {
          var a2 = H(this, e2, n3, t3, r2, i2, o2), c2 = a2[0], u2 = a2[1], d2 = a2[2];
          if ("function" != typeof d2)
            throw new B("Graph.".concat(e2, ": updater should be a function."));
          var s3 = c2.attributes, h2 = d2(s3[u2]);
          return s3[u2] = h2, this.emit("nodeAttributesUpdated", { key: c2.key, type: "set", attributes: c2.attributes, name: u2 }), this;
        };
      } }, { name: function(t2) {
        return "remove".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2) {
          var o2 = H(this, e2, n3, t3, r2, i2), a2 = o2[0], c2 = o2[1];
          return delete a2.attributes[c2], this.emit("nodeAttributesUpdated", { key: a2.key, type: "remove", attributes: a2.attributes, name: c2 }), this;
        };
      } }, { name: function(t2) {
        return "replace".concat(t2, "Attributes");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2) {
          var o2 = H(this, e2, n3, t3, r2, i2), a2 = o2[0], c2 = o2[1];
          if (!s2(c2))
            throw new B("Graph.".concat(e2, ": provided attributes are not a plain object."));
          return a2.attributes = c2, this.emit("nodeAttributesUpdated", { key: a2.key, type: "replace", attributes: a2.attributes }), this;
        };
      } }, { name: function(t2) {
        return "merge".concat(t2, "Attributes");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2) {
          var o2 = H(this, e2, n3, t3, r2, i2), a2 = o2[0], c2 = o2[1];
          if (!s2(c2))
            throw new B("Graph.".concat(e2, ": provided attributes are not a plain object."));
          return u(a2.attributes, c2), this.emit("nodeAttributesUpdated", { key: a2.key, type: "merge", attributes: a2.attributes, data: c2 }), this;
        };
      } }, { name: function(t2) {
        return "update".concat(t2, "Attributes");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2) {
          var o2 = H(this, e2, n3, t3, r2, i2), a2 = o2[0], c2 = o2[1];
          if ("function" != typeof c2)
            throw new B("Graph.".concat(e2, ": provided updater is not a function."));
          return a2.attributes = c2(a2.attributes), this.emit("nodeAttributesUpdated", { key: a2.key, type: "update", attributes: a2.attributes }), this;
        };
      } }];
      var X = [{ name: function(t2) {
        return "get".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2) {
          var i2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new I("Graph.".concat(e2, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi)
              throw new I("Graph.".concat(e2, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o2 = "" + t3, a2 = "" + r2;
            if (r2 = arguments[2], !(i2 = d(this, o2, a2, n3)))
              throw new F("Graph.".concat(e2, ': could not find an edge for the given path ("').concat(o2, '" - "').concat(a2, '").'));
          } else {
            if ("mixed" !== n3)
              throw new I("Graph.".concat(e2, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t3 = "" + t3, !(i2 = this._edges.get(t3)))
              throw new F("Graph.".concat(e2, ': could not find the "').concat(t3, '" edge in the graph.'));
          }
          return i2.attributes[r2];
        };
      } }, { name: function(t2) {
        return "get".concat(t2, "Attributes");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3) {
          var r2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new I("Graph.".concat(e2, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 1) {
            if (this.multi)
              throw new I("Graph.".concat(e2, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var i2 = "" + t3, o2 = "" + arguments[1];
            if (!(r2 = d(this, i2, o2, n3)))
              throw new F("Graph.".concat(e2, ': could not find an edge for the given path ("').concat(i2, '" - "').concat(o2, '").'));
          } else {
            if ("mixed" !== n3)
              throw new I("Graph.".concat(e2, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t3 = "" + t3, !(r2 = this._edges.get(t3)))
              throw new F("Graph.".concat(e2, ': could not find the "').concat(t3, '" edge in the graph.'));
          }
          return r2.attributes;
        };
      } }, { name: function(t2) {
        return "has".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2) {
          var i2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new I("Graph.".concat(e2, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi)
              throw new I("Graph.".concat(e2, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o2 = "" + t3, a2 = "" + r2;
            if (r2 = arguments[2], !(i2 = d(this, o2, a2, n3)))
              throw new F("Graph.".concat(e2, ': could not find an edge for the given path ("').concat(o2, '" - "').concat(a2, '").'));
          } else {
            if ("mixed" !== n3)
              throw new I("Graph.".concat(e2, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t3 = "" + t3, !(i2 = this._edges.get(t3)))
              throw new F("Graph.".concat(e2, ': could not find the "').concat(t3, '" edge in the graph.'));
          }
          return i2.attributes.hasOwnProperty(r2);
        };
      } }, { name: function(t2) {
        return "set".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2) {
          var o2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new I("Graph.".concat(e2, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 3) {
            if (this.multi)
              throw new I("Graph.".concat(e2, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var a2 = "" + t3, c2 = "" + r2;
            if (r2 = arguments[2], i2 = arguments[3], !(o2 = d(this, a2, c2, n3)))
              throw new F("Graph.".concat(e2, ': could not find an edge for the given path ("').concat(a2, '" - "').concat(c2, '").'));
          } else {
            if ("mixed" !== n3)
              throw new I("Graph.".concat(e2, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t3 = "" + t3, !(o2 = this._edges.get(t3)))
              throw new F("Graph.".concat(e2, ': could not find the "').concat(t3, '" edge in the graph.'));
          }
          return o2.attributes[r2] = i2, this.emit("edgeAttributesUpdated", { key: o2.key, type: "set", attributes: o2.attributes, name: r2 }), this;
        };
      } }, { name: function(t2) {
        return "update".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2) {
          var o2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new I("Graph.".concat(e2, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 3) {
            if (this.multi)
              throw new I("Graph.".concat(e2, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var a2 = "" + t3, c2 = "" + r2;
            if (r2 = arguments[2], i2 = arguments[3], !(o2 = d(this, a2, c2, n3)))
              throw new F("Graph.".concat(e2, ': could not find an edge for the given path ("').concat(a2, '" - "').concat(c2, '").'));
          } else {
            if ("mixed" !== n3)
              throw new I("Graph.".concat(e2, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t3 = "" + t3, !(o2 = this._edges.get(t3)))
              throw new F("Graph.".concat(e2, ': could not find the "').concat(t3, '" edge in the graph.'));
          }
          if ("function" != typeof i2)
            throw new B("Graph.".concat(e2, ": updater should be a function."));
          return o2.attributes[r2] = i2(o2.attributes[r2]), this.emit("edgeAttributesUpdated", { key: o2.key, type: "set", attributes: o2.attributes, name: r2 }), this;
        };
      } }, { name: function(t2) {
        return "remove".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2) {
          var i2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new I("Graph.".concat(e2, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi)
              throw new I("Graph.".concat(e2, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o2 = "" + t3, a2 = "" + r2;
            if (r2 = arguments[2], !(i2 = d(this, o2, a2, n3)))
              throw new F("Graph.".concat(e2, ': could not find an edge for the given path ("').concat(o2, '" - "').concat(a2, '").'));
          } else {
            if ("mixed" !== n3)
              throw new I("Graph.".concat(e2, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t3 = "" + t3, !(i2 = this._edges.get(t3)))
              throw new F("Graph.".concat(e2, ': could not find the "').concat(t3, '" edge in the graph.'));
          }
          return delete i2.attributes[r2], this.emit("edgeAttributesUpdated", { key: i2.key, type: "remove", attributes: i2.attributes, name: r2 }), this;
        };
      } }, { name: function(t2) {
        return "replace".concat(t2, "Attributes");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2) {
          var i2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new I("Graph.".concat(e2, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi)
              throw new I("Graph.".concat(e2, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o2 = "" + t3, a2 = "" + r2;
            if (r2 = arguments[2], !(i2 = d(this, o2, a2, n3)))
              throw new F("Graph.".concat(e2, ': could not find an edge for the given path ("').concat(o2, '" - "').concat(a2, '").'));
          } else {
            if ("mixed" !== n3)
              throw new I("Graph.".concat(e2, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t3 = "" + t3, !(i2 = this._edges.get(t3)))
              throw new F("Graph.".concat(e2, ': could not find the "').concat(t3, '" edge in the graph.'));
          }
          if (!s2(r2))
            throw new B("Graph.".concat(e2, ": provided attributes are not a plain object."));
          return i2.attributes = r2, this.emit("edgeAttributesUpdated", { key: i2.key, type: "replace", attributes: i2.attributes }), this;
        };
      } }, { name: function(t2) {
        return "merge".concat(t2, "Attributes");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2) {
          var i2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new I("Graph.".concat(e2, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi)
              throw new I("Graph.".concat(e2, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o2 = "" + t3, a2 = "" + r2;
            if (r2 = arguments[2], !(i2 = d(this, o2, a2, n3)))
              throw new F("Graph.".concat(e2, ': could not find an edge for the given path ("').concat(o2, '" - "').concat(a2, '").'));
          } else {
            if ("mixed" !== n3)
              throw new I("Graph.".concat(e2, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t3 = "" + t3, !(i2 = this._edges.get(t3)))
              throw new F("Graph.".concat(e2, ': could not find the "').concat(t3, '" edge in the graph.'));
          }
          if (!s2(r2))
            throw new B("Graph.".concat(e2, ": provided attributes are not a plain object."));
          return u(i2.attributes, r2), this.emit("edgeAttributesUpdated", { key: i2.key, type: "merge", attributes: i2.attributes, data: r2 }), this;
        };
      } }, { name: function(t2) {
        return "update".concat(t2, "Attributes");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2) {
          var i2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new I("Graph.".concat(e2, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi)
              throw new I("Graph.".concat(e2, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o2 = "" + t3, a2 = "" + r2;
            if (r2 = arguments[2], !(i2 = d(this, o2, a2, n3)))
              throw new F("Graph.".concat(e2, ': could not find an edge for the given path ("').concat(o2, '" - "').concat(a2, '").'));
          } else {
            if ("mixed" !== n3)
              throw new I("Graph.".concat(e2, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t3 = "" + t3, !(i2 = this._edges.get(t3)))
              throw new F("Graph.".concat(e2, ': could not find the "').concat(t3, '" edge in the graph.'));
          }
          if ("function" != typeof r2)
            throw new B("Graph.".concat(e2, ": provided updater is not a function."));
          return i2.attributes = r2(i2.attributes), this.emit("edgeAttributesUpdated", { key: i2.key, type: "update", attributes: i2.attributes }), this;
        };
      } }];
      var Z = O, $ = P, tt = function() {
        var t2 = arguments, e2 = null, n3 = -1;
        return new Z(function() {
          for (var r2 = null; ; ) {
            if (null === e2) {
              if (++n3 >= t2.length)
                return { done: true };
              e2 = $(t2[n3]);
            }
            if (true !== (r2 = e2.next()).done)
              break;
            e2 = null;
          }
          return r2;
        });
      }, et = [{ name: "edges", type: "mixed" }, { name: "inEdges", type: "directed", direction: "in" }, { name: "outEdges", type: "directed", direction: "out" }, { name: "inboundEdges", type: "mixed", direction: "in" }, { name: "outboundEdges", type: "mixed", direction: "out" }, { name: "directedEdges", type: "directed" }, { name: "undirectedEdges", type: "undirected" }];
      function nt(t2, e2, n3, r2) {
        var i2 = false;
        for (var o2 in e2)
          if (o2 !== r2) {
            var a2 = e2[o2];
            if (i2 = n3(a2.key, a2.attributes, a2.source.key, a2.target.key, a2.source.attributes, a2.target.attributes, a2.undirected), t2 && i2)
              return a2.key;
          }
      }
      function rt(t2, e2, n3, r2) {
        var i2, o2, a2, c2 = false;
        for (var u2 in e2)
          if (u2 !== r2) {
            i2 = e2[u2];
            do {
              if (o2 = i2.source, a2 = i2.target, c2 = n3(i2.key, i2.attributes, o2.key, a2.key, o2.attributes, a2.attributes, i2.undirected), t2 && c2)
                return i2.key;
              i2 = i2.next;
            } while (void 0 !== i2);
          }
      }
      function it(t2, e2) {
        var n3, r2 = Object.keys(t2), i2 = r2.length, o2 = 0;
        return new O(function() {
          do {
            if (n3)
              n3 = n3.next;
            else {
              if (o2 >= i2)
                return { done: true };
              var a2 = r2[o2++];
              if (a2 === e2) {
                n3 = void 0;
                continue;
              }
              n3 = t2[a2];
            }
          } while (!n3);
          return { done: false, value: { edge: n3.key, attributes: n3.attributes, source: n3.source.key, target: n3.target.key, sourceAttributes: n3.source.attributes, targetAttributes: n3.target.attributes, undirected: n3.undirected } };
        });
      }
      function ot(t2, e2, n3, r2) {
        var i2 = e2[n3];
        if (i2) {
          var o2 = i2.source, a2 = i2.target;
          return r2(i2.key, i2.attributes, o2.key, a2.key, o2.attributes, a2.attributes, i2.undirected) && t2 ? i2.key : void 0;
        }
      }
      function at(t2, e2, n3, r2) {
        var i2 = e2[n3];
        if (i2) {
          var o2 = false;
          do {
            if (o2 = r2(i2.key, i2.attributes, i2.source.key, i2.target.key, i2.source.attributes, i2.target.attributes, i2.undirected), t2 && o2)
              return i2.key;
            i2 = i2.next;
          } while (void 0 !== i2);
        }
      }
      function ct(t2, e2) {
        var n3 = t2[e2];
        return void 0 !== n3.next ? new O(function() {
          if (!n3)
            return { done: true };
          var t3 = { edge: n3.key, attributes: n3.attributes, source: n3.source.key, target: n3.target.key, sourceAttributes: n3.source.attributes, targetAttributes: n3.target.attributes, undirected: n3.undirected };
          return n3 = n3.next, { done: false, value: t3 };
        }) : O.of({ edge: n3.key, attributes: n3.attributes, source: n3.source.key, target: n3.target.key, sourceAttributes: n3.source.attributes, targetAttributes: n3.target.attributes, undirected: n3.undirected });
      }
      function ut(t2, e2) {
        if (0 === t2.size)
          return [];
        if ("mixed" === e2 || e2 === t2.type)
          return "function" == typeof Array.from ? Array.from(t2._edges.keys()) : K(t2._edges.keys(), t2._edges.size);
        for (var n3, r2, i2 = "undirected" === e2 ? t2.undirectedSize : t2.directedSize, o2 = new Array(i2), a2 = "undirected" === e2, c2 = t2._edges.values(), u2 = 0; true !== (n3 = c2.next()).done; )
          (r2 = n3.value).undirected === a2 && (o2[u2++] = r2.key);
        return o2;
      }
      function dt(t2, e2, n3, r2) {
        if (0 !== e2.size) {
          for (var i2, o2, a2 = "mixed" !== n3 && n3 !== e2.type, c2 = "undirected" === n3, u2 = false, d2 = e2._edges.values(); true !== (i2 = d2.next()).done; )
            if (o2 = i2.value, !a2 || o2.undirected === c2) {
              var s3 = o2, h2 = s3.key, p2 = s3.attributes, f2 = s3.source, l3 = s3.target;
              if (u2 = r2(h2, p2, f2.key, l3.key, f2.attributes, l3.attributes, o2.undirected), t2 && u2)
                return h2;
            }
        }
      }
      function st(t2, e2) {
        if (0 === t2.size)
          return O.empty();
        var n3 = "mixed" !== e2 && e2 !== t2.type, r2 = "undirected" === e2, i2 = t2._edges.values();
        return new O(function() {
          for (var t3, e3; ; ) {
            if ((t3 = i2.next()).done)
              return t3;
            if (e3 = t3.value, !n3 || e3.undirected === r2)
              break;
          }
          return { value: { edge: e3.key, attributes: e3.attributes, source: e3.source.key, target: e3.target.key, sourceAttributes: e3.source.attributes, targetAttributes: e3.target.attributes, undirected: e3.undirected }, done: false };
        });
      }
      function ht(t2, e2, n3, r2, i2, o2) {
        var a2, c2 = e2 ? rt : nt;
        if ("undirected" !== n3) {
          if ("out" !== r2 && (a2 = c2(t2, i2.in, o2), t2 && a2))
            return a2;
          if ("in" !== r2 && (a2 = c2(t2, i2.out, o2, r2 ? void 0 : i2.key), t2 && a2))
            return a2;
        }
        if ("directed" !== n3 && (a2 = c2(t2, i2.undirected, o2), t2 && a2))
          return a2;
      }
      function pt(t2, e2, n3, r2) {
        var i2 = [];
        return ht(false, t2, e2, n3, r2, function(t3) {
          i2.push(t3);
        }), i2;
      }
      function ft(t2, e2, n3) {
        var r2 = O.empty();
        return "undirected" !== t2 && ("out" !== e2 && void 0 !== n3.in && (r2 = tt(r2, it(n3.in))), "in" !== e2 && void 0 !== n3.out && (r2 = tt(r2, it(n3.out, e2 ? void 0 : n3.key)))), "directed" !== t2 && void 0 !== n3.undirected && (r2 = tt(r2, it(n3.undirected))), r2;
      }
      function lt(t2, e2, n3, r2, i2, o2, a2) {
        var c2, u2 = n3 ? at : ot;
        if ("undirected" !== e2) {
          if (void 0 !== i2.in && "out" !== r2 && (c2 = u2(t2, i2.in, o2, a2), t2 && c2))
            return c2;
          if (void 0 !== i2.out && "in" !== r2 && (r2 || i2.key !== o2) && (c2 = u2(t2, i2.out, o2, a2), t2 && c2))
            return c2;
        }
        if ("directed" !== e2 && void 0 !== i2.undirected && (c2 = u2(t2, i2.undirected, o2, a2), t2 && c2))
          return c2;
      }
      function gt(t2, e2, n3, r2, i2) {
        var o2 = [];
        return lt(false, t2, e2, n3, r2, i2, function(t3) {
          o2.push(t3);
        }), o2;
      }
      function yt(t2, e2, n3, r2) {
        var i2 = O.empty();
        return "undirected" !== t2 && (void 0 !== n3.in && "out" !== e2 && r2 in n3.in && (i2 = tt(i2, ct(n3.in, r2))), void 0 !== n3.out && "in" !== e2 && r2 in n3.out && (e2 || n3.key !== r2) && (i2 = tt(i2, ct(n3.out, r2)))), "directed" !== t2 && void 0 !== n3.undirected && r2 in n3.undirected && (i2 = tt(i2, ct(n3.undirected, r2))), i2;
      }
      var wt = [{ name: "neighbors", type: "mixed" }, { name: "inNeighbors", type: "directed", direction: "in" }, { name: "outNeighbors", type: "directed", direction: "out" }, { name: "inboundNeighbors", type: "mixed", direction: "in" }, { name: "outboundNeighbors", type: "mixed", direction: "out" }, { name: "directedNeighbors", type: "directed" }, { name: "undirectedNeighbors", type: "undirected" }];
      function vt() {
        this.A = null, this.B = null;
      }
      function bt(t2, e2, n3, r2, i2) {
        for (var o2 in r2) {
          var a2 = r2[o2], c2 = a2.source, u2 = a2.target, d2 = c2 === n3 ? u2 : c2;
          if (!e2 || !e2.has(d2.key)) {
            var s3 = i2(d2.key, d2.attributes);
            if (t2 && s3)
              return d2.key;
          }
        }
      }
      function mt(t2, e2, n3, r2, i2) {
        if ("mixed" !== e2) {
          if ("undirected" === e2)
            return bt(t2, null, r2, r2.undirected, i2);
          if ("string" == typeof n3)
            return bt(t2, null, r2, r2[n3], i2);
        }
        var o2, a2 = new vt();
        if ("undirected" !== e2) {
          if ("out" !== n3) {
            if (o2 = bt(t2, null, r2, r2.in, i2), t2 && o2)
              return o2;
            a2.wrap(r2.in);
          }
          if ("in" !== n3) {
            if (o2 = bt(t2, a2, r2, r2.out, i2), t2 && o2)
              return o2;
            a2.wrap(r2.out);
          }
        }
        if ("directed" !== e2 && (o2 = bt(t2, a2, r2, r2.undirected, i2), t2 && o2))
          return o2;
      }
      function kt(t2, e2, n3) {
        var r2 = Object.keys(n3), i2 = r2.length, o2 = 0;
        return new O(function() {
          var a2 = null;
          do {
            if (o2 >= i2)
              return t2 && t2.wrap(n3), { done: true };
            var c2 = n3[r2[o2++]], u2 = c2.source, d2 = c2.target;
            a2 = u2 === e2 ? d2 : u2, t2 && t2.has(a2.key) && (a2 = null);
          } while (null === a2);
          return { done: false, value: { neighbor: a2.key, attributes: a2.attributes } };
        });
      }
      function _t(t2, e2) {
        var n3 = e2.name, r2 = e2.type, i2 = e2.direction;
        t2.prototype[n3] = function(t3) {
          if ("mixed" !== r2 && "mixed" !== this.type && r2 !== this.type)
            return [];
          t3 = "" + t3;
          var e3 = this._nodes.get(t3);
          if (void 0 === e3)
            throw new F("Graph.".concat(n3, ': could not find the "').concat(t3, '" node in the graph.'));
          return function(t4, e4, n4) {
            if ("mixed" !== t4) {
              if ("undirected" === t4)
                return Object.keys(n4.undirected);
              if ("string" == typeof e4)
                return Object.keys(n4[e4]);
            }
            var r3 = [];
            return mt(false, t4, e4, n4, function(t5) {
              r3.push(t5);
            }), r3;
          }("mixed" === r2 ? this.type : r2, i2, e3);
        };
      }
      function Gt(t2, e2) {
        var n3 = e2.name, r2 = e2.type, i2 = e2.direction, o2 = n3.slice(0, -1) + "Entries";
        t2.prototype[o2] = function(t3) {
          if ("mixed" !== r2 && "mixed" !== this.type && r2 !== this.type)
            return O.empty();
          t3 = "" + t3;
          var e3 = this._nodes.get(t3);
          if (void 0 === e3)
            throw new F("Graph.".concat(o2, ': could not find the "').concat(t3, '" node in the graph.'));
          return function(t4, e4, n4) {
            if ("mixed" !== t4) {
              if ("undirected" === t4)
                return kt(null, n4, n4.undirected);
              if ("string" == typeof e4)
                return kt(null, n4, n4[e4]);
            }
            var r3 = O.empty(), i3 = new vt();
            return "undirected" !== t4 && ("out" !== e4 && (r3 = tt(r3, kt(i3, n4, n4.in))), "in" !== e4 && (r3 = tt(r3, kt(i3, n4, n4.out)))), "directed" !== t4 && (r3 = tt(r3, kt(i3, n4, n4.undirected))), r3;
          }("mixed" === r2 ? this.type : r2, i2, e3);
        };
      }
      function xt(t2, e2, n3, r2, i2) {
        for (var o2, a2, c2, u2, d2, s3, h2, p2 = r2._nodes.values(), f2 = r2.type; true !== (o2 = p2.next()).done; ) {
          var l3 = false;
          if (a2 = o2.value, "undirected" !== f2)
            for (c2 in u2 = a2.out) {
              d2 = u2[c2];
              do {
                if (s3 = d2.target, l3 = true, h2 = i2(a2.key, s3.key, a2.attributes, s3.attributes, d2.key, d2.attributes, d2.undirected), t2 && h2)
                  return d2;
                d2 = d2.next;
              } while (d2);
            }
          if ("directed" !== f2) {
            for (c2 in u2 = a2.undirected)
              if (!(e2 && a2.key > c2)) {
                d2 = u2[c2];
                do {
                  if ((s3 = d2.target).key !== c2 && (s3 = d2.source), l3 = true, h2 = i2(a2.key, s3.key, a2.attributes, s3.attributes, d2.key, d2.attributes, d2.undirected), t2 && h2)
                    return d2;
                  d2 = d2.next;
                } while (d2);
              }
          }
          if (n3 && !l3 && (h2 = i2(a2.key, null, a2.attributes, null, null, null, null), t2 && h2))
            return null;
        }
      }
      function Et(t2) {
        if (!s2(t2))
          throw new B('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');
        if (!("key" in t2))
          throw new B("Graph.import: serialized node is missing its key.");
        if ("attributes" in t2 && (!s2(t2.attributes) || null === t2.attributes))
          throw new B("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");
      }
      function At(t2) {
        if (!s2(t2))
          throw new B('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');
        if (!("source" in t2))
          throw new B("Graph.import: serialized edge is missing its source.");
        if (!("target" in t2))
          throw new B("Graph.import: serialized edge is missing its target.");
        if ("attributes" in t2 && (!s2(t2.attributes) || null === t2.attributes))
          throw new B("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");
        if ("undirected" in t2 && "boolean" != typeof t2.undirected)
          throw new B("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.");
      }
      vt.prototype.wrap = function(t2) {
        null === this.A ? this.A = t2 : null === this.B && (this.B = t2);
      }, vt.prototype.has = function(t2) {
        return null !== this.A && t2 in this.A || null !== this.B && t2 in this.B;
      };
      var Lt, St = (Lt = 255 & Math.floor(256 * Math.random()), function() {
        return Lt++;
      }), Dt = /* @__PURE__ */ new Set(["directed", "undirected", "mixed"]), Ut = /* @__PURE__ */ new Set(["domain", "_events", "_eventsCount", "_maxListeners"]), Nt = { allowSelfLoops: true, multi: false, type: "mixed" };
      function Ot(t2, e2, n3) {
        var r2 = new t2.NodeDataClass(e2, n3);
        return t2._nodes.set(e2, r2), t2.emit("nodeAdded", { key: e2, attributes: n3 }), r2;
      }
      function jt(t2, e2, n3, r2, i2, o2, a2, c2) {
        if (!r2 && "undirected" === t2.type)
          throw new I("Graph.".concat(e2, ": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead."));
        if (r2 && "directed" === t2.type)
          throw new I("Graph.".concat(e2, ": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead."));
        if (c2 && !s2(c2))
          throw new B("Graph.".concat(e2, ': invalid attributes. Expecting an object but got "').concat(c2, '"'));
        if (o2 = "" + o2, a2 = "" + a2, c2 = c2 || {}, !t2.allowSelfLoops && o2 === a2)
          throw new I("Graph.".concat(e2, ': source & target are the same ("').concat(o2, `"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`));
        var u2 = t2._nodes.get(o2), d2 = t2._nodes.get(a2);
        if (!u2)
          throw new F("Graph.".concat(e2, ': source node "').concat(o2, '" not found.'));
        if (!d2)
          throw new F("Graph.".concat(e2, ': target node "').concat(a2, '" not found.'));
        var h2 = { key: null, undirected: r2, source: o2, target: a2, attributes: c2 };
        if (n3)
          i2 = t2._edgeKeyGenerator();
        else if (i2 = "" + i2, t2._edges.has(i2))
          throw new I("Graph.".concat(e2, ': the "').concat(i2, '" edge already exists in the graph.'));
        if (!t2.multi && (r2 ? void 0 !== u2.undirected[a2] : void 0 !== u2.out[a2]))
          throw new I("Graph.".concat(e2, ': an edge linking "').concat(o2, '" to "').concat(a2, `" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`));
        var p2 = new V(r2, i2, u2, d2, c2);
        t2._edges.set(i2, p2);
        var f2 = o2 === a2;
        return r2 ? (u2.undirectedDegree++, d2.undirectedDegree++, f2 && (u2.undirectedLoops++, t2._undirectedSelfLoopCount++)) : (u2.outDegree++, d2.inDegree++, f2 && (u2.directedLoops++, t2._directedSelfLoopCount++)), t2.multi ? p2.attachMulti() : p2.attach(), r2 ? t2._undirectedSize++ : t2._directedSize++, h2.key = i2, t2.emit("edgeAdded", h2), i2;
      }
      function Ct(t2, e2, n3, r2, i2, o2, a2, c2, d2) {
        if (!r2 && "undirected" === t2.type)
          throw new I("Graph.".concat(e2, ": you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead."));
        if (r2 && "directed" === t2.type)
          throw new I("Graph.".concat(e2, ": you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead."));
        if (c2) {
          if (d2) {
            if ("function" != typeof c2)
              throw new B("Graph.".concat(e2, ': invalid updater function. Expecting a function but got "').concat(c2, '"'));
          } else if (!s2(c2))
            throw new B("Graph.".concat(e2, ': invalid attributes. Expecting an object but got "').concat(c2, '"'));
        }
        var h2;
        if (o2 = "" + o2, a2 = "" + a2, d2 && (h2 = c2, c2 = void 0), !t2.allowSelfLoops && o2 === a2)
          throw new I("Graph.".concat(e2, ': source & target are the same ("').concat(o2, `"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`));
        var p2, f2, l3 = t2._nodes.get(o2), g2 = t2._nodes.get(a2);
        if (!n3 && (p2 = t2._edges.get(i2))) {
          if (!(p2.source.key === o2 && p2.target.key === a2 || r2 && p2.source.key === a2 && p2.target.key === o2))
            throw new I("Graph.".concat(e2, ': inconsistency detected when attempting to merge the "').concat(i2, '" edge with "').concat(o2, '" source & "').concat(a2, '" target vs. ("').concat(p2.source.key, '", "').concat(p2.target.key, '").'));
          f2 = p2;
        }
        if (f2 || t2.multi || !l3 || (f2 = r2 ? l3.undirected[a2] : l3.out[a2]), f2) {
          var y2 = [f2.key, false, false, false];
          if (d2 ? !h2 : !c2)
            return y2;
          if (d2) {
            var w2 = f2.attributes;
            f2.attributes = h2(w2), t2.emit("edgeAttributesUpdated", { type: "replace", key: f2.key, attributes: f2.attributes });
          } else
            u(f2.attributes, c2), t2.emit("edgeAttributesUpdated", { type: "merge", key: f2.key, attributes: f2.attributes, data: c2 });
          return y2;
        }
        c2 = c2 || {}, d2 && h2 && (c2 = h2(c2));
        var v2 = { key: null, undirected: r2, source: o2, target: a2, attributes: c2 };
        if (n3)
          i2 = t2._edgeKeyGenerator();
        else if (i2 = "" + i2, t2._edges.has(i2))
          throw new I("Graph.".concat(e2, ': the "').concat(i2, '" edge already exists in the graph.'));
        var b2 = false, m2 = false;
        l3 || (l3 = Ot(t2, o2, {}), b2 = true, o2 === a2 && (g2 = l3, m2 = true)), g2 || (g2 = Ot(t2, a2, {}), m2 = true), p2 = new V(r2, i2, l3, g2, c2), t2._edges.set(i2, p2);
        var k2 = o2 === a2;
        return r2 ? (l3.undirectedDegree++, g2.undirectedDegree++, k2 && (l3.undirectedLoops++, t2._undirectedSelfLoopCount++)) : (l3.outDegree++, g2.inDegree++, k2 && (l3.directedLoops++, t2._directedSelfLoopCount++)), t2.multi ? p2.attachMulti() : p2.attach(), r2 ? t2._undirectedSize++ : t2._directedSize++, v2.key = i2, t2.emit("edgeAdded", v2), [i2, true, b2, m2];
      }
      function Mt(t2, e2) {
        t2._edges.delete(e2.key);
        var n3 = e2.source, r2 = e2.target, i2 = e2.attributes, o2 = e2.undirected, a2 = n3 === r2;
        o2 ? (n3.undirectedDegree--, r2.undirectedDegree--, a2 && (n3.undirectedLoops--, t2._undirectedSelfLoopCount--)) : (n3.outDegree--, r2.inDegree--, a2 && (n3.directedLoops--, t2._directedSelfLoopCount--)), t2.multi ? e2.detachMulti() : e2.detach(), o2 ? t2._undirectedSize-- : t2._directedSize--, t2.emit("edgeDropped", { key: e2.key, attributes: i2, source: n3.key, target: r2.key, undirected: o2 });
      }
      var zt = function(n3) {
        function r2(t2) {
          var e2;
          if (e2 = n3.call(this) || this, "boolean" != typeof (t2 = u({}, Nt, t2)).multi)
            throw new B(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "`.concat(t2.multi, '".'));
          if (!Dt.has(t2.type))
            throw new B(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "`.concat(t2.type, '".'));
          if ("boolean" != typeof t2.allowSelfLoops)
            throw new B(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "`.concat(t2.allowSelfLoops, '".'));
          var r3 = "mixed" === t2.type ? Y : "directed" === t2.type ? q : J;
          p(c(e2), "NodeDataClass", r3);
          var i3 = "geid_" + St() + "_", o2 = 0;
          return p(c(e2), "_attributes", {}), p(c(e2), "_nodes", /* @__PURE__ */ new Map()), p(c(e2), "_edges", /* @__PURE__ */ new Map()), p(c(e2), "_directedSize", 0), p(c(e2), "_undirectedSize", 0), p(c(e2), "_directedSelfLoopCount", 0), p(c(e2), "_undirectedSelfLoopCount", 0), p(c(e2), "_edgeKeyGenerator", function() {
            var t3;
            do {
              t3 = i3 + o2++;
            } while (e2._edges.has(t3));
            return t3;
          }), p(c(e2), "_options", t2), Ut.forEach(function(t3) {
            return p(c(e2), t3, e2[t3]);
          }), f(c(e2), "order", function() {
            return e2._nodes.size;
          }), f(c(e2), "size", function() {
            return e2._edges.size;
          }), f(c(e2), "directedSize", function() {
            return e2._directedSize;
          }), f(c(e2), "undirectedSize", function() {
            return e2._undirectedSize;
          }), f(c(e2), "selfLoopCount", function() {
            return e2._directedSelfLoopCount + e2._undirectedSelfLoopCount;
          }), f(c(e2), "directedSelfLoopCount", function() {
            return e2._directedSelfLoopCount;
          }), f(c(e2), "undirectedSelfLoopCount", function() {
            return e2._undirectedSelfLoopCount;
          }), f(c(e2), "multi", e2._options.multi), f(c(e2), "type", e2._options.type), f(c(e2), "allowSelfLoops", e2._options.allowSelfLoops), f(c(e2), "implementation", function() {
            return "graphology";
          }), e2;
        }
        e(r2, n3);
        var i2 = r2.prototype;
        return i2._resetInstanceCounters = function() {
          this._directedSize = 0, this._undirectedSize = 0, this._directedSelfLoopCount = 0, this._undirectedSelfLoopCount = 0;
        }, i2.hasNode = function(t2) {
          return this._nodes.has("" + t2);
        }, i2.hasDirectedEdge = function(t2, e2) {
          if ("undirected" === this.type)
            return false;
          if (1 === arguments.length) {
            var n4 = "" + t2, r3 = this._edges.get(n4);
            return !!r3 && !r3.undirected;
          }
          if (2 === arguments.length) {
            t2 = "" + t2, e2 = "" + e2;
            var i3 = this._nodes.get(t2);
            return !!i3 && i3.out.hasOwnProperty(e2);
          }
          throw new B("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length, ", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."));
        }, i2.hasUndirectedEdge = function(t2, e2) {
          if ("directed" === this.type)
            return false;
          if (1 === arguments.length) {
            var n4 = "" + t2, r3 = this._edges.get(n4);
            return !!r3 && r3.undirected;
          }
          if (2 === arguments.length) {
            t2 = "" + t2, e2 = "" + e2;
            var i3 = this._nodes.get(t2);
            return !!i3 && i3.undirected.hasOwnProperty(e2);
          }
          throw new B("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length, ", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."));
        }, i2.hasEdge = function(t2, e2) {
          if (1 === arguments.length) {
            var n4 = "" + t2;
            return this._edges.has(n4);
          }
          if (2 === arguments.length) {
            t2 = "" + t2, e2 = "" + e2;
            var r3 = this._nodes.get(t2);
            return !!r3 && (void 0 !== r3.out && r3.out.hasOwnProperty(e2) || void 0 !== r3.undirected && r3.undirected.hasOwnProperty(e2));
          }
          throw new B("Graph.hasEdge: invalid arity (".concat(arguments.length, ", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."));
        }, i2.directedEdge = function(t2, e2) {
          if ("undirected" !== this.type) {
            if (t2 = "" + t2, e2 = "" + e2, this.multi)
              throw new I("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");
            var n4 = this._nodes.get(t2);
            if (!n4)
              throw new F('Graph.directedEdge: could not find the "'.concat(t2, '" source node in the graph.'));
            if (!this._nodes.has(e2))
              throw new F('Graph.directedEdge: could not find the "'.concat(e2, '" target node in the graph.'));
            var r3 = n4.out && n4.out[e2] || void 0;
            return r3 ? r3.key : void 0;
          }
        }, i2.undirectedEdge = function(t2, e2) {
          if ("directed" !== this.type) {
            if (t2 = "" + t2, e2 = "" + e2, this.multi)
              throw new I("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");
            var n4 = this._nodes.get(t2);
            if (!n4)
              throw new F('Graph.undirectedEdge: could not find the "'.concat(t2, '" source node in the graph.'));
            if (!this._nodes.has(e2))
              throw new F('Graph.undirectedEdge: could not find the "'.concat(e2, '" target node in the graph.'));
            var r3 = n4.undirected && n4.undirected[e2] || void 0;
            return r3 ? r3.key : void 0;
          }
        }, i2.edge = function(t2, e2) {
          if (this.multi)
            throw new I("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new F('Graph.edge: could not find the "'.concat(t2, '" source node in the graph.'));
          if (!this._nodes.has(e2))
            throw new F('Graph.edge: could not find the "'.concat(e2, '" target node in the graph.'));
          var r3 = n4.out && n4.out[e2] || n4.undirected && n4.undirected[e2] || void 0;
          if (r3)
            return r3.key;
        }, i2.areDirectedNeighbors = function(t2, e2) {
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new F('Graph.areDirectedNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" !== this.type && (e2 in n4.in || e2 in n4.out);
        }, i2.areOutNeighbors = function(t2, e2) {
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new F('Graph.areOutNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" !== this.type && e2 in n4.out;
        }, i2.areInNeighbors = function(t2, e2) {
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new F('Graph.areInNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" !== this.type && e2 in n4.in;
        }, i2.areUndirectedNeighbors = function(t2, e2) {
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new F('Graph.areUndirectedNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "directed" !== this.type && e2 in n4.undirected;
        }, i2.areNeighbors = function(t2, e2) {
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new F('Graph.areNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" !== this.type && (e2 in n4.in || e2 in n4.out) || "directed" !== this.type && e2 in n4.undirected;
        }, i2.areInboundNeighbors = function(t2, e2) {
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new F('Graph.areInboundNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" !== this.type && e2 in n4.in || "directed" !== this.type && e2 in n4.undirected;
        }, i2.areOutboundNeighbors = function(t2, e2) {
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new F('Graph.areOutboundNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" !== this.type && e2 in n4.out || "directed" !== this.type && e2 in n4.undirected;
        }, i2.inDegree = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.inDegree: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e2.inDegree;
        }, i2.outDegree = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.outDegree: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e2.outDegree;
        }, i2.directedDegree = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.directedDegree: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e2.inDegree + e2.outDegree;
        }, i2.undirectedDegree = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.undirectedDegree: could not find the "'.concat(t2, '" node in the graph.'));
          return "directed" === this.type ? 0 : e2.undirectedDegree;
        }, i2.inboundDegree = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.inboundDegree: could not find the "'.concat(t2, '" node in the graph.'));
          var n4 = 0;
          return "directed" !== this.type && (n4 += e2.undirectedDegree), "undirected" !== this.type && (n4 += e2.inDegree), n4;
        }, i2.outboundDegree = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.outboundDegree: could not find the "'.concat(t2, '" node in the graph.'));
          var n4 = 0;
          return "directed" !== this.type && (n4 += e2.undirectedDegree), "undirected" !== this.type && (n4 += e2.outDegree), n4;
        }, i2.degree = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.degree: could not find the "'.concat(t2, '" node in the graph.'));
          var n4 = 0;
          return "directed" !== this.type && (n4 += e2.undirectedDegree), "undirected" !== this.type && (n4 += e2.inDegree + e2.outDegree), n4;
        }, i2.inDegreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.inDegreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e2.inDegree - e2.directedLoops;
        }, i2.outDegreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.outDegreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e2.outDegree - e2.directedLoops;
        }, i2.directedDegreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.directedDegreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e2.inDegree + e2.outDegree - 2 * e2.directedLoops;
        }, i2.undirectedDegreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.undirectedDegreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          return "directed" === this.type ? 0 : e2.undirectedDegree - 2 * e2.undirectedLoops;
        }, i2.inboundDegreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.inboundDegreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          var n4 = 0, r3 = 0;
          return "directed" !== this.type && (n4 += e2.undirectedDegree, r3 += 2 * e2.undirectedLoops), "undirected" !== this.type && (n4 += e2.inDegree, r3 += e2.directedLoops), n4 - r3;
        }, i2.outboundDegreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.outboundDegreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          var n4 = 0, r3 = 0;
          return "directed" !== this.type && (n4 += e2.undirectedDegree, r3 += 2 * e2.undirectedLoops), "undirected" !== this.type && (n4 += e2.outDegree, r3 += e2.directedLoops), n4 - r3;
        }, i2.degreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.degreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          var n4 = 0, r3 = 0;
          return "directed" !== this.type && (n4 += e2.undirectedDegree, r3 += 2 * e2.undirectedLoops), "undirected" !== this.type && (n4 += e2.inDegree + e2.outDegree, r3 += 2 * e2.directedLoops), n4 - r3;
        }, i2.source = function(t2) {
          t2 = "" + t2;
          var e2 = this._edges.get(t2);
          if (!e2)
            throw new F('Graph.source: could not find the "'.concat(t2, '" edge in the graph.'));
          return e2.source.key;
        }, i2.target = function(t2) {
          t2 = "" + t2;
          var e2 = this._edges.get(t2);
          if (!e2)
            throw new F('Graph.target: could not find the "'.concat(t2, '" edge in the graph.'));
          return e2.target.key;
        }, i2.extremities = function(t2) {
          t2 = "" + t2;
          var e2 = this._edges.get(t2);
          if (!e2)
            throw new F('Graph.extremities: could not find the "'.concat(t2, '" edge in the graph.'));
          return [e2.source.key, e2.target.key];
        }, i2.opposite = function(t2, e2) {
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._edges.get(e2);
          if (!n4)
            throw new F('Graph.opposite: could not find the "'.concat(e2, '" edge in the graph.'));
          var r3 = n4.source.key, i3 = n4.target.key;
          if (t2 === r3)
            return i3;
          if (t2 === i3)
            return r3;
          throw new F('Graph.opposite: the "'.concat(t2, '" node is not attached to the "').concat(e2, '" edge (').concat(r3, ", ").concat(i3, ")."));
        }, i2.hasExtremity = function(t2, e2) {
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._edges.get(t2);
          if (!n4)
            throw new F('Graph.hasExtremity: could not find the "'.concat(t2, '" edge in the graph.'));
          return n4.source.key === e2 || n4.target.key === e2;
        }, i2.isUndirected = function(t2) {
          t2 = "" + t2;
          var e2 = this._edges.get(t2);
          if (!e2)
            throw new F('Graph.isUndirected: could not find the "'.concat(t2, '" edge in the graph.'));
          return e2.undirected;
        }, i2.isDirected = function(t2) {
          t2 = "" + t2;
          var e2 = this._edges.get(t2);
          if (!e2)
            throw new F('Graph.isDirected: could not find the "'.concat(t2, '" edge in the graph.'));
          return !e2.undirected;
        }, i2.isSelfLoop = function(t2) {
          t2 = "" + t2;
          var e2 = this._edges.get(t2);
          if (!e2)
            throw new F('Graph.isSelfLoop: could not find the "'.concat(t2, '" edge in the graph.'));
          return e2.source === e2.target;
        }, i2.addNode = function(t2, e2) {
          var n4 = function(t3, e3, n5) {
            if (n5 && !s2(n5))
              throw new B('Graph.addNode: invalid attributes. Expecting an object but got "'.concat(n5, '"'));
            if (e3 = "" + e3, n5 = n5 || {}, t3._nodes.has(e3))
              throw new I('Graph.addNode: the "'.concat(e3, '" node already exist in the graph.'));
            var r3 = new t3.NodeDataClass(e3, n5);
            return t3._nodes.set(e3, r3), t3.emit("nodeAdded", { key: e3, attributes: n5 }), r3;
          }(this, t2, e2);
          return n4.key;
        }, i2.mergeNode = function(t2, e2) {
          if (e2 && !s2(e2))
            throw new B('Graph.mergeNode: invalid attributes. Expecting an object but got "'.concat(e2, '"'));
          t2 = "" + t2, e2 = e2 || {};
          var n4 = this._nodes.get(t2);
          return n4 ? (e2 && (u(n4.attributes, e2), this.emit("nodeAttributesUpdated", { type: "merge", key: t2, attributes: n4.attributes, data: e2 })), [t2, false]) : (n4 = new this.NodeDataClass(t2, e2), this._nodes.set(t2, n4), this.emit("nodeAdded", { key: t2, attributes: e2 }), [t2, true]);
        }, i2.updateNode = function(t2, e2) {
          if (e2 && "function" != typeof e2)
            throw new B('Graph.updateNode: invalid updater function. Expecting a function but got "'.concat(e2, '"'));
          t2 = "" + t2;
          var n4 = this._nodes.get(t2);
          if (n4) {
            if (e2) {
              var r3 = n4.attributes;
              n4.attributes = e2(r3), this.emit("nodeAttributesUpdated", { type: "replace", key: t2, attributes: n4.attributes });
            }
            return [t2, false];
          }
          var i3 = e2 ? e2({}) : {};
          return n4 = new this.NodeDataClass(t2, i3), this._nodes.set(t2, n4), this.emit("nodeAdded", { key: t2, attributes: i3 }), [t2, true];
        }, i2.dropNode = function(t2) {
          t2 = "" + t2;
          var e2, n4 = this._nodes.get(t2);
          if (!n4)
            throw new F('Graph.dropNode: could not find the "'.concat(t2, '" node in the graph.'));
          if ("undirected" !== this.type) {
            for (var r3 in n4.out) {
              e2 = n4.out[r3];
              do {
                Mt(this, e2), e2 = e2.next;
              } while (e2);
            }
            for (var i3 in n4.in) {
              e2 = n4.in[i3];
              do {
                Mt(this, e2), e2 = e2.next;
              } while (e2);
            }
          }
          if ("directed" !== this.type)
            for (var o2 in n4.undirected) {
              e2 = n4.undirected[o2];
              do {
                Mt(this, e2), e2 = e2.next;
              } while (e2);
            }
          this._nodes.delete(t2), this.emit("nodeDropped", { key: t2, attributes: n4.attributes });
        }, i2.dropEdge = function(t2) {
          var e2;
          if (arguments.length > 1) {
            var n4 = "" + arguments[0], r3 = "" + arguments[1];
            if (!(e2 = d(this, n4, r3, this.type)))
              throw new F('Graph.dropEdge: could not find the "'.concat(n4, '" -> "').concat(r3, '" edge in the graph.'));
          } else if (t2 = "" + t2, !(e2 = this._edges.get(t2)))
            throw new F('Graph.dropEdge: could not find the "'.concat(t2, '" edge in the graph.'));
          return Mt(this, e2), this;
        }, i2.dropDirectedEdge = function(t2, e2) {
          if (arguments.length < 2)
            throw new I("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");
          if (this.multi)
            throw new I("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");
          var n4 = d(this, t2 = "" + t2, e2 = "" + e2, "directed");
          if (!n4)
            throw new F('Graph.dropDirectedEdge: could not find a "'.concat(t2, '" -> "').concat(e2, '" edge in the graph.'));
          return Mt(this, n4), this;
        }, i2.dropUndirectedEdge = function(t2, e2) {
          if (arguments.length < 2)
            throw new I("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");
          if (this.multi)
            throw new I("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");
          var n4 = d(this, t2, e2, "undirected");
          if (!n4)
            throw new F('Graph.dropUndirectedEdge: could not find a "'.concat(t2, '" -> "').concat(e2, '" edge in the graph.'));
          return Mt(this, n4), this;
        }, i2.clear = function() {
          this._edges.clear(), this._nodes.clear(), this._resetInstanceCounters(), this.emit("cleared");
        }, i2.clearEdges = function() {
          for (var t2, e2 = this._nodes.values(); true !== (t2 = e2.next()).done; )
            t2.value.clear();
          this._edges.clear(), this._resetInstanceCounters(), this.emit("edgesCleared");
        }, i2.getAttribute = function(t2) {
          return this._attributes[t2];
        }, i2.getAttributes = function() {
          return this._attributes;
        }, i2.hasAttribute = function(t2) {
          return this._attributes.hasOwnProperty(t2);
        }, i2.setAttribute = function(t2, e2) {
          return this._attributes[t2] = e2, this.emit("attributesUpdated", { type: "set", attributes: this._attributes, name: t2 }), this;
        }, i2.updateAttribute = function(t2, e2) {
          if ("function" != typeof e2)
            throw new B("Graph.updateAttribute: updater should be a function.");
          var n4 = this._attributes[t2];
          return this._attributes[t2] = e2(n4), this.emit("attributesUpdated", { type: "set", attributes: this._attributes, name: t2 }), this;
        }, i2.removeAttribute = function(t2) {
          return delete this._attributes[t2], this.emit("attributesUpdated", { type: "remove", attributes: this._attributes, name: t2 }), this;
        }, i2.replaceAttributes = function(t2) {
          if (!s2(t2))
            throw new B("Graph.replaceAttributes: provided attributes are not a plain object.");
          return this._attributes = t2, this.emit("attributesUpdated", { type: "replace", attributes: this._attributes }), this;
        }, i2.mergeAttributes = function(t2) {
          if (!s2(t2))
            throw new B("Graph.mergeAttributes: provided attributes are not a plain object.");
          return u(this._attributes, t2), this.emit("attributesUpdated", { type: "merge", attributes: this._attributes, data: t2 }), this;
        }, i2.updateAttributes = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.updateAttributes: provided updater is not a function.");
          return this._attributes = t2(this._attributes), this.emit("attributesUpdated", { type: "update", attributes: this._attributes }), this;
        }, i2.updateEachNodeAttributes = function(t2, e2) {
          if ("function" != typeof t2)
            throw new B("Graph.updateEachNodeAttributes: expecting an updater function.");
          if (e2 && !l2(e2))
            throw new B("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");
          for (var n4, r3, i3 = this._nodes.values(); true !== (n4 = i3.next()).done; )
            (r3 = n4.value).attributes = t2(r3.key, r3.attributes);
          this.emit("eachNodeAttributesUpdated", { hints: e2 || null });
        }, i2.updateEachEdgeAttributes = function(t2, e2) {
          if ("function" != typeof t2)
            throw new B("Graph.updateEachEdgeAttributes: expecting an updater function.");
          if (e2 && !l2(e2))
            throw new B("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");
          for (var n4, r3, i3, o2, a2 = this._edges.values(); true !== (n4 = a2.next()).done; )
            i3 = (r3 = n4.value).source, o2 = r3.target, r3.attributes = t2(r3.key, r3.attributes, i3.key, o2.key, i3.attributes, o2.attributes, r3.undirected);
          this.emit("eachEdgeAttributesUpdated", { hints: e2 || null });
        }, i2.forEachAdjacencyEntry = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.forEachAdjacencyEntry: expecting a callback.");
          xt(false, false, false, this, t2);
        }, i2.forEachAdjacencyEntryWithOrphans = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");
          xt(false, false, true, this, t2);
        }, i2.forEachAssymetricAdjacencyEntry = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");
          xt(false, true, false, this, t2);
        }, i2.forEachAssymetricAdjacencyEntryWithOrphans = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");
          xt(false, true, true, this, t2);
        }, i2.nodes = function() {
          return "function" == typeof Array.from ? Array.from(this._nodes.keys()) : K(this._nodes.keys(), this._nodes.size);
        }, i2.forEachNode = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.forEachNode: expecting a callback.");
          for (var e2, n4, r3 = this._nodes.values(); true !== (e2 = r3.next()).done; )
            t2((n4 = e2.value).key, n4.attributes);
        }, i2.findNode = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.findNode: expecting a callback.");
          for (var e2, n4, r3 = this._nodes.values(); true !== (e2 = r3.next()).done; )
            if (t2((n4 = e2.value).key, n4.attributes))
              return n4.key;
        }, i2.mapNodes = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.mapNode: expecting a callback.");
          for (var e2, n4, r3 = this._nodes.values(), i3 = new Array(this.order), o2 = 0; true !== (e2 = r3.next()).done; )
            n4 = e2.value, i3[o2++] = t2(n4.key, n4.attributes);
          return i3;
        }, i2.someNode = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.someNode: expecting a callback.");
          for (var e2, n4, r3 = this._nodes.values(); true !== (e2 = r3.next()).done; )
            if (t2((n4 = e2.value).key, n4.attributes))
              return true;
          return false;
        }, i2.everyNode = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.everyNode: expecting a callback.");
          for (var e2, n4, r3 = this._nodes.values(); true !== (e2 = r3.next()).done; )
            if (!t2((n4 = e2.value).key, n4.attributes))
              return false;
          return true;
        }, i2.filterNodes = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.filterNodes: expecting a callback.");
          for (var e2, n4, r3 = this._nodes.values(), i3 = []; true !== (e2 = r3.next()).done; )
            t2((n4 = e2.value).key, n4.attributes) && i3.push(n4.key);
          return i3;
        }, i2.reduceNodes = function(t2, e2) {
          if ("function" != typeof t2)
            throw new B("Graph.reduceNodes: expecting a callback.");
          if (arguments.length < 2)
            throw new B("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");
          for (var n4, r3, i3 = e2, o2 = this._nodes.values(); true !== (n4 = o2.next()).done; )
            i3 = t2(i3, (r3 = n4.value).key, r3.attributes);
          return i3;
        }, i2.nodeEntries = function() {
          var t2 = this._nodes.values();
          return new O(function() {
            var e2 = t2.next();
            if (e2.done)
              return e2;
            var n4 = e2.value;
            return { value: { node: n4.key, attributes: n4.attributes }, done: false };
          });
        }, i2.export = function() {
          var t2 = this, e2 = new Array(this._nodes.size), n4 = 0;
          this._nodes.forEach(function(t3, r4) {
            e2[n4++] = function(t4, e3) {
              var n5 = { key: t4 };
              return h(e3.attributes) || (n5.attributes = u({}, e3.attributes)), n5;
            }(r4, t3);
          });
          var r3 = new Array(this._edges.size);
          return n4 = 0, this._edges.forEach(function(e3, i3) {
            r3[n4++] = function(t3, e4, n5) {
              var r4 = { key: e4, source: n5.source.key, target: n5.target.key };
              return h(n5.attributes) || (r4.attributes = u({}, n5.attributes)), "mixed" === t3 && n5.undirected && (r4.undirected = true), r4;
            }(t2.type, i3, e3);
          }), { options: { type: this.type, multi: this.multi, allowSelfLoops: this.allowSelfLoops }, attributes: this.getAttributes(), nodes: e2, edges: r3 };
        }, i2.import = function(t2) {
          var e2, n4, i3, o2, a2, c2 = this, u2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          if (t2 instanceof r2)
            return t2.forEachNode(function(t3, e3) {
              u2 ? c2.mergeNode(t3, e3) : c2.addNode(t3, e3);
            }), t2.forEachEdge(function(t3, e3, n5, r3, i4, o3, a3) {
              u2 ? a3 ? c2.mergeUndirectedEdgeWithKey(t3, n5, r3, e3) : c2.mergeDirectedEdgeWithKey(t3, n5, r3, e3) : a3 ? c2.addUndirectedEdgeWithKey(t3, n5, r3, e3) : c2.addDirectedEdgeWithKey(t3, n5, r3, e3);
            }), this;
          if (!s2(t2))
            throw new B("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");
          if (t2.attributes) {
            if (!s2(t2.attributes))
              throw new B("Graph.import: invalid attributes. Expecting a plain object.");
            u2 ? this.mergeAttributes(t2.attributes) : this.replaceAttributes(t2.attributes);
          }
          if (t2.nodes) {
            if (i3 = t2.nodes, !Array.isArray(i3))
              throw new B("Graph.import: invalid nodes. Expecting an array.");
            for (e2 = 0, n4 = i3.length; e2 < n4; e2++) {
              Et(o2 = i3[e2]);
              var d2 = o2, h2 = d2.key, p2 = d2.attributes;
              u2 ? this.mergeNode(h2, p2) : this.addNode(h2, p2);
            }
          }
          if (t2.edges) {
            var f2 = false;
            if ("undirected" === this.type && (f2 = true), i3 = t2.edges, !Array.isArray(i3))
              throw new B("Graph.import: invalid edges. Expecting an array.");
            for (e2 = 0, n4 = i3.length; e2 < n4; e2++) {
              At(a2 = i3[e2]);
              var l3 = a2, g2 = l3.source, y2 = l3.target, w2 = l3.attributes, v2 = l3.undirected, b2 = void 0 === v2 ? f2 : v2;
              "key" in a2 ? (u2 ? b2 ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey : b2 ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey).call(this, a2.key, g2, y2, w2) : (u2 ? b2 ? this.mergeUndirectedEdge : this.mergeDirectedEdge : b2 ? this.addUndirectedEdge : this.addDirectedEdge).call(this, g2, y2, w2);
            }
          }
          return this;
        }, i2.nullCopy = function(t2) {
          var e2 = new r2(u({}, this._options, t2));
          return e2.replaceAttributes(u({}, this.getAttributes())), e2;
        }, i2.emptyCopy = function(t2) {
          var e2 = this.nullCopy(t2);
          return this._nodes.forEach(function(t3, n4) {
            var r3 = u({}, t3.attributes);
            t3 = new e2.NodeDataClass(n4, r3), e2._nodes.set(n4, t3);
          }), e2;
        }, i2.copy = function(t2) {
          if ("string" == typeof (t2 = t2 || {}).type && t2.type !== this.type && "mixed" !== t2.type)
            throw new I('Graph.copy: cannot create an incompatible copy from "'.concat(this.type, '" type to "').concat(t2.type, '" because this would mean losing information about the current graph.'));
          if ("boolean" == typeof t2.multi && t2.multi !== this.multi && true !== t2.multi)
            throw new I("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");
          if ("boolean" == typeof t2.allowSelfLoops && t2.allowSelfLoops !== this.allowSelfLoops && true !== t2.allowSelfLoops)
            throw new I("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");
          for (var e2, n4, r3 = this.emptyCopy(t2), i3 = this._edges.values(); true !== (e2 = i3.next()).done; )
            jt(r3, "copy", false, (n4 = e2.value).undirected, n4.key, n4.source.key, n4.target.key, u({}, n4.attributes));
          return r3;
        }, i2.toJSON = function() {
          return this.export();
        }, i2.toString = function() {
          return "[object Graph]";
        }, i2.inspect = function() {
          var e2 = this, n4 = {};
          this._nodes.forEach(function(t2, e3) {
            n4[e3] = t2.attributes;
          });
          var r3 = {}, i3 = {};
          this._edges.forEach(function(t2, n5) {
            var o3, a3 = t2.undirected ? "--" : "->", c2 = "", u2 = t2.source.key, d2 = t2.target.key;
            t2.undirected && u2 > d2 && (o3 = u2, u2 = d2, d2 = o3);
            var s3 = "(".concat(u2, ")").concat(a3, "(").concat(d2, ")");
            n5.startsWith("geid_") ? e2.multi && (void 0 === i3[s3] ? i3[s3] = 0 : i3[s3]++, c2 += "".concat(i3[s3], ". ")) : c2 += "[".concat(n5, "]: "), r3[c2 += s3] = t2.attributes;
          });
          var o2 = {};
          for (var a2 in this)
            this.hasOwnProperty(a2) && !Ut.has(a2) && "function" != typeof this[a2] && "symbol" !== t(a2) && (o2[a2] = this[a2]);
          return o2.attributes = this._attributes, o2.nodes = n4, o2.edges = r3, p(o2, "constructor", this.constructor), o2;
        }, r2;
      }(y.exports.EventEmitter);
      "undefined" != typeof Symbol && (zt.prototype[Symbol.for("nodejs.util.inspect.custom")] = zt.prototype.inspect), [{ name: function(t2) {
        return "".concat(t2, "Edge");
      }, generateKey: true }, { name: function(t2) {
        return "".concat(t2, "DirectedEdge");
      }, generateKey: true, type: "directed" }, { name: function(t2) {
        return "".concat(t2, "UndirectedEdge");
      }, generateKey: true, type: "undirected" }, { name: function(t2) {
        return "".concat(t2, "EdgeWithKey");
      } }, { name: function(t2) {
        return "".concat(t2, "DirectedEdgeWithKey");
      }, type: "directed" }, { name: function(t2) {
        return "".concat(t2, "UndirectedEdgeWithKey");
      }, type: "undirected" }].forEach(function(t2) {
        ["add", "merge", "update"].forEach(function(e2) {
          var n3 = t2.name(e2), r2 = "add" === e2 ? jt : Ct;
          t2.generateKey ? zt.prototype[n3] = function(i2, o2, a2) {
            return r2(this, n3, true, "undirected" === (t2.type || this.type), null, i2, o2, a2, "update" === e2);
          } : zt.prototype[n3] = function(i2, o2, a2, c2) {
            return r2(this, n3, false, "undirected" === (t2.type || this.type), i2, o2, a2, c2, "update" === e2);
          };
        });
      }), function(t2) {
        Q.forEach(function(e2) {
          var n3 = e2.name, r2 = e2.attacher;
          r2(t2, n3("Node"), 0), r2(t2, n3("Source"), 1), r2(t2, n3("Target"), 2), r2(t2, n3("Opposite"), 3);
        });
      }(zt), function(t2) {
        X.forEach(function(e2) {
          var n3 = e2.name, r2 = e2.attacher;
          r2(t2, n3("Edge"), "mixed"), r2(t2, n3("DirectedEdge"), "directed"), r2(t2, n3("UndirectedEdge"), "undirected");
        });
      }(zt), function(t2) {
        et.forEach(function(e2) {
          !function(t3, e3) {
            var n3 = e3.name, r2 = e3.type, i2 = e3.direction;
            t3.prototype[n3] = function(t4, e4) {
              if ("mixed" !== r2 && "mixed" !== this.type && r2 !== this.type)
                return [];
              if (!arguments.length)
                return ut(this, r2);
              if (1 === arguments.length) {
                t4 = "" + t4;
                var o2 = this._nodes.get(t4);
                if (void 0 === o2)
                  throw new F("Graph.".concat(n3, ': could not find the "').concat(t4, '" node in the graph.'));
                return pt(this.multi, "mixed" === r2 ? this.type : r2, i2, o2);
              }
              if (2 === arguments.length) {
                t4 = "" + t4, e4 = "" + e4;
                var a2 = this._nodes.get(t4);
                if (!a2)
                  throw new F("Graph.".concat(n3, ':  could not find the "').concat(t4, '" source node in the graph.'));
                if (!this._nodes.has(e4))
                  throw new F("Graph.".concat(n3, ':  could not find the "').concat(e4, '" target node in the graph.'));
                return gt(r2, this.multi, i2, a2, e4);
              }
              throw new B("Graph.".concat(n3, ": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length, ")."));
            };
          }(t2, e2), function(t3, e3) {
            var n3 = e3.name, r2 = e3.type, i2 = e3.direction, o2 = "forEach" + n3[0].toUpperCase() + n3.slice(1, -1);
            t3.prototype[o2] = function(t4, e4, n4) {
              if ("mixed" === r2 || "mixed" === this.type || r2 === this.type) {
                if (1 === arguments.length)
                  return dt(false, this, r2, n4 = t4);
                if (2 === arguments.length) {
                  t4 = "" + t4, n4 = e4;
                  var a3 = this._nodes.get(t4);
                  if (void 0 === a3)
                    throw new F("Graph.".concat(o2, ': could not find the "').concat(t4, '" node in the graph.'));
                  return ht(false, this.multi, "mixed" === r2 ? this.type : r2, i2, a3, n4);
                }
                if (3 === arguments.length) {
                  t4 = "" + t4, e4 = "" + e4;
                  var c3 = this._nodes.get(t4);
                  if (!c3)
                    throw new F("Graph.".concat(o2, ':  could not find the "').concat(t4, '" source node in the graph.'));
                  if (!this._nodes.has(e4))
                    throw new F("Graph.".concat(o2, ':  could not find the "').concat(e4, '" target node in the graph.'));
                  return lt(false, r2, this.multi, i2, c3, e4, n4);
                }
                throw new B("Graph.".concat(o2, ": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length, ")."));
              }
            };
            var a2 = "map" + n3[0].toUpperCase() + n3.slice(1);
            t3.prototype[a2] = function() {
              var t4, e4 = Array.prototype.slice.call(arguments), n4 = e4.pop();
              if (0 === e4.length) {
                var i3 = 0;
                "directed" !== r2 && (i3 += this.undirectedSize), "undirected" !== r2 && (i3 += this.directedSize), t4 = new Array(i3);
                var a3 = 0;
                e4.push(function(e5, r3, i4, o3, c3, u3, d2) {
                  t4[a3++] = n4(e5, r3, i4, o3, c3, u3, d2);
                });
              } else
                t4 = [], e4.push(function(e5, r3, i4, o3, a4, c3, u3) {
                  t4.push(n4(e5, r3, i4, o3, a4, c3, u3));
                });
              return this[o2].apply(this, e4), t4;
            };
            var c2 = "filter" + n3[0].toUpperCase() + n3.slice(1);
            t3.prototype[c2] = function() {
              var t4 = Array.prototype.slice.call(arguments), e4 = t4.pop(), n4 = [];
              return t4.push(function(t5, r3, i3, o3, a3, c3, u3) {
                e4(t5, r3, i3, o3, a3, c3, u3) && n4.push(t5);
              }), this[o2].apply(this, t4), n4;
            };
            var u2 = "reduce" + n3[0].toUpperCase() + n3.slice(1);
            t3.prototype[u2] = function() {
              var t4, e4, n4 = Array.prototype.slice.call(arguments);
              if (n4.length < 2 || n4.length > 4)
                throw new B("Graph.".concat(u2, ": invalid number of arguments (expecting 2, 3 or 4 and got ").concat(n4.length, ")."));
              if ("function" == typeof n4[n4.length - 1] && "function" != typeof n4[n4.length - 2])
                throw new B("Graph.".concat(u2, ": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));
              2 === n4.length ? (t4 = n4[0], e4 = n4[1], n4 = []) : 3 === n4.length ? (t4 = n4[1], e4 = n4[2], n4 = [n4[0]]) : 4 === n4.length && (t4 = n4[2], e4 = n4[3], n4 = [n4[0], n4[1]]);
              var r3 = e4;
              return n4.push(function(e5, n5, i3, o3, a3, c3, u3) {
                r3 = t4(r3, e5, n5, i3, o3, a3, c3, u3);
              }), this[o2].apply(this, n4), r3;
            };
          }(t2, e2), function(t3, e3) {
            var n3 = e3.name, r2 = e3.type, i2 = e3.direction, o2 = "find" + n3[0].toUpperCase() + n3.slice(1, -1);
            t3.prototype[o2] = function(t4, e4, n4) {
              if ("mixed" !== r2 && "mixed" !== this.type && r2 !== this.type)
                return false;
              if (1 === arguments.length)
                return dt(true, this, r2, n4 = t4);
              if (2 === arguments.length) {
                t4 = "" + t4, n4 = e4;
                var a3 = this._nodes.get(t4);
                if (void 0 === a3)
                  throw new F("Graph.".concat(o2, ': could not find the "').concat(t4, '" node in the graph.'));
                return ht(true, this.multi, "mixed" === r2 ? this.type : r2, i2, a3, n4);
              }
              if (3 === arguments.length) {
                t4 = "" + t4, e4 = "" + e4;
                var c3 = this._nodes.get(t4);
                if (!c3)
                  throw new F("Graph.".concat(o2, ':  could not find the "').concat(t4, '" source node in the graph.'));
                if (!this._nodes.has(e4))
                  throw new F("Graph.".concat(o2, ':  could not find the "').concat(e4, '" target node in the graph.'));
                return lt(true, r2, this.multi, i2, c3, e4, n4);
              }
              throw new B("Graph.".concat(o2, ": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length, ")."));
            };
            var a2 = "some" + n3[0].toUpperCase() + n3.slice(1, -1);
            t3.prototype[a2] = function() {
              var t4 = Array.prototype.slice.call(arguments), e4 = t4.pop();
              return t4.push(function(t5, n4, r3, i3, o3, a3, c3) {
                return e4(t5, n4, r3, i3, o3, a3, c3);
              }), !!this[o2].apply(this, t4);
            };
            var c2 = "every" + n3[0].toUpperCase() + n3.slice(1, -1);
            t3.prototype[c2] = function() {
              var t4 = Array.prototype.slice.call(arguments), e4 = t4.pop();
              return t4.push(function(t5, n4, r3, i3, o3, a3, c3) {
                return !e4(t5, n4, r3, i3, o3, a3, c3);
              }), !this[o2].apply(this, t4);
            };
          }(t2, e2), function(t3, e3) {
            var n3 = e3.name, r2 = e3.type, i2 = e3.direction, o2 = n3.slice(0, -1) + "Entries";
            t3.prototype[o2] = function(t4, e4) {
              if ("mixed" !== r2 && "mixed" !== this.type && r2 !== this.type)
                return O.empty();
              if (!arguments.length)
                return st(this, r2);
              if (1 === arguments.length) {
                t4 = "" + t4;
                var n4 = this._nodes.get(t4);
                if (!n4)
                  throw new F("Graph.".concat(o2, ': could not find the "').concat(t4, '" node in the graph.'));
                return ft(r2, i2, n4);
              }
              if (2 === arguments.length) {
                t4 = "" + t4, e4 = "" + e4;
                var a2 = this._nodes.get(t4);
                if (!a2)
                  throw new F("Graph.".concat(o2, ':  could not find the "').concat(t4, '" source node in the graph.'));
                if (!this._nodes.has(e4))
                  throw new F("Graph.".concat(o2, ':  could not find the "').concat(e4, '" target node in the graph.'));
                return yt(r2, i2, a2, e4);
              }
              throw new B("Graph.".concat(o2, ": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length, ")."));
            };
          }(t2, e2);
        });
      }(zt), function(t2) {
        wt.forEach(function(e2) {
          _t(t2, e2), function(t3, e3) {
            var n3 = e3.name, r2 = e3.type, i2 = e3.direction, o2 = "forEach" + n3[0].toUpperCase() + n3.slice(1, -1);
            t3.prototype[o2] = function(t4, e4) {
              if ("mixed" === r2 || "mixed" === this.type || r2 === this.type) {
                t4 = "" + t4;
                var n4 = this._nodes.get(t4);
                if (void 0 === n4)
                  throw new F("Graph.".concat(o2, ': could not find the "').concat(t4, '" node in the graph.'));
                mt(false, "mixed" === r2 ? this.type : r2, i2, n4, e4);
              }
            };
            var a2 = "map" + n3[0].toUpperCase() + n3.slice(1);
            t3.prototype[a2] = function(t4, e4) {
              var n4 = [];
              return this[o2](t4, function(t5, r3) {
                n4.push(e4(t5, r3));
              }), n4;
            };
            var c2 = "filter" + n3[0].toUpperCase() + n3.slice(1);
            t3.prototype[c2] = function(t4, e4) {
              var n4 = [];
              return this[o2](t4, function(t5, r3) {
                e4(t5, r3) && n4.push(t5);
              }), n4;
            };
            var u2 = "reduce" + n3[0].toUpperCase() + n3.slice(1);
            t3.prototype[u2] = function(t4, e4, n4) {
              if (arguments.length < 3)
                throw new B("Graph.".concat(u2, ": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));
              var r3 = n4;
              return this[o2](t4, function(t5, n5) {
                r3 = e4(r3, t5, n5);
              }), r3;
            };
          }(t2, e2), function(t3, e3) {
            var n3 = e3.name, r2 = e3.type, i2 = e3.direction, o2 = n3[0].toUpperCase() + n3.slice(1, -1), a2 = "find" + o2;
            t3.prototype[a2] = function(t4, e4) {
              if ("mixed" === r2 || "mixed" === this.type || r2 === this.type) {
                t4 = "" + t4;
                var n4 = this._nodes.get(t4);
                if (void 0 === n4)
                  throw new F("Graph.".concat(a2, ': could not find the "').concat(t4, '" node in the graph.'));
                return mt(true, "mixed" === r2 ? this.type : r2, i2, n4, e4);
              }
            };
            var c2 = "some" + o2;
            t3.prototype[c2] = function(t4, e4) {
              return !!this[a2](t4, e4);
            };
            var u2 = "every" + o2;
            t3.prototype[u2] = function(t4, e4) {
              return !this[a2](t4, function(t5, n4) {
                return !e4(t5, n4);
              });
            };
          }(t2, e2), Gt(t2, e2);
        });
      }(zt);
      var Wt = function(t2) {
        function n3(e2) {
          var n4 = u({ type: "directed" }, e2);
          if ("multi" in n4 && false !== n4.multi)
            throw new B("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");
          if ("directed" !== n4.type)
            throw new B('DirectedGraph.from: inconsistent "' + n4.type + '" type in given options!');
          return t2.call(this, n4) || this;
        }
        return e(n3, t2), n3;
      }(zt), Pt = function(t2) {
        function n3(e2) {
          var n4 = u({ type: "undirected" }, e2);
          if ("multi" in n4 && false !== n4.multi)
            throw new B("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");
          if ("undirected" !== n4.type)
            throw new B('UndirectedGraph.from: inconsistent "' + n4.type + '" type in given options!');
          return t2.call(this, n4) || this;
        }
        return e(n3, t2), n3;
      }(zt), Rt = function(t2) {
        function n3(e2) {
          var n4 = u({ multi: true }, e2);
          if ("multi" in n4 && true !== n4.multi)
            throw new B("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");
          return t2.call(this, n4) || this;
        }
        return e(n3, t2), n3;
      }(zt), Kt = function(t2) {
        function n3(e2) {
          var n4 = u({ type: "directed", multi: true }, e2);
          if ("multi" in n4 && true !== n4.multi)
            throw new B("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");
          if ("directed" !== n4.type)
            throw new B('MultiDirectedGraph.from: inconsistent "' + n4.type + '" type in given options!');
          return t2.call(this, n4) || this;
        }
        return e(n3, t2), n3;
      }(zt), Tt = function(t2) {
        function n3(e2) {
          var n4 = u({ type: "undirected", multi: true }, e2);
          if ("multi" in n4 && true !== n4.multi)
            throw new B("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");
          if ("undirected" !== n4.type)
            throw new B('MultiUndirectedGraph.from: inconsistent "' + n4.type + '" type in given options!');
          return t2.call(this, n4) || this;
        }
        return e(n3, t2), n3;
      }(zt);
      function Bt(t2) {
        t2.from = function(e2, n3) {
          var r2 = u({}, e2.options, n3), i2 = new t2(r2);
          return i2.import(e2), i2;
        };
      }
      return Bt(zt), Bt(Wt), Bt(Pt), Bt(Rt), Bt(Kt), Bt(Tt), zt.Graph = zt, zt.DirectedGraph = Wt, zt.UndirectedGraph = Pt, zt.MultiGraph = Rt, zt.MultiDirectedGraph = Kt, zt.MultiUndirectedGraph = Tt, zt.InvalidArgumentsGraphError = B, zt.NotFoundGraphError = F, zt.UsageGraphError = I, zt;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BreadcrumbsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian37 = require("obsidian");

// src/codeblocks/index.ts
var import_obsidian = require("obsidian");

// src/external/dataview/index.ts
var import_obsidian_dataview = __toESM(require_lib());

// src/logger/index.ts
var LOG_LEVELS = [
  "DEBUG",
  "INFO",
  "WARN",
  "ERROR",
  // Some features log data
  "FEAT"
];
var LEVEL_COLOURS = {
  DEBUG: "#999",
  INFO: null,
  WARN: "#f90",
  ERROR: "#f00",
  FEAT: "#0f0"
};
var build_prefix = (level) => {
  const colour = LEVEL_COLOURS[level];
  const prefix = `[BC:${level}][${(/* @__PURE__ */ new Date()).toISOString().split("T")[1]}]`;
  return [
    colour ? `%c${prefix}` : prefix,
    colour ? `color: ${LEVEL_COLOURS[level]};` : "",
    "\n"
  ];
};
var Logger = class {
  constructor(level) {
    this.set_level(level);
  }
  debug(...args) {
    if (this.level_i <= 0) {
      console.log(...build_prefix("DEBUG"), ...args);
    }
  }
  info(...args) {
    if (this.level_i <= 1) {
      console.log(...build_prefix("INFO"), ...args);
    }
  }
  warn(...args) {
    if (this.level_i <= 2) {
      console.log(...build_prefix("WARN"), ...args);
    }
  }
  error(...args) {
    if (this.level_i <= 3) {
      console.log(...build_prefix("ERROR"), ...args);
    }
  }
  feat(...args) {
    if (this.level_i <= 4) {
      console.log(...build_prefix("FEAT"), ...args);
    }
  }
  set_level(level) {
    this.level_i = LOG_LEVELS.findIndex((l2) => l2 === level);
  }
};
var log = new Logger("INFO");

// src/external/dataview/index.ts
var await_if_enabled = (plugin) => new Promise((resolve) => {
  var _a;
  if ((0, import_obsidian_dataview.isPluginEnabled)(plugin.app)) {
    if ((_a = (0, import_obsidian_dataview.getAPI)(plugin.app)) == null ? void 0 : _a.index.initialized) {
      log.debug("dataview > already initialized");
      resolve();
    }
    plugin.registerEvent(
      plugin.app.metadataCache.on(
        //@ts-ignore: It's there if dataview is enabled
        "dataview:index-ready",
        () => {
          log.debug("dataview > ready");
          resolve();
        }
      )
    );
  } else {
    log.debug("dataview > not enabled");
    resolve();
  }
});
var dataview_plugin = {
  get_api: import_obsidian_dataview.getAPI,
  is_enabled: import_obsidian_dataview.isPluginEnabled,
  await_if_enabled
};

// src/utils/arrays.ts
var ensure_is_array = (maybe_array) => {
  if (Array.isArray(maybe_array))
    return maybe_array;
  return [maybe_array];
};
var ensure_square_array = (arr, fill, pre) => {
  const max_width = Math.max(...arr.map((row) => row.length));
  return arr.map((row) => {
    const diff = max_width - row.length;
    if (pre) {
      return Array(diff).fill(fill).concat(row);
    } else {
      return row.concat(Array(diff).fill(fill));
    }
  });
};
var transpose = (arr) => {
  const transposed = [];
  if (!arr.length)
    return transposed;
  for (let i = 0; i < arr.at(0).length; i++) {
    transposed.push([]);
    for (let j = 0; j < arr.length; j++) {
      transposed[i].push(arr[j][i]);
    }
  }
  return transposed;
};
var gather_by_runs = (arr, get_value) => {
  const runs = [];
  for (let i = 0; i < arr.length; i++) {
    const last_run = runs.at(-1);
    const value = get_value(arr[i]);
    if (last_run && last_run.value === value) {
      last_run.last = i;
    } else {
      runs.push({ value, first: i, last: i });
    }
  }
  return runs;
};
var group_by = (list, get_value, project = (item) => item) => {
  const grouped = {};
  list.forEach((item) => {
    const key = get_value(item);
    if (key === void 0)
      return;
    const group = grouped[key];
    const projected = project(item);
    if (!group)
      grouped[key] = [projected];
    else
      group.push(projected);
  });
  return grouped;
};
var group_projection = (grouped, projector) => {
  const projected = {};
  Object.entries(grouped).forEach(([key, items]) => {
    projected[key] = projector(items);
  });
  return projected;
};
var remove_duplicates = (arr) => {
  const set = new Set(arr);
  return Array.from(set);
};
var remove_duplicates_by = (arr, get_value) => {
  const set = /* @__PURE__ */ new Set();
  const unique = [];
  arr.forEach((item) => {
    const value = get_value(item);
    if (set.has(value))
      return;
    set.add(value);
    unique.push(item);
  });
  return unique;
};

// src/utils/objects.ts
function deep_merge_objects(obj1, obj2) {
  const result = { ...obj1 };
  for (const key in obj2) {
    const val1 = obj1[key];
    const val2 = obj2[key];
    if (typeof val1 === "object" && typeof val2 === "object" && !Array.isArray(val1) && !Array.isArray(val2)) {
      result[key] = deep_merge_objects(val1, val2);
    } else if (val1 === void 0) {
      result[key] = val2;
    }
  }
  return result;
}
var deep_access = (obj, path) => {
  let current = obj;
  for (const key of path) {
    if (current[key] === void 0) {
      return void 0;
    }
    current = current[key];
  }
  return current;
};
var untyped_pick = (obj, keys) => Object.fromEntries(
  Object.entries(obj).filter(([key]) => keys.includes(key))
);
var remove_nullish_keys = (obj) => Object.fromEntries(
  Object.entries(obj).filter(
    ([_, val]) => val !== null && val !== void 0
  )
);

// src/utils/strings.ts
var split_and_trim = (str, delimiter = ",") => {
  if (!str || str === "")
    return [];
  else
    return str.split(delimiter).map((str2) => str2.trim());
};
var quote_join = (arr, quote = '"', joiner = ", ") => arr.map((str) => quote + str + quote).join(joiner);
var ensure_starts_with = (str, prefix) => str.startsWith(prefix) ? str : prefix + str;
var ensure_ends_with = (str, suffix) => str.endsWith(suffix) ? str : str + suffix;
var ensure_not_ends_with = (str, suffix) => str.endsWith(suffix) ? str.slice(0, -suffix.length) : str;
var TEMPLATE_REGEX = /{{(.*?)}}/g;
var resolve_templates = (str, templates) => {
  var _a;
  let resolved = str.slice();
  (_a = resolved.match(TEMPLATE_REGEX)) == null ? void 0 : _a.forEach((match2) => {
    const key = match2.slice(2, -2);
    const value = deep_access(templates, key.split("."));
    if (value !== void 0) {
      resolved = resolved.replace(match2, String(value));
    }
  });
  return resolved;
};
var wrap_in_codeblock = (str, lang = "") => "```" + lang + "\n" + str + "\n```";

// src/utils/paths.ts
var ensure_ext = (path, ext = "md") => ensure_ends_with(path, "." + ext);
var drop_ext = (path) => path.replace(/\.[^.]+$/, "");
var extname = (path) => path.split(".").pop();
var drop_folder = (path) => path.split("/").pop();
var dirname = (path) => path.split("/").slice(0, -1).join("/");
var basename = (path) => drop_ext(path.split("/").pop());
var normalise = (path) => path.replace(/\/+/g, "/").replace(/^\//, "");
var build = (folder, basename2, ext) => ensure_ext(normalise(folder + "/" + basename2), ext);
var show = (path, show_node_options) => {
  let output = path.slice();
  if (!(show_node_options == null ? void 0 : show_node_options.folder)) {
    output = drop_folder(output);
  }
  if (!(show_node_options == null ? void 0 : show_node_options.ext)) {
    output = drop_ext(output);
  }
  return output;
};
var Paths = {
  ensure_ext,
  extname,
  basename,
  dirname,
  drop_ext,
  drop_folder,
  build,
  normalise,
  show
};

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class _ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex2 = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex2 = `${regex2}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex2 = `${regex2}(\\.\\d+)?`;
  }
  return regex2;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex2 = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex2 = `${regex2}(${opts.join("|")})`;
  return new RegExp(`^${regex2}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex2 = datetimeRegex(check);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex2 = dateRegex;
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex2 = timeRegex(check);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex2, validation, message) {
    return this.refinement((data) => regex2.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex2, message) {
    return this._addCheck({
      kind: "regex",
      regex: regex2,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element2 of elements2) {
        if (element2.status === "aborted")
          return INVALID;
        if (element2.status === "dirty")
          status.dirty();
        parsedSet.add(element2.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function custom(check, params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// src/const/graph.ts
var EXPLICIT_EDGE_SOURCES = [
  "typed_link",
  "tag_note",
  "list_note",
  "dendron_note",
  "johnny_decimal_note",
  "dataview_note",
  "date_note",
  "folder_note",
  "regex_note"
  // TODO: "zetel_note", // Can date_notes do this already?
];
var SIMPLE_EDGE_SORT_FIELDS = [
  // The order they were added to the graph
  // Hidden because I don't think anyone really cares about that order
  // "graph",
  "basename",
  "path",
  "field",
  // Whether the edge is explicit or not
  // Uses source and implied_kind as tie-breakers for explicit == true and false, respectively
  "explicit"
];
var COMPLEX_EDGE_SORT_FIELD_PREFIXES = ["neighbour-field"];

// src/graph/MyMultiGraph.ts
var import_graphology = __toESM(require_graphology_umd_min());

// src/utils/result.ts
var succ = (data) => ({
  ok: true,
  data
});
var fail = (error) => ({
  ok: false,
  error
});
var graph_build_fail = (error) => fail(error);

// src/graph/objectify_mappers.ts
var objectify_edge_mapper = (cb) => (edge_id, attr2, source_id, target_id, source_attr, target_attr, undirected) => cb({
  id: edge_id,
  attr: attr2,
  source_id,
  target_id,
  source_attr,
  target_attr,
  undirected
});
var objectify_edge = objectify_edge_mapper((e) => e);

// src/graph/utils.ts
var is_self_loop = (edge) => edge.source_id === edge.target_id;
var stringify_node = (node_id, node_attr, options) => {
  var _a, _b;
  if (((_a = options == null ? void 0 : options.show_node_options) == null ? void 0 : _a.alias) && ((_b = node_attr.aliases) == null ? void 0 : _b.length)) {
    return node_attr.aliases.at(0);
  } else if (options == null ? void 0 : options.trim_basename_delimiter) {
    return Paths.drop_ext(node_id).split("/").pop().split(options.trim_basename_delimiter).last();
  } else {
    return Paths.show(node_id, options == null ? void 0 : options.show_node_options);
  }
};
var sorters = {
  path: (order) => (a, b) => a.target_id.localeCompare(b.target_id) * order,
  basename: (order) => (a, b) => {
    const [a_field, b_field] = [
      Paths.drop_folder(a.target_id),
      Paths.drop_folder(b.target_id)
    ];
    return a_field.localeCompare(b_field) * order;
  },
  field: (order) => (a, b) => {
    var _a, _b;
    const [a_field, b_field] = [
      (_a = a.attr.field) != null ? _a : "null",
      (_b = b.attr.field) != null ? _b : "null"
    ];
    return a_field.localeCompare(b_field) * order;
  }
};
var get_edge_sorter = (sort, graph) => {
  switch (sort.field) {
    case "path": {
      return sorters.path(sort.order);
    }
    case "basename": {
      return sorters.basename(sort.order);
    }
    case "field": {
      return sorters.field(sort.order);
    }
    case "explicit": {
      return (a, b) => {
        if (a.attr.explicit === true && b.attr.explicit === true) {
          return a.attr.source.localeCompare(b.attr.source) * sort.order;
        } else if (a.attr.explicit === false && b.attr.explicit === false) {
          return a.attr.implied_kind.localeCompare(b.attr.implied_kind) * sort.order;
        } else {
          return a.attr.explicit ? sort.order : -sort.order;
        }
      };
    }
    default: {
      if (!COMPLEX_EDGE_SORT_FIELD_PREFIXES.some(
        (f) => sort.field.startsWith(f + ":")
      )) {
        throw new Error(`Invalid sort field: ${sort.field}`);
      }
      switch (sort.field.split(":")[0]) {
        case "neighbour":
        case "neighbour-field": {
          const field = sort.field.split(":", 2).at(1);
          const cache = {};
          return (a, b) => {
            var _a, _b, _c, _d;
            const [a_neighbour, b_neighbour] = [
              (_b = cache[_a = a.target_id]) != null ? _b : cache[_a] = graph.get_out_edges(a.target_id).filter((e) => has_edge_attrs(e, { field })).at(0),
              (_d = cache[_c = b.target_id]) != null ? _d : cache[_c] = graph.get_out_edges(b.target_id).filter((e) => has_edge_attrs(e, { field })).at(0)
            ];
            if (!a_neighbour || !b_neighbour) {
              return a_neighbour ? -sort.order : b_neighbour ? sort.order : 0;
            } else {
              return sorters.path(sort.order)(
                a_neighbour,
                b_neighbour
              );
            }
          };
        }
        default: {
          return (_a, _b) => sort.order;
        }
      }
    }
  }
};
var has_edge_attrs = (edge, attrs) => {
  var _a;
  return attrs === void 0 || [
    attrs.field === void 0 || edge.attr.field === attrs.field,
    attrs.explicit === void 0 || edge.attr.explicit === attrs.explicit,
    attrs.$or_fields === void 0 || attrs.$or_fields.includes((_a = edge.attr.field) != null ? _a : "null"),
    attrs.$or_target_ids === void 0 || attrs.$or_target_ids.includes(edge.target_id)
  ].every(Boolean);
};

// src/graph/MyMultiGraph.ts
var EDGE_ATTRIBUTES = [
  "field",
  "explicit",
  "source",
  "implied_kind",
  "round"
];
var BCGraph = class extends import_graphology.MultiGraph {
  constructor(input) {
    var _a, _b;
    super();
    /** Uniquely identify an edge based on its:
     * - source_id
     * - target_id
     * - field
     */
    this.make_edge_id = (source_id, target_id, attr2) => `${source_id}|${attr2.field}|${target_id}`;
    // NOTE: These fields shouldn't actually dedupe an edge... I think what the user would consider an edge to be the same
    //   even if it was added for different reasons, but still to and from the same nodes, using the same field.
    //   Consider the commands/freeze-crumbs/index.md note as an example. If these fields were included, the implied relations would still show
    //   even tho there are now frozen real relations serving the exact same purpose.
    // |${attr.explicit ? "explicit|" + attr.source : "implied|" + attr.implied_kind}
    /** Return true if the edge was added.
     * Won't be added if it already exists (based on it's {@link this.make_edge_id}),
     * 	or if it's target_node has ingore_in_edges */
    this.safe_add_directed_edge = (source_id, target_id, attr2) => {
      if (this.getNodeAttribute(target_id, "ignore_in_edges")) {
        log.debug(
          `ignore-in-edge > ${source_id} -${attr2.field}-> ${target_id}`
        );
        return false;
      } else if (this.getNodeAttribute(source_id, "ignore_out_edges")) {
        log.debug(
          `ignore-out-edge > ${source_id} -${attr2.field}-> ${target_id}`
        );
        return false;
      }
      const edge_id = this.make_edge_id(source_id, target_id, attr2);
      if (!this.hasDirectedEdge(edge_id)) {
        this.addDirectedEdgeWithKey(edge_id, source_id, target_id, attr2);
        return true;
      } else {
        return false;
      }
    };
    /** safely returns [] if node_id and !hasNode(node_id) */
    this.get_in_edges = (node_id) => node_id ? this.hasNode(node_id) ? this.mapInEdges(node_id, objectify_edge) : [] : this.mapInEdges(objectify_edge);
    /** safely returns [] if node_id and !hasNode(node_id) */
    this.get_out_edges = (node_id) => node_id ? this.hasNode(node_id) ? this.mapOutEdges(node_id, objectify_edge) : [] : this.mapOutEdges(objectify_edge);
    if (input) {
      (_a = input.nodes) == null ? void 0 : _a.forEach(
        ({ id, attr: attr2 }) => this.safe_add_node(id, attr2)
      );
      (_b = input.edges) == null ? void 0 : _b.forEach((edge) => {
        this.safe_add_node(edge.source_id, { resolved: true });
        this.safe_add_node(edge.target_id, { resolved: true });
        this.safe_add_directed_edge(
          edge.source_id,
          edge.target_id,
          edge.attr
        );
      });
    }
  }
  safe_add_node(id, attr2) {
    try {
      this.addNode(id, attr2);
      return true;
    } catch (error) {
      return false;
    }
  }
  /** Upsert a node by it's id (path). If it exists, patch attr, else addNode */
  upsert_node(id, attr2) {
    if (this.hasNode(id)) {
      Object.keys(attr2).forEach((key) => {
        this.setNodeAttribute(
          id,
          key,
          attr2[key]
        );
      });
    } else {
      this.addNode(id, attr2);
    }
  }
  safe_rename_node(old_id, new_id) {
    const exists = {
      old: this.hasNode(old_id),
      new: this.hasNode(new_id)
    };
    if (!exists.old) {
      return fail({ exists, message: "old_id doesn't exist" });
    } else if (exists.new) {
      return fail({ exists, message: "new_id already exists" });
    } else {
      this.addNode(new_id, this.getNodeAttributes(old_id));
      const old_edges = {
        in: this.get_in_edges(old_id),
        out: this.get_out_edges(old_id)
      };
      this.dropNode(old_id);
      old_edges.in.forEach((old_in_edge) => {
        is_self_loop(old_in_edge) ? this.safe_add_directed_edge(
          new_id,
          new_id,
          old_in_edge.attr
        ) : this.safe_add_directed_edge(
          old_in_edge.source_id,
          new_id,
          old_in_edge.attr
        );
      });
      old_edges.out.forEach((old_out_edge) => {
        !is_self_loop(old_out_edge) && this.safe_add_directed_edge(
          new_id,
          old_out_edge.target_id,
          old_out_edge.attr
        );
      });
    }
    return succ({ exists });
  }
};

// src/utils/edge_fields.ts
var resolve_field_group_labels = (edge_field_groups, field_group_labels) => remove_duplicates(
  edge_field_groups.filter((group) => field_group_labels.includes(group.label)).flatMap((group) => group.fields)
);

// src/utils/url.ts
var url_search_params = (obj, options) => {
  const { delimiter } = Object.assign({ delimiter: " " }, options);
  let params = "";
  for (const key in obj) {
    params += `${key}=${obj[key]}${delimiter}`;
  }
  params = params.slice(0, -1);
  if ((options == null ? void 0 : options.trim_lone_param) && Object.keys(obj).length === 1) {
    params = params.split("=", 2)[1];
  }
  return params;
};

// src/utils/mermaid.ts
var MERMAID_DIRECTIONS = ["LR", "RL", "TB", "BT"];
var MERMAID_RENDERER = ["dagre", "elk"];
var MERMAID_CURVE_STYLES = [
  "basis",
  "bumpX",
  "bumpY",
  "cardinal",
  "catmullRom",
  "linear",
  "monotoneX",
  "monotoneY",
  "natural",
  "step",
  "stepAfter",
  "stepBefore"
];
var build_arrow = (e) => e.attr.explicit ? "-->" : "-.->";
var build_attrs = (attr2, show_attributes) => {
  const params = (show_attributes == null ? void 0 : show_attributes.length) ? url_search_params(untyped_pick(attr2, show_attributes), {
    trim_lone_param: true
  }) : null;
  return (params == null ? void 0 : params.length) ? `|"${params}"|` : "";
};
var from_edges = (edges, config) => {
  var _a, _b, _c, _d, _e;
  const resolved = Object.assign(
    { direction: "LR", kind: "flowchart" },
    remove_nullish_keys(
      config != null ? config : {}
    )
  );
  const flowchart_init = remove_nullish_keys({
    curve: resolved.curve_style,
    defaultRenderer: resolved.renderer
  });
  const lines = [
    // NOTE: Regardless of kind, the below field should always be flowchart
    `%%{ init: { "flowchart": ${JSON.stringify(flowchart_init)} } }%%`,
    `${resolved.kind} ${resolved.direction}`
  ];
  const node_map = remove_duplicates_by(
    // NOTE: This is _pretty_ inefficient, but necessary.
    // If we just take all unique target_ids, we miss source nodes that don't have any incoming edges.
    edges.flatMap((e) => [
      { path: e.source_id, attr: e.source_attr },
      { path: e.target_id, attr: e.target_attr }
    ]),
    (n2) => n2.path
  ).reduce(
    (map, node, i) => {
      var _a2, _b2;
      return map.set(node.path, {
        i,
        attr: node.attr,
        label: (_b2 = (_a2 = resolved.get_node_label) == null ? void 0 : _a2.call(resolved, node.path, node.attr)) != null ? _b2 : node.path
      });
    },
    /* @__PURE__ */ new Map()
  );
  node_map.forEach((node) => {
    lines.push(`	${node.i}("${node.label}")`);
  });
  lines.push("");
  const mermaid_edges = [];
  for (const edge of edges) {
    const [source_i, target_i] = [
      node_map.get(edge.source_id).i,
      node_map.get(edge.target_id).i
    ];
    const opposing_edge_i = resolved.collapse_opposing_edges !== false ? mermaid_edges.findIndex(
      (existing) => (
        // NOTE: This is pretty intense, all opposing edges will collapse, because now there's no direction semantics
        target_i === existing.source_i && source_i === existing.target_i
      )
    ) : -1;
    if (opposing_edge_i === -1) {
      mermaid_edges.push({
        source_i,
        target_i,
        arrow: build_arrow(edge),
        attr: edge.attr,
        collapsed_attr: Object.fromEntries(
          (_b = (_a = resolved.show_attributes) == null ? void 0 : _a.map((attr2) => {
            var _a2;
            return [
              attr2,
              /* @__PURE__ */ new Set([
                // @ts-ignore: If the property is not in the object, it will be undefined
                (_a2 = edge.attr[attr2]) != null ? _a2 : "_"
              ])
            ];
          })) != null ? _b : []
        )
      });
    } else {
      const existing = mermaid_edges[opposing_edge_i];
      existing.arrow = edge.attr.explicit || existing.attr.explicit ? "---" : "-.-";
      (_c = resolved.show_attributes) == null ? void 0 : _c.forEach((attr2) => {
        var _a2;
        existing.collapsed_attr[attr2].add(
          // @ts-ignore: If the property is not in the object, it will be undefined
          (_a2 = edge.attr[attr2]) != null ? _a2 : "_"
        );
      });
    }
  }
  mermaid_edges.forEach(({ arrow, collapsed_attr, source_i, target_i }) => {
    const attrs = build_attrs(
      Object.fromEntries(
        Object.entries(collapsed_attr).map(([key, set]) => [
          key,
          [...set.values()].join("|")
        ])
      ),
      resolved.show_attributes
    );
    lines.push(`	${source_i} ${arrow}${attrs} ${target_i}`);
  });
  lines.push("");
  const active_note_i = resolved.active_node_id ? (_d = node_map.get(resolved.active_node_id)) == null ? void 0 : _d.i : void 0;
  if (active_note_i !== void 0) {
    lines.push(`	class ${active_note_i} BC-active-node`);
  }
  switch ((_e = resolved.click) == null ? void 0 : _e.method) {
    case "class": {
      const nodes = [...node_map.values()];
      if (nodes.length) {
        lines.push(
          `	class ${nodes.filter((n2) => n2.i !== active_note_i).map((n2) => n2.i)} internal-link`
        );
      }
      const unresolved_nodes = nodes.filter((n2) => !n2.attr.resolved);
      if (unresolved_nodes.length) {
        lines.push(
          `	class ${unresolved_nodes.map((n2) => n2.i)} is-unresolved`
        );
      }
      break;
    }
    case "href": {
      node_map.forEach((node, path) => {
        var _a2;
        lines.push(
          `	click ${node.i} "${(_a2 = resolved.click) == null ? void 0 : _a2.getter(path, node.attr)}"`
        );
      });
      break;
    }
    case "callback": {
      node_map.forEach((node) => {
        var _a2;
        lines.push(
          `	click ${node.i} call ${(_a2 = resolved.click) == null ? void 0 : _a2.callback_name}()`
        );
      });
      break;
    }
  }
  return lines.join("\n");
};
var _encode = (code) => {
  const bytes = new TextEncoder().encode(code);
  return btoa(String.fromCharCode(...bytes));
};
var to_image_link = (code) => `https://mermaid.ink/img/${_encode(code)}`;
var to_live_edit_link = (code) => {
  const state = {
    code,
    // NOTE: For some reason, having both true doesn't trigger the initial render?
    autoSync: false,
    updateDiagram: true,
    mermaid: { theme: "default" }
  };
  const encoded = _encode(JSON.stringify(state, void 0, 2));
  return `https://mermaid.live/edit#base64:${encoded}`;
};
var Mermaid = {
  from_edges,
  to_image_link,
  to_live_edit_link,
  RENDERERS: MERMAID_RENDERER,
  DIRECTIONS: MERMAID_DIRECTIONS,
  CURVE_STYLES: MERMAID_CURVE_STYLES
};

// src/utils/zod.ts
var not_string_msg = (field, received) => `Expected a string (text), but got: \`${received}\` (${typeof received}). _Try wrapping the value in quotes._
**Example**: \`${field}: "${received}"\``;
var invalid_enum_msg = (field, options, received) => `Expected one of the following options: ${quote_join(options, "`", ", or ")}, but got: \`${received}\`.
**Example**: \`${field}: ${options[0]}\``;
var not_array_msg = (field, options, received) => `This field is now expected to be a YAML list (array), but got: \`${received}\` (${typeof received}). _Try wrapping it in square brackets._
**Example**: \`${field}: [${options.slice(0, 2).join(", ")}]\`, or possibly: \`${field}: [${received}]\``;
var dynamic_enum_schema = (options, field) => z.string().superRefine((received, ctx) => {
  if (options.includes(received)) {
    return true;
  } else {
    ctx.addIssue({
      options,
      received,
      code: "invalid_enum_value",
      // NOTE: Leave the default path on _this_ object, but pass the override into the error message
      message: invalid_enum_msg(
        field != null ? field : ctx.path.join("."),
        options,
        received
      )
    });
    return false;
  }
});
var dynamic_enum_array_schema = (field, options, received) => z.array(dynamic_enum_schema(options), {
  invalid_type_error: not_array_msg(field, options, received)
});
var zod = {
  error: {
    not_string: not_string_msg,
    invalid_enum: invalid_enum_msg,
    not_array: not_array_msg
  },
  schema: {
    dynamic_enum: dynamic_enum_schema,
    dynamic_enum_array: dynamic_enum_array_schema
  }
};

// src/codeblocks/schema.ts
var FIELDS = [
  "type",
  "title",
  "start-note",
  "fields",
  "field-groups",
  "depth",
  "flat",
  "collapse",
  "merge-fields",
  "dataview-from",
  "content",
  "sort",
  "field-prefix",
  "show-attributes",
  "mermaid-direction",
  "mermaid-renderer",
  "mermaid-curve"
];
var BOOLEANS = [true, false];
var build2 = (input, data) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const field_labels = data.edge_fields.map((f) => f.label);
  const group_labels = data.field_groups.map((f) => f.label);
  return z.object({
    title: z.string({
      message: zod.error.not_string("title", input["title"])
    }).optional(),
    "start-note": z.string({
      message: zod.error.not_string(
        "start-note",
        input["start-note"]
      )
    }).optional(),
    "dataview-from": z.string({
      message: zod.error.not_string(
        "dataview-from",
        input["dataview-from"]
      )
    }).optional(),
    flat: z.boolean({
      message: zod.error.invalid_enum(
        "flat",
        BOOLEANS,
        input["flat"]
      )
    }).default(false),
    collapse: z.boolean({
      message: zod.error.invalid_enum(
        "collapse",
        BOOLEANS,
        input["collapse"]
      )
    }).default(false),
    "merge-fields": z.boolean({
      message: zod.error.invalid_enum(
        "merge-fields",
        BOOLEANS,
        input["merge-fields"]
      )
    }).default(true),
    content: z.enum(["open", "closed"], {
      message: zod.error.invalid_enum(
        "content",
        ["open", "closed"],
        input["content"]
      )
    }).optional(),
    type: z.enum(["tree", "mermaid", "markmap"], {
      message: zod.error.invalid_enum(
        "type",
        ["tree", "mermaid", "markmap"],
        input["type"]
      )
    }).default("tree"),
    "mermaid-renderer": z.enum(Mermaid.RENDERERS, {
      message: zod.error.invalid_enum(
        "mermaid-renderer",
        Mermaid.RENDERERS,
        input["mermaid-renderer"]
      )
    }).optional(),
    "mermaid-direction": z.enum(Mermaid.DIRECTIONS, {
      message: zod.error.invalid_enum(
        "mermaid-direction",
        Mermaid.DIRECTIONS,
        input["mermaid-direction"]
      )
    }).optional(),
    "mermaid-curve": z.enum(Mermaid.CURVE_STYLES, {
      message: zod.error.invalid_enum(
        "mermaid-curve",
        Mermaid.CURVE_STYLES,
        input["mermaid-curve"]
      )
    }).optional(),
    "show-attributes": z.array(z.enum(EDGE_ATTRIBUTES), {
      message: zod.error.not_array(
        "show-attributes",
        EDGE_ATTRIBUTES,
        input["show-attributes"]
      )
    }).optional(),
    fields: zod.schema.dynamic_enum_array("fields", field_labels, input["fields"]).optional(),
    "field-groups": zod.schema.dynamic_enum_array(
      "field-groups",
      group_labels,
      input["field-groups"]
    ).optional(),
    depth: z.array(
      z.number({
        invalid_type_error: `Expected a number, but got: \`${input["depth"]}\` (${typeof input["depth"]}). _Try using a number (integer)._
**Example**: \`depth: [0]\`, or \`depth: [0, 3]\``
      }).min(
        0,
        `Minimum depth cannot be less than \`0\`, but got: \`${input["depth"]}\` _Try using a non-negative number (greater than or equal to zero \`0\`)._
**Example**: \`depth: [0]\`, or possibly: \`depth: [${typeof input["depth"] === "number" ? -1 * input["depth"] : input["depth"]}\`]`
      ),
      {
        invalid_type_error: `Expected a YAML list (array) of one or two numbers, but got: \`${input["depth"]}\` (${typeof input["depth"]}).  _Try wrapping it in square brackets._
**Example**: \`depth: [0]\`, or \`depth: [0, 3]\`, or possibly: \`depth: [${input["depth"]}]\``
      }
    ).min(
      1,
      `At least one item is required, but got: \`[${input["depth"]}]\`. _Try adding a number to the list._
**Example**: \`depth: [0]\`, or \`depth: [0, 3]\``
    ).max(
      2,
      // NOTE: I _could_ do something like:
      //    or possibly \`depth: [${(<number[] | null>input["depth"])?.slice(0, 2).join(", ")}]\`
      //    But even that mess isn't safe. What if it's a string or something without join?
      `Maximum of two items allowed, but got: \`[${input["depth"]}]\`. _Try removing one of the numbers._
**Example**: \`depth: [${(_b = (_a = input["depth"]) == null ? void 0 : _a[0]) != null ? _b : 0}]\`, or possibly \`depth: [${(_d = (_c = input["depth"]) == null ? void 0 : _c[0]) != null ? _d : 0}, 3]\``
    ).transform((v) => {
      if (v.length === 1)
        return [v[0], Infinity];
      else
        return v;
    }).refine((v) => v[0] <= v[1], {
      message: `Minimum depth cannot be greater than maximum depth. _Try swapping the numbers._
**Example**: \`depth: [0, 3]\`, or possibly: \`depth: [${(_f = (_e = input["depth"]) == null ? void 0 : _e[1]) != null ? _f : 0}, ${(_h = (_g = input["depth"]) == null ? void 0 : _g[0]) != null ? _h : 3}]\``
    }).default([0, Infinity]),
    sort: z.preprocess(
      (v) => {
        if (typeof v === "string") {
          const [field, order] = v.split(" ");
          return { field, order: order != null ? order : "asc" };
        } else {
          return v;
        }
      },
      z.object({
        // TODO: Use a custom zod schema to retain string template literals here
        // https://github.com/colinhacks/zod?tab=readme-ov-file#custom-schemas
        field: zod.schema.dynamic_enum(
          [
            ...SIMPLE_EDGE_SORT_FIELDS,
            ...data.edge_fields.map(
              (f) => `neighbour-field:${f.label}`
            )
          ],
          "sort"
        ),
        order: z.union(
          [
            z.enum(["asc", "desc"]),
            // Something very weird happening...
            // If a note has two codeblocks, the one that gets rendered first seems to override config in the other?
            // So when the `sort` field of the second comes in for parsing,
            // It's already been transformed, and so sort.order is a number, not a string...
            z.literal(1),
            z.literal(-1)
          ],
          {
            // SOURCE: https://github.com/colinhacks/zod/issues/117#issuecomment-1595801389
            errorMap: (_err, ctx) => ({
              message: zod.error.invalid_enum(
                "sort.order",
                ["asc", "desc"],
                ctx.data
              )
            })
          }
        ).transform(
          (v) => v === "asc" ? 1 : v === "desc" ? -1 : v
        )
      })
    ).default({
      order: 1,
      field: "basename"
    })
  }).passthrough().default({}).transform((options) => {
    if (options["field-groups"]) {
      const field_labels2 = resolve_field_group_labels(
        data.field_groups,
        options["field-groups"]
      );
      if (options.fields) {
        options.fields = remove_duplicates(
          options.fields.concat(field_labels2)
        );
      } else {
        options.fields = field_labels2;
      }
    }
    return options;
  }).superRefine((options, ctx) => {
    if (options["mermaid-curve"] && options["mermaid-renderer"]) {
      ctx.addIssue({
        code: "custom",
        path: ["mermaid-curve"],
        message: `Cannot specify both a mermaid curve and a renderer. _Try removing one of the fields._
**Example**: \`mermaid-curve: ${options["mermaid-curve"]}\`, or \`mermaid-renderer: ${options["mermaid-renderer"]}\``
      });
      return false;
    }
    return true;
  });
};
var CodeblockSchema = {
  FIELDS,
  build: build2
};

// src/codeblocks/index.ts
var parse_source = (source, data) => {
  var _a;
  const errors = [];
  let yaml;
  try {
    yaml = (_a = (0, import_obsidian.parseYaml)(source)) != null ? _a : {};
    log.debug("Codeblock > parsed_yaml >", yaml);
  } catch (error) {
    log.error("Codeblock > parse_source > ", error);
    errors.push({
      path: "yaml",
      code: "invalid_yaml",
      message: "Invalid codeblock YAML. Check the console for more information (press `Ctrl + Shift + I` to open the console)."
    });
    return { parsed: null, errors };
  }
  const parsed = CodeblockSchema.build(yaml, data).safeParse(yaml);
  if (!parsed.success) {
    errors.push(
      ...remove_duplicates_by(
        parsed.error.issues,
        (issue) => issue.path.join(".")
      ).map((issue) => ({
        message: issue.message,
        code: "invalid_field_value",
        path: issue.path.map((key) => typeof key === "number" ? key + 1 : key).join(" > ")
      }))
    );
    return {
      errors,
      parsed: null
    };
  }
  const invalid_fields = Object.keys(parsed.data).filter(
    (key) => !CodeblockSchema.FIELDS.includes(key)
  );
  if (invalid_fields.length) {
    errors.push({
      path: "yaml",
      code: "invalid_yaml",
      message: `The following is not a valid codeblock field: \`${invalid_fields[0]}\`. Valid options are: ${quote_join(CodeblockSchema.FIELDS, "`", ", or ")}`
    });
  }
  return { parsed: parsed.data, errors };
};
var postprocess_options = (source_path, parsed, errors, plugin) => {
  var _a;
  let file_path = source_path;
  if (parsed["start-note"]) {
    const normalised = Paths.normalise(
      Paths.ensure_ext(parsed["start-note"], "md")
    );
    const start_file = plugin.app.metadataCache.getFirstLinkpathDest(
      normalised,
      file_path
    );
    if (start_file) {
      file_path = start_file.path;
    } else {
      errors.push({
        path: "start-note",
        code: "invalid_field_value",
        message: `Could not find note \`${normalised}\` in your vault. Try a different path.`
      });
    }
  }
  if (parsed["dataview-from"]) {
    try {
      const pages = (_a = dataview_plugin.get_api(plugin.app)) == null ? void 0 : _a.pages(parsed["dataview-from"]);
      parsed["dataview-from-paths"] = pages == null ? void 0 : pages.map(
        (page) => page.file.path
      );
    } catch (error) {
      errors.push({
        path: "dataview-from",
        code: "invalid_field_value",
        message: `Input \`${parsed["dataview-from"]}\` is not a valid Dataview query. 
You can use \`app.plugins.plugins.dataview.api.pages("<query>")\` to test your query in the console (press \`Ctrl + Shift + I\` to open the console).`
      });
    }
  }
  return { options: parsed, file_path };
};
var active_codeblocks = /* @__PURE__ */ new Map();
var register = (codeBlock) => {
  active_codeblocks.set(codeBlock.id, codeBlock);
};
var unregister = (codeBlock) => {
  active_codeblocks.delete(codeBlock.id);
};
var update_all = () => {
  for (const codeBlock of active_codeblocks.values()) {
    void codeBlock.update();
  }
};
var Codeblocks = {
  parse_source,
  postprocess_options,
  register,
  unregister,
  update_all
};

// src/graph/traverse.ts
var breadth_first = (graph, start_node, callback, edge_filter) => {
  const visited_edge_ids = /* @__PURE__ */ new Set();
  const stack = graph.get_out_edges(start_node).map((edge) => ({ edge, depth: 0 })).filter((item) => !edge_filter || edge_filter(item));
  while (stack.length > 0) {
    const item = stack.shift();
    if (visited_edge_ids.has(item.edge.id))
      continue;
    else
      visited_edge_ids.add(item.edge.id);
    callback(item);
    graph.get_out_edges(item.edge.target_id).map((out_edge) => ({ edge: out_edge, depth: item.depth + 1 })).filter((out_item) => !edge_filter || edge_filter(out_item)).forEach((item2) => stack.push(item2));
  }
};
var gather_items = (graph, start_node, edge_filter) => {
  const items = [];
  breadth_first(graph, start_node, (item) => items.push(item), edge_filter);
  return items;
};
var MAX_DEPTH = 100;
var build_tree = (graph, source_id, { depth, max_depth }, edge_filter, visited_edge_ids = /* @__PURE__ */ new Set()) => {
  depth != null ? depth : depth = 0;
  max_depth != null ? max_depth : max_depth = MAX_DEPTH;
  const tree = [];
  if (depth <= max_depth) {
    for (const edge of graph.get_out_edges(source_id).filter((edge2) => !edge_filter || edge_filter(edge2, depth))) {
      if (visited_edge_ids.has(edge.id))
        continue;
      else
        visited_edge_ids.add(edge.id);
      const children2 = build_tree(
        graph,
        edge.target_id,
        { depth: depth + 1, max_depth },
        edge_filter,
        visited_edge_ids
      );
      tree.push({ edge, depth, children: children2 });
    }
  }
  return tree;
};
var flatten_tree = (tree) => {
  const traversal_items = [];
  tree.forEach(({ edge, depth, children: children2 }) => {
    traversal_items.push({ edge, depth });
    traversal_items.push(...flatten_tree(children2));
  });
  return traversal_items;
};
var tree_to_all_paths = (tree) => {
  const paths = [];
  tree.forEach(({ edge, children: children2 }) => {
    if (children2.length === 0) {
      paths.push([edge]);
    } else {
      const child_paths = tree_to_all_paths(children2);
      child_paths.forEach((path) => paths.push([edge, ...path]));
    }
  });
  return paths;
};
var sort_edge_tree = (tree, sorter) => {
  tree.forEach((nested_path) => {
    nested_path.children = sort_edge_tree(nested_path.children, sorter);
  });
  return tree.sort((a, b) => sorter(a.edge, b.edge));
};
var get_transitive_chain_target_ids = (graph, start_node, chain, edge_filter) => {
  const target_ids = [];
  Traverse.breadth_first(
    graph,
    start_node,
    (item) => {
      if (item.depth === chain.length - 1) {
        target_ids.push(item.edge.target_id);
      }
    },
    (item) => (
      // Ensures we don't go over the chain length ("max_depth")
      chain[item.depth] && // Check if the edge has the attrs we're looking for
      has_edge_attrs(item.edge, chain[item.depth]) && (!edge_filter || edge_filter(item))
    )
  );
  return target_ids;
};
var Traverse = {
  breadth_first,
  gather_items,
  build_tree,
  flatten_tree,
  tree_to_all_paths,
  sort_edge_tree,
  get_transitive_chain_target_ids
};

// src/utils/links.ts
var resolve_to_absolute_path = (app, relative_path, source_path) => {
  const folder = app.fileManager.getNewFileParent(source_path, relative_path);
  return Paths.build(folder.path, Paths.basename(relative_path), "md");
};
var ify = (path, display, options) => {
  switch (options.link_kind) {
    case "none": {
      return display;
    }
    case "wiki": {
      const no_ext = Paths.drop_ext(path);
      return display === path ? `[[${no_ext}]]` : `[[${no_ext}|${display}]]`;
    }
    case "markdown": {
      return display === path ? `[${path}](${path})` : `[${display}](${path})`;
    }
  }
};
var Links = {
  ify,
  resolve_to_absolute_path
};

// src/commands/list_index/index.ts
var ListIndex;
((ListIndex2) => {
  ListIndex2.DEFAULT_OPTIONS = {
    fields: [],
    indent: "\\t",
    link_kind: "wiki",
    show_attributes: [],
    field_group_labels: [],
    edge_sort_id: {
      order: 1,
      field: "basename"
    },
    show_node_options: {
      ext: false,
      alias: true,
      folder: false
    }
  };
  ListIndex2.edge_tree_to_list_index = (tree, options) => {
    let index = "";
    const real_indent = options.indent.replace(/\\t/g, "	");
    tree.forEach(({ children: children2, depth, edge }) => {
      const display = stringify_node(edge.target_id, edge.target_attr, {
        show_node_options: options.show_node_options
      });
      const link = Links.ify(edge.target_id, display, {
        link_kind: options.link_kind
      });
      const attr2 = options.show_attributes.length ? ` (${url_search_params(
        untyped_pick(edge.attr, options.show_attributes),
        { trim_lone_param: true }
      )})` : "";
      index += real_indent.repeat(depth) + `- ${link}${attr2}
`;
      index += (0, ListIndex2.edge_tree_to_list_index)(children2, options);
    });
    return index;
  };
  ListIndex2.build = (graph, start_node, options) => (0, ListIndex2.edge_tree_to_list_index)(
    Traverse.sort_edge_tree(
      Traverse.build_tree(
        graph,
        start_node,
        options,
        (e) => has_edge_attrs(e, { $or_fields: options.fields })
      ),
      get_edge_sorter(options.edge_sort_id, graph)
    ),
    options
  );
})(ListIndex || (ListIndex = {}));

// src/const/settings.ts
var DEFAULT_EDGE_SORT_ID = { field: "basename", order: 1 };
var DEFAULT_SHOW_NODE_OPTIONS = {
  ext: false,
  folder: false,
  alias: false
};
var DEFAULT_SETTINGS = {
  is_dirty: false,
  edge_fields: [
    { label: "up" },
    { label: "down" },
    { label: "same" },
    { label: "next" },
    { label: "prev" }
  ],
  edge_field_groups: [
    {
      label: "ups",
      fields: ["up"]
    },
    {
      label: "downs",
      fields: ["down"]
    },
    {
      label: "sames",
      fields: ["same"]
    },
    {
      label: "nexts",
      fields: ["next"]
    },
    {
      label: "prevs",
      fields: ["prev"]
    }
  ],
  implied_relations: {
    transitive: [
      {
        name: "",
        rounds: 1,
        chain: [{ field: "up" }],
        close_field: "down",
        close_reversed: true
      },
      {
        name: "",
        rounds: 1,
        chain: [{ field: "down" }],
        close_field: "up",
        close_reversed: true
      },
      {
        name: "",
        rounds: 1,
        chain: [{ field: "same" }],
        close_field: "same",
        close_reversed: true
      },
      {
        name: "",
        rounds: 1,
        chain: [{ field: "next" }],
        close_field: "prev",
        close_reversed: true
      },
      {
        name: "",
        rounds: 1,
        chain: [{ field: "prev" }],
        close_field: "next",
        close_reversed: true
      }
    ]
  },
  explicit_edge_sources: {
    typed_link: {},
    list_note: {
      // Disabled by default
      default_neighbour_field: ""
    },
    tag_note: {
      default_field: "up"
    },
    regex_note: {
      default_field: "up"
    },
    dendron_note: {
      enabled: false,
      delimiter: ".",
      default_field: "up",
      display_trimmed: false
    },
    johnny_decimal_note: {
      enabled: false,
      delimiter: ".",
      default_field: "up"
    },
    date_note: {
      enabled: false,
      date_format: "yyyy-MM-dd",
      default_field: "next",
      stretch_to_existing: false
    }
  },
  views: {
    page: {
      all: {
        sticky: false,
        readable_line_width: true
      },
      trail: {
        enabled: true,
        format: "grid",
        selection: "all",
        default_depth: 999,
        no_path_message: "",
        show_controls: true,
        merge_fields: false,
        field_group_labels: ["ups"],
        show_node_options: { ...DEFAULT_SHOW_NODE_OPTIONS }
      },
      prev_next: {
        enabled: true,
        show_node_options: { ...DEFAULT_SHOW_NODE_OPTIONS },
        field_group_labels: {
          prev: ["prevs"],
          next: ["nexts"]
        }
      }
    },
    side: {
      matrix: {
        collapse: false,
        edge_sort_id: { ...DEFAULT_EDGE_SORT_ID },
        show_node_options: { ...DEFAULT_SHOW_NODE_OPTIONS },
        show_attributes: ["source", "implied_kind", "round"],
        field_group_labels: ["ups", "downs", "sames", "nexts", "prevs"]
      },
      tree: {
        collapse: false,
        show_attributes: [],
        merge_fields: false,
        field_group_labels: ["downs"],
        edge_sort_id: { ...DEFAULT_EDGE_SORT_ID },
        show_node_options: { ...DEFAULT_SHOW_NODE_OPTIONS }
      }
    },
    codeblocks: {
      show_node_options: { ...DEFAULT_SHOW_NODE_OPTIONS }
    }
  },
  commands: {
    rebuild_graph: {
      notify: true,
      trigger: {
        note_save: false,
        layout_change: false
      }
    },
    list_index: {
      default_options: ListIndex.DEFAULT_OPTIONS
    },
    freeze_implied_edges: {
      default_options: {
        destination: "frontmatter"
      }
    },
    thread: {
      default_options: {
        destination: "frontmatter",
        target_path_template: "{{source.folder}}/{{attr.field}} {{source.basename}}"
      }
    }
  },
  suggestors: {
    edge_field: {
      enabled: false,
      trigger: "."
    }
  },
  debug: {
    level: "INFO"
  }
};

// src/const/views.ts
var VIEW_IDS = {
  matrix: "bc-matrix-view",
  tree: "bc-tree-view"
};

// src/const/metadata_fields.ts
var METADATA_FIELDS_MAP = {
  "BC-tag-note-tag": {
    property_type: "text"
  },
  "BC-tag-note-field": {
    property_type: "text"
  },
  "BC-tag-note-exact": {
    property_type: "checkbox"
  },
  //
  "BC-regex-note-regex": {
    property_type: "text"
  },
  "BC-regex-note-flags": {
    property_type: "text"
  },
  "BC-regex-note-field": {
    property_type: "text"
  },
  //
  "BC-folder-note-field": {
    property_type: "text"
  },
  "BC-folder-note-recurse": {
    property_type: "checkbox"
  },
  //
  "BC-list-note-field": {
    property_type: "text"
  },
  "BC-list-note-neighbour-field": {
    property_type: "text"
  },
  "BC-list-note-exclude-index": {
    property_type: "checkbox"
  },
  //
  "BC-dendron-note-field": {
    property_type: "text"
  },
  //
  "BC-johnny-decimal-note-field": {
    property_type: "text"
  },
  //
  "BC-dataview-note-query": {
    property_type: "text"
  },
  "BC-dataview-note-field": {
    property_type: "text"
  },
  //
  "BC-ignore-in-edges": {
    property_type: "checkbox"
  },
  "BC-ignore-out-edges": {
    property_type: "checkbox"
  }
};
var META_ALIAS = {
  "tag-note-tag": "BC-tag-note-tag",
  "tag-note-field": "BC-tag-note-field",
  "tag-note-exact": "BC-tag-note-exact",
  //
  "regex-note-regex": "BC-regex-note-regex",
  "regex-note-flags": "BC-regex-note-flags",
  "regex-note-field": "BC-regex-note-field",
  //
  "folder-note-field": "BC-folder-note-field",
  "folder-note-recurse": "BC-folder-note-recurse",
  //
  "list-note-field": "BC-list-note-field",
  "list-note-neighbour-field": "BC-list-note-neighbour-field",
  "list-note-exclude-index": "BC-list-note-exclude-index",
  //
  "dendron-note-field": "BC-dendron-note-field",
  //
  "johnny-decimal-note-field": "BC-johnny-decimal-note-field",
  //
  "dataview-note-query": "BC-dataview-note-query",
  "dataview-note-field": "BC-dataview-note-field",
  //
  "ignore-in-edges": "BC-ignore-in-edges",
  "ignore-out-edges": "BC-ignore-out-edges"
};

// src/utils/timer.ts
var Timer = class {
  constructor() {
    this.start = performance.now();
  }
  elapsed() {
    return performance.now() - this.start;
  }
  elapsed_str(digits = 0) {
    return this.elapsed().toFixed(digits);
  }
  reset() {
    this.start = performance.now();
  }
  elapsedMessage(action, reset = false) {
    const msg = `${action} took ${this.elapsed_str(2)}ms`;
    if (reset)
      this.reset();
    return msg;
  }
};

// src/graph/builders/explicit/dataview_note.ts
var import_obsidian2 = require("obsidian");
var get_dataview_note_info = (plugin, metadata, path) => {
  if (!metadata) {
    return fail(void 0);
  }
  const query = metadata[META_ALIAS["dataview-note-query"]];
  if (!query) {
    return fail(void 0);
  } else if (typeof query !== "string") {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: "dataview-note-query is not a string"
    });
  }
  const field = metadata[META_ALIAS["dataview-note-field"]];
  if (!field) {
    return fail(void 0);
  } else if (typeof field !== "string") {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: "dataview-note-field is not a string"
    });
  } else if (!plugin.settings.edge_fields.find((f) => f.label === field)) {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: `dataview-note-field is not a valid field: '${field}'`
    });
  }
  return succ({
    field,
    query
  });
};
var _add_explicit_edges_dataview_note = (graph, plugin, all_files) => {
  var _a, _b;
  const errors = [];
  (_a = all_files.obsidian) == null ? void 0 : _a.forEach(
    ({ file: dataview_note_file, cache: dataview_note_cache }) => {
      if (!dataview_note_cache)
        return;
      const dataview_note_info = get_dataview_note_info(
        plugin,
        dataview_note_cache == null ? void 0 : dataview_note_cache.frontmatter,
        dataview_note_file.path
      );
      if (!dataview_note_info.ok) {
        if (dataview_note_info.error)
          errors.push(dataview_note_info.error);
        return;
      } else {
        new import_obsidian2.Notice(
          "dataview-notes are not implemented without Dataview enabled"
        );
      }
    }
  );
  (_b = all_files.dataview) == null ? void 0 : _b.forEach((dataview_note_page) => {
    const dataview_note_path = dataview_note_page.file.path;
    const dataview_note_info = get_dataview_note_info(
      plugin,
      dataview_note_page,
      dataview_note_path
    );
    if (!dataview_note_info.ok) {
      if (dataview_note_info.error)
        errors.push(dataview_note_info.error);
      return;
    }
    const { field, query } = dataview_note_info.data;
    let pages = [];
    try {
      pages = dataview_plugin.get_api().pages(query, dataview_note_path).values;
    } catch (error) {
      log.warn(
        "dataview-note > DV API error:",
        error instanceof Error ? error.message : error
      );
      return errors.push({
        code: "invalid_field_value",
        path: dataview_note_path,
        message: `dataview-note-query is not a valid dataview query: '${query}'`
      });
    }
    pages.forEach((page) => {
      graph.safe_add_directed_edge(
        dataview_note_page.file.path,
        page.file.path,
        {
          field,
          explicit: true,
          source: "dataview_note"
        }
      );
    });
  });
  return { errors };
};

// node_modules/luxon/src/errors.js
var LuxonError = class extends Error {
};
var InvalidDateTimeError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
};
var InvalidIntervalError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
};
var InvalidDurationError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
};
var ConflictingSpecificationError = class extends LuxonError {
};
var InvalidUnitError = class extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
};
var InvalidArgumentError = class extends LuxonError {
};
var ZoneIsAbstractError = class extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
};

// node_modules/luxon/src/impl/formats.js
var n = "numeric";
var s = "short";
var l = "long";
var DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
var DATE_MED = {
  year: n,
  month: s,
  day: n
};
var DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s
};
var DATE_FULL = {
  year: n,
  month: l,
  day: n
};
var DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
var TIME_SIMPLE = {
  hour: n,
  minute: n
};
var TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
var TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
var TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s
};
var TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l
};
var DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n
};
var DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s
};
var DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
var DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};

// node_modules/luxon/src/zone.js
var Zone = class {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
};

// node_modules/luxon/src/zones/systemZone.js
var singleton = null;
var SystemZone = class _SystemZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton === null) {
      singleton = new _SystemZone();
    }
    return singleton;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale);
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }
  /** @override **/
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/IANAZone.js
var dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type, value } = formatted[i];
    const pos = typeToPos[type];
    if (type === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
var ianaZoneCache = {};
var IANAZone = class _IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new _IANAZone(name);
    }
    return ianaZoneCache[name];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(s2) {
    return this.isValidZone(s2);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e) {
      return false;
    }
  }
  constructor(name) {
    super();
    this.zoneName = name;
    this.valid = _IANAZone.isValidZone(name);
  }
  /** @override **/
  get type() {
    return "iana";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  offset(ts) {
    const date = new Date(ts);
    if (isNaN(date))
      return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  /** @override **/
  get isValid() {
    return this.valid;
  }
};

// node_modules/luxon/src/impl/locale.js
var intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
var intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
var intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
var intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const { base, ...cacheKeyOpts } = opts;
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
var sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
var weekInfoCache = {};
function getCachedWeekInfo(locString) {
  let data = weekInfoCache[locString];
  if (!data) {
    const locale = new Intl.Locale(locString);
    data = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
    weekInfoCache[locString] = data;
  }
  return data;
}
function parseLocaleString(localeStr) {
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    let selectedStr;
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e) {
      const smaller = localeStr.substring(0, uIndex);
      options = getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }
    const { numberingSystem, calendar } = options;
    return [selectedStr, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2009, i, 1);
    ms.push(f(dt));
  }
  return ms;
}
function mapWeekdays(f) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
}
function listStuff(loc, length, englishFn, intlFn) {
  const mode = loc.listingMode();
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
var PolyNumberFormatter = class {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const { padTo, floor, ...otherOpts } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0)
        intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
};
var PolyDateFormatter = class {
  constructor(dt, intl, opts) {
    this.opts = opts;
    this.originalZone = void 0;
    let z2 = void 0;
    if (this.opts.timeZone) {
      this.dt = dt;
    } else if (dt.zone.type === "fixed") {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z2 = offsetZ;
        this.dt = dt;
      } else {
        z2 = "UTC";
        this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else if (dt.zone.type === "iana") {
      this.dt = dt;
      z2 = dt.zone.name;
    } else {
      z2 = "UTC";
      this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
      this.originalZone = dt.zone;
    }
    const intlOpts = { ...this.opts };
    intlOpts.timeZone = intlOpts.timeZone || z2;
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    if (this.originalZone) {
      return this.formatToParts().map(({ value }) => value).join("");
    }
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const parts = this.dtf.formatToParts(this.dt.toJSDate());
    if (this.originalZone) {
      return parts.map((part) => {
        if (part.type === "timeZoneName") {
          const offsetName = this.originalZone.offsetName(this.dt.ts, {
            locale: this.dt.locale,
            format: this.opts.timeZoneName
          });
          return {
            ...part,
            value: offsetName
          };
        } else {
          return part;
        }
      });
    }
    return parts;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
};
var PolyRelFormatter = class {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
};
var fallbackWeekSettings = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
var Locale = class _Locale {
  static fromOpts(opts) {
    return _Locale.create(
      opts.locale,
      opts.numberingSystem,
      opts.outputCalendar,
      opts.weekSettings,
      opts.defaultToEN
    );
  }
  static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
    return new _Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {
    return _Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
  }
  constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.weekSettings = weekSettings;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return _Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        validateWeekSettings(alts.weekSettings) || this.weekSettings,
        alts.defaultToEN || false
      );
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }
  months(length, format = false) {
    return listStuff(this, length, months, () => {
      const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format = false) {
    return listStuff(this, length, weekdays, () => {
      const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays(
          (dt) => this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems() {
    return listStuff(
      this,
      void 0,
      () => meridiems,
      () => {
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (dt) => this.extract(dt, intl, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(length) {
    return listStuff(this, length, eras, () => {
      const intl = { era: length };
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
          (dt) => this.extract(dt, intl, "era")
        );
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  getWeekSettings() {
    if (this.weekSettings) {
      return this.weekSettings;
    } else if (!hasLocaleWeekInfo()) {
      return fallbackWeekSettings;
    } else {
      return getCachedWeekInfo(this.locale);
    }
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
};

// node_modules/luxon/src/zones/fixedOffsetZone.js
var singleton2 = null;
var FixedOffsetZone = class _FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton2 === null) {
      singleton2 = new _FixedOffsetZone(0);
    }
    return singleton2;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset2) {
    return offset2 === 0 ? _FixedOffsetZone.utcInstance : new _FixedOffsetZone(offset2);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s2) {
    if (s2) {
      const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new _FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }
  constructor(offset2) {
    super();
    this.fixed = offset2;
  }
  /** @override **/
  get type() {
    return "fixed";
  }
  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  /** @override **/
  offsetName() {
    return this.name;
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }
  /** @override **/
  get isUniversal() {
    return true;
  }
  /** @override **/
  offset() {
    return this.fixed;
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  /** @override **/
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/invalidZone.js
var InvalidZone = class extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return false;
  }
  /** @override **/
  get isValid() {
    return false;
  }
};

// node_modules/luxon/src/impl/zoneUtil.js
function normalizeZone(input, defaultZone2) {
  let offset2;
  if (isUndefined(input) || input === null) {
    return defaultZone2;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default")
      return defaultZone2;
    else if (lowered === "local" || lowered === "system")
      return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt")
      return FixedOffsetZone.utcInstance;
    else
      return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
    return input;
  } else {
    return new InvalidZone(input);
  }
}

// node_modules/luxon/src/settings.js
var now = () => Date.now();
var defaultZone = "system";
var defaultLocale = null;
var defaultNumberingSystem = null;
var defaultOutputCalendar = null;
var twoDigitCutoffYear = 60;
var throwOnInvalid;
var defaultWeekSettings = null;
var Settings = class {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n2) {
    now = n2;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */
  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return defaultWeekSettings;
  }
  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(weekSettings) {
    defaultWeekSettings = validateWeekSettings(weekSettings);
  }
  /**
   * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }
  /**
   * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
};

// node_modules/luxon/src/impl/invalid.js
var Invalid = class {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
};

// node_modules/luxon/src/impl/conversions.js
var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid(
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
  );
}
function dayOfWeek(year, month, day) {
  const d = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  const js = d.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal), day = ordinal - table[month0];
  return { month: month0 + 1, day };
}
function isoWeekdayToLocal(isoWeekday, startOfWeek) {
  return (isoWeekday - startOfWeek + 7) % 7 + 1;
}
function gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);
  let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
  } else if (weekNumber > weeksInWeekYear(year, minDaysInFirstWeek, startOfWeek)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}
function weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(weekData) };
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return { year, ordinal, ...timeObject(gregData) };
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(ordinalData) };
}
function usesLocalWeekValues(obj, loc) {
  const hasLocaleWeekData = !isUndefined(obj.localWeekday) || !isUndefined(obj.localWeekNumber) || !isUndefined(obj.localWeekYear);
  if (hasLocaleWeekData) {
    const hasIsoWeekData = !isUndefined(obj.weekday) || !isUndefined(obj.weekNumber) || !isUndefined(obj.weekYear);
    if (hasIsoWeekData) {
      throw new ConflictingSpecificationError(
        "Cannot mix locale-based week fields with ISO-based week fields"
      );
    }
    if (!isUndefined(obj.localWeekday))
      obj.weekday = obj.localWeekday;
    if (!isUndefined(obj.localWeekNumber))
      obj.weekNumber = obj.localWeekNumber;
    if (!isUndefined(obj.localWeekYear))
      obj.weekYear = obj.localWeekYear;
    delete obj.localWeekday;
    delete obj.localWeekNumber;
    delete obj.localWeekYear;
    return {
      minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
      startOfWeek: loc.getStartOfWeek()
    };
  } else {
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
  }
}
function hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(
    obj.weekNumber,
    1,
    weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)
  ), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.weekNumber);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else
    return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else
    return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else
    return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else
    return false;
}

// node_modules/luxon/src/impl/util.js
function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}
function hasLocaleWeekInfo() {
  try {
    return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch (e) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return void 0;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function validateWeekSettings(settings) {
  if (settings == null) {
    return null;
  } else if (typeof settings !== "object") {
    throw new InvalidArgumentError("Week settings must be an object");
  } else {
    if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v) => !integerBetween(v, 1, 7))) {
      throw new InvalidArgumentError("Invalid week settings");
    }
    return {
      firstDay: settings.firstDay,
      minimalDays: settings.minimalDays,
      weekend: Array.from(settings.weekend)
    };
  }
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x, n2) {
  return x - n2 * Math.floor(x / n2);
}
function padStart(input, n2 = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n2, "0");
  } else {
    padded = ("" + input).padStart(n2, "0");
  }
  return padded;
}
function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseInt(string, 10);
  }
}
function parseFloating(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseFloat(string);
  }
}
function parseMillis(fraction) {
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f);
  }
}
function roundTo(number, digits, towardZero = false) {
  const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
  }
  return +d;
}
function firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {
  const fwdlw = isoWeekdayToLocal(dayOfWeek(year, 1, minDaysInFirstWeek), startOfWeek);
  return -fwdlw + minDaysInFirstWeek - 1;
}
function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
  const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
  return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else
    return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = { timeZoneName: offsetFormat, ...intlOpts };
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty(obj, u)) {
      const v = obj[u];
      if (v === void 0 || v === null)
        continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}
function formatOffset(offset2, format) {
  const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}

// node_modules/luxon/src/impl/english.js
var monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
var weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
var meridiems = ["AM", "PM"];
var erasLong = ["Before Christ", "Anno Domini"];
var erasShort = ["BC", "AD"];
var erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
      default:
    }
  }
  const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}

// node_modules/luxon/src/impl/formatter.js
function stringifyTokens(splits, tokenToString) {
  let s2 = "";
  for (const token of splits) {
    if (token.literal) {
      s2 += token.val;
    } else {
      s2 += tokenToString(token.val);
    }
  }
  return s2;
}
var macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
var Formatter = class _Formatter {
  static create(locale, opts = {}) {
    return new _Formatter(locale, opts);
  }
  static parseFormat(fmt) {
    let current = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
        }
        currentFull = c;
        current = c;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  dtFormatter(dt, opts = {}) {
    return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
  }
  formatDateTime(dt, opts) {
    return this.dtFormatter(dt, opts).format();
  }
  formatDateTimeParts(dt, opts) {
    return this.dtFormatter(dt, opts).formatToParts();
  }
  formatInterval(interval, opts) {
    const df = this.dtFormatter(interval.start, opts);
    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }
  resolvedOptions(dt, opts) {
    return this.dtFormatter(dt, opts).resolvedOptions();
  }
  num(n2, p = 0) {
    if (this.opts.forceSimple) {
      return padStart(n2, p);
    }
    const opts = { ...this.opts };
    if (p > 0) {
      opts.padTo = p;
    }
    return this.loc.numberFormatter(opts).format(n2);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(
      standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
      "weekday"
    ), maybeMacro = (token) => {
      const formatOpts = _Formatter.macroTokenToFormatOpts(token);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
      switch (token) {
        case "S":
          return this.num(dt.millisecond);
        case "u":
        case "SSS":
          return this.num(dt.millisecond, 3);
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return dt.zoneName;
        case "a":
          return meridiem();
        case "d":
          return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        case "L":
          return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        case "M":
          return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        case "y":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "n":
          return this.num(dt.localWeekNumber);
        case "nn":
          return this.num(dt.localWeekNumber, 2);
        case "ii":
          return this.num(dt.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(dt.localWeekYear, 4);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1e3));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token);
      }
    };
    return stringifyTokens(_Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
      switch (token[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, tokenToString = (lildur) => (token) => {
      const mapped = tokenToField(token);
      if (mapped) {
        return this.num(lildur.get(mapped), token.length);
      } else {
        return token;
      }
    }, tokens = _Formatter.parseFormat(fmt), realTokens = tokens.reduce(
      (found, { literal, val }) => literal ? found : found.concat(val),
      []
    ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
};

// node_modules/luxon/src/impl/regexParser.js
var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m) => extractors.reduce(
    ([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next] = ex(m, cursor);
      return [{ ...mergedVals, ...val }, zone || mergedZone, next];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function parse(s2, ...patterns) {
  if (s2 == null) {
    return [null, null];
  }
  for (const [regex2, extractor] of patterns) {
    const m = regex2.exec(s2);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}
function simpleParse(...keys) {
  return (match2, cursor) => {
    const ret = {};
    let i;
    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match2[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}
var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
var extractISOOrdinalData = simpleParse("year", "ordinal");
var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
var sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match2, pos, fallback) {
  const m = match2[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}
function extractISOYmd(match2, cursor) {
  const item = {
    year: int(match2, cursor),
    month: int(match2, cursor + 1, 1),
    day: int(match2, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match2, cursor) {
  const item = {
    hours: int(match2, cursor, 0),
    minutes: int(match2, cursor + 1, 0),
    seconds: int(match2, cursor + 2, 0),
    milliseconds: parseMillis(match2[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match2, cursor) {
  const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match2, cursor) {
  const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
  return [{}, zone, cursor + 1];
}
var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match2) {
  const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
  const hasNegativePrefix = s2[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
var obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr)
    result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match2) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset2;
  if (obsOffset) {
    offset2 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset2 = 0;
  } else {
    offset2 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset2)];
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match2) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match2) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseISODate(s2) {
  return parse(
    s2,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}
function parseRFC2822Date(s2) {
  return parse(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s2) {
  return parse(
    s2,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}
function parseISODuration(s2) {
  return parse(s2, [isoDuration, extractISODuration]);
}
var extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s2) {
  return parse(s2, [isoTimeOnly, extractISOTimeOnly]);
}
var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseSQL(s2) {
  return parse(
    s2,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}

// node_modules/luxon/src/duration.js
var INVALID2 = "Invalid Duration";
var lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
};
var casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var daysInYearAccurate = 146097 / 400;
var daysInMonthAccurate = 146097 / 4800;
var accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var orderedUnits = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
var reverseUnits = orderedUnits.slice(0).reverse();
function clone(dur, alts, clear = false) {
  const conf = {
    values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function durationToMillis(matrix, vals) {
  var _a;
  let sum = (_a = vals.milliseconds) != null ? _a : 0;
  for (const unit of reverseUnits.slice(1)) {
    if (vals[unit]) {
      sum += vals[unit] * matrix[unit]["milliseconds"];
    }
  }
  return sum;
}
function normalizeValues(matrix, vals) {
  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
  orderedUnits.reduceRight((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const previousVal = vals[previous] * factor;
        const conv = matrix[current][previous];
        const rollUp = Math.floor(previousVal / conv);
        vals[current] += rollUp * factor;
        vals[previous] -= rollUp * conv * factor;
      }
      return current;
    } else {
      return previous;
    }
  }, null);
  orderedUnits.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const fraction = vals[previous] % 1;
        vals[previous] -= fraction;
        vals[current] += fraction * matrix[previous][current];
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}
var Duration = class _Duration {
  /**
   * @private
   */
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config.matrix) {
      matrix = config.matrix;
    }
    this.values = config.values;
    this.loc = config.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config.invalid || null;
    this.matrix = matrix;
    this.isLuxonDuration = true;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count, opts) {
    return _Duration.fromObject({ milliseconds: count }, opts);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
      );
    }
    return new _Duration({
      values: normalizeObject(obj, _Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return _Duration.fromMillis(durationLike);
    } else if (_Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return _Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text2, opts) {
    const [parsed] = parseISODuration(text2);
    if (parsed) {
      return _Duration.fromObject(parsed, opts);
    } else {
      return _Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text2, opts) {
    const [parsed] = parseISOTimeOnly(text2);
    if (parsed) {
      return _Duration.fromObject(parsed, opts);
    } else {
      return _Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new _Duration({ invalid });
    }
  }
  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized)
      throw new InvalidUnitError(unit);
    return normalized;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o) {
    return o && o.isLuxonDuration || false;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID2;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(opts = {}) {
    if (!this.isValid)
      return INVALID2;
    const l2 = orderedUnits.map((unit) => {
      const val = this.values[unit];
      if (isUndefined(val)) {
        return null;
      }
      return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
    }).filter((n2) => n2);
    return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid)
      return {};
    return { ...this.values };
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid)
      return null;
    let s2 = "P";
    if (this.years !== 0)
      s2 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0)
      s2 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0)
      s2 += this.weeks + "W";
    if (this.days !== 0)
      s2 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s2 += "T";
    if (this.hours !== 0)
      s2 += this.hours + "H";
    if (this.minutes !== 0)
      s2 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s2 === "P")
      s2 += "T0S";
    return s2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid)
      return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5)
      return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts,
      includeOffset: false
    };
    const dateTime = DateTime.fromMillis(millis, { zone: "UTC" });
    return dateTime.toISOTime(opts);
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Duration { values: ${JSON.stringify(this.values)} }`;
    } else {
      return `Duration { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    if (!this.isValid)
      return NaN;
    return durationToMillis(this.matrix, this.values);
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = _Duration.fromDurationLike(duration), result = {};
    for (const k of orderedUnits) {
      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }
    return clone(this, { values: result }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = _Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn) {
    if (!this.isValid)
      return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn(this.values[k], k));
    }
    return clone(this, { values: result }, true);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[_Duration.normalizeUnit(unit)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid)
      return this;
    const mixed = { ...this.values, ...normalizeObject(values, _Duration.normalizeUnit) };
    return clone(this, { values: mixed });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone(this, opts);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid)
      return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone(this, { values: vals }, true);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid)
      return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone(this, { values: vals }, true);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid)
      return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u) => _Duration.normalizeUnit(u));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber(vals[k])) {
          own += vals[k];
        }
        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    normalizeValues(this.matrix, built);
    return clone(this, { values: built }, true);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    if (!this.isValid)
      return this;
    return this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    );
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid)
      return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone(this, { values: negated }, true);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v2) {
      if (v1 === void 0 || v1 === 0)
        return v2 === void 0 || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/luxon/src/interval.js
var INVALID3 = "Invalid Interval";
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
    );
  } else {
    return null;
  }
}
var Interval = class _Interval {
  /**
   * @private
   */
  constructor(config) {
    this.s = config.start;
    this.e = config.end;
    this.invalid = config.invalid || null;
    this.isLuxonInterval = true;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new _Interval({ invalid });
    }
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new _Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
    return _Interval.fromDateTimes(dt, dt.plus(dur));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
    return _Interval.fromDateTimes(dt.minus(dur), dt);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text2, opts) {
    const [s2, e] = (text2 || "").split("/", 2);
    if (s2 && e) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s2, opts);
        startIsValid = start.isValid;
      } catch (e2) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e2) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return _Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e, opts);
        if (dur.isValid) {
          return _Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s2, opts);
        if (dur.isValid) {
          return _Interval.before(end, dur);
        }
      }
    }
    return _Interval.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o) {
    return o && o.isLuxonInterval || false;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count(unit = "milliseconds", opts) {
    if (!this.isValid)
      return NaN;
    const start = this.start.startOf(unit, opts);
    let end;
    if (opts == null ? void 0 : opts.useLocaleWeeks) {
      end = this.end.reconfigure({ locale: start.locale });
    } else {
      end = this.end;
    }
    end = end.startOf(unit, opts);
    return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid)
      return false;
    return this.s > dateTime;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid)
      return false;
    return this.e <= dateTime;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid)
      return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start, end } = {}) {
    if (!this.isValid)
      return this;
    return _Interval.fromDateTimes(start || this.s, end || this.e);
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid)
      return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort((a, b) => a.toMillis() - b.toMillis()), results = [];
    let { s: s2 } = this, i = 0;
    while (s2 < this.e) {
      const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
      results.push(_Interval.fromDateTimes(s2, next));
      s2 = next;
      i += 1;
    }
    return results;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s2 } = this, idx = 1, next;
    const results = [];
    while (s2 < this.e) {
      const added = this.start.plus(dur.mapUnits((x) => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(_Interval.fromDateTimes(s2, next));
      s2 = next;
      idx += 1;
    }
    return results;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid)
      return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid)
      return false;
    return +this.e === +other.s;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid)
      return false;
    return +other.e === +this.s;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid)
      return false;
    return this.s <= other.s && this.e >= other.e;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
    if (s2 >= e) {
      return null;
    } else {
      return _Interval.fromDateTimes(s2, e);
    }
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
    return _Interval.fromDateTimes(s2, e);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(
      ([sofar, current], item) => {
        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      },
      [[], null]
    );
    if (final) {
      found.push(final);
    }
    return found;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start = null, currentCount = 0;
    const results = [], ends = intervals.map((i) => [
      { time: i.s, type: "s" },
      { time: i.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(_Interval.fromDateTimes(start, i.time));
        }
        start = null;
      }
    }
    return _Interval.merge(results);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return _Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid)
      return INVALID3;
    return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
  }
  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
    } else {
      return `Interval { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID3;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid)
      return INVALID3;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid)
      return INVALID3;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid)
      return INVALID3;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(dateFormat, { separator = " \u2013 " } = {}) {
    if (!this.isValid)
      return INVALID3;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return _Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
};

// node_modules/luxon/src/info.js
var Info = class {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getStartOfWeek();
  }
  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getMinDaysInFirstWeek();
  }
  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getWeekendDays().slice();
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras(length = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return { relative: hasRelative(), localeWeek: hasLocaleWeekInfo() };
  }
};

// node_modules/luxon/src/impl/diff.js
function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a, b) => b.year - a.year],
    ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
    ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
    [
      "weeks",
      (a, b) => {
        const days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  const earlier = cursor;
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      results[unit] = differ(cursor, later);
      highWater = earlier.plus(results);
      if (highWater > later) {
        results[unit]--;
        cursor = earlier.plus(results);
        if (cursor > later) {
          highWater = cursor;
          results[unit]--;
          cursor = earlier.plus(results);
        }
      } else {
        cursor = highWater;
      }
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff_default(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(
    (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
  );
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}

// node_modules/luxon/src/impl/digits.js
var numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
var numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex({ numberingSystem }, append2 = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append2}`);
}

// node_modules/luxon/src/impl/tokenParser.js
var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex2, post = (i) => i) {
  return { regex: regex2, deser: ([s2]) => post(parseDigits(s2)) };
}
var NBSP = String.fromCharCode(160);
var spaceOrNBSP = `[ ${NBSP}]`;
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s2) {
  return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s2) {
  return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
    };
  }
}
function offset(regex2, groups) {
  return { regex: regex2, deser: ([, h, m]) => signedOffset(h, m), groups };
}
function simple(regex2) {
  return { regex: regex2, deser: ([s2]) => s2 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s2]) => s2, literal: true }), unitate = (t) => {
    if (token.literal) {
      return literal(t);
    }
    switch (t.val) {
      case "G":
        return oneOf(loc.eras("short"), 0);
      case "GG":
        return oneOf(loc.eras("long"), 0);
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true), 1);
      case "MMMM":
        return oneOf(loc.months("long", true), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false), 1);
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one);
      case "a":
        return oneOf(loc.meridiems(), 0);
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      case "E":
      case "c":
        return intUnit(one);
      case "EEE":
        return oneOf(loc.weekdays("short", false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true), 1);
      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      case " ":
        return simple(/[^\S\n\r]/);
      default:
        return literal(t);
    }
  };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}
var partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, formatOpts, resolvedOpts) {
  const { type, value } = part;
  if (type === "literal") {
    const isSpace = /^\s+$/.test(value);
    return {
      literal: !isSpace,
      val: isSpace ? " " : value
    };
  }
  const style = formatOpts[type];
  let actualType = type;
  if (type === "hour") {
    if (formatOpts.hour12 != null) {
      actualType = formatOpts.hour12 ? "hour12" : "hour24";
    } else if (formatOpts.hourCycle != null) {
      if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
        actualType = "hour12";
      } else {
        actualType = "hour24";
      }
    } else {
      actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
    }
  }
  let val = partTypeStyleToTokenVal[actualType];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}$`, units];
}
function match(input, regex2, handlers) {
  const matches = input.match(regex2);
  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty(handlers, i)) {
        const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }
    return r;
  }, {});
  return [vals, zone, specificOffset];
}
var dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);
  if (tokens == null || tokens.includes(void 0)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
}
function explainFromTokens(locale, input, format) {
  const tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map((t) => unitForToken(t, locale)), disqualifyingUnit = units.find((t) => t.invalidReason);
  if (disqualifyingUnit) {
    return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
  } else {
    const [regexString, handlers] = buildRegex(units), regex2 = RegExp(regexString, "i"), [rawMatches, matches] = match(input, regex2, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
    if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
      throw new ConflictingSpecificationError(
        "Can't include meridiem when specifying 24-hour format"
      );
    }
    return { input, tokens, regex: regex2, rawMatches, matches, result, zone, specificOffset };
  }
}
function parseFromTokens(locale, input, format) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const df = formatter.dtFormatter(getDummyDateTime());
  const parts = df.formatToParts();
  const resolvedOpts = df.resolvedOptions();
  return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));
}

// node_modules/luxon/src/datetime.js
var INVALID4 = "Invalid DateTime";
var MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function possiblyCachedLocalWeekData(dt) {
  if (dt.localWeekData === null) {
    dt.localWeekData = gregorianToWeek(
      dt.c,
      dt.loc.getMinDaysInFirstWeek(),
      dt.loc.getStartOfWeek()
    );
  }
  return dt.localWeekData;
}
function clone2(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({ ...current, ...alts, old: current });
}
function fixOffset(localTS, o, tz) {
  let utcGuess = localTS - o * 60 * 1e3;
  const o2 = tz.offset(utcGuess);
  if (o === o2) {
    return [utcGuess, o];
  }
  utcGuess -= (o2 - o) * 60 * 1e3;
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }
  return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
}
function tsToObj(ts, offset2) {
  ts += offset2 * 60 * 1e3;
  const d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
}
function objToTS(obj, offset2, zone) {
  return fixOffset(objToLocalTS(obj), offset2, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
    ...inst.c,
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }, millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o = inst.zone.offset(ts);
  }
  return { ts, o };
}
function parseDataToDateTime(parsed, parsedZone, opts, format, text2, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
      ...opts,
      zone: interpretationZone,
      specificOffset
    });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${text2}" can't be parsed as ${format}`)
    );
  }
}
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
}
function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0)
    c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);
  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    c += "-";
    c += padStart(o.c.day);
  } else {
    c += padStart(o.c.month);
    c += padStart(o.c.day);
  }
  return c;
}
function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c = padStart(o.c.hour);
  if (extended) {
    c += ":";
    c += padStart(o.c.minute);
    if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += padStart(o.c.minute);
  }
  if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
    c += padStart(o.c.second);
    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += padStart(o.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }
  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
}
var defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized)
    throw new InvalidUnitError(unit);
  return normalized;
}
function normalizeUnitWithLocalWeeks(unit) {
  switch (unit.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return normalizeUnit(unit);
  }
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
  let ts, o;
  if (!isUndefined(obj.year)) {
    for (const u of orderedUnits2) {
      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = zone.offset(tsNow);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }
  return new DateTime({ ts, zone, loc, o });
}
function diffRelative(start, end, opts) {
  const round = isUndefined(opts.round) ? true : opts.round, format = (c, unit) => {
    c = roundTo(c, round || opts.calendary ? 0 : 2, true);
    const formatter = end.loc.clone(opts).relFormatter(opts);
    return formatter.format(c, unit);
  }, differ = (unit) => {
    if (opts.calendary) {
      if (!end.hasSame(start, unit)) {
        return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
      } else
        return 0;
    } else {
      return end.diff(start, unit).get(unit);
    }
  };
  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
var DateTime = class _DateTime {
  /**
   * @access private
   */
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;
    let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    let c = null, o = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config.loc || Locale.create();
    this.invalid = invalid;
    this.weekData = null;
    this.localWeekData = null;
    this.c = c;
    this.o = o;
    this.isLuxonDateTime = true;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new _DateTime({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date, options = {}) {
    const ts = isDate(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return _DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return _DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new _DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return _DateTime.invalid("Timestamp out of range");
    } else {
      return new _DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new _DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return _DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const loc = Locale.fromObject(opts);
    const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, loc);
    const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits2;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return _DateTime.invalid(invalid);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new _DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return _DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }
    return inst;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text2, opts = {}) {
    const [vals, parsedZone] = parseISODate(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text2);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text2, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text2);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text2, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text2, fmt, opts = {}) {
    if (isUndefined(text2) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text2, fmt);
    if (invalid) {
      return _DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text2, specificOffset);
    }
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text2, fmt, opts = {}) {
    return _DateTime.fromFormat(text2, fmt, opts);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text2, opts = {}) {
    const [vals, parsedZone] = parseSQL(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text2);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new _DateTime({ invalid });
    }
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map((t) => t.val).join("");
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
  }
  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed) {
      return [this];
    }
    const dayMs = 864e5;
    const minuteMs = 6e4;
    const localTS = objToLocalTS(this.c);
    const oEarlier = this.zone.offset(localTS - dayMs);
    const oLater = this.zone.offset(localTS + dayMs);
    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
    const o2 = this.zone.offset(localTS - oLater * minuteMs);
    if (o1 === o2) {
      return [this];
    }
    const ts1 = localTS - o1 * minuteMs;
    const ts2 = localTS - o2 * minuteMs;
    const c1 = tsToObj(ts1, o1);
    const c2 = tsToObj(ts2, o2);
    if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
      return [clone2(this, { ts: ts1 }), clone2(this, { ts: ts2 })];
    }
    return [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? weeksInWeekYear(
      this.localWeekYear,
      this.loc.getMinDaysInFirstWeek(),
      this.loc.getStartOfWeek()
    ) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset2 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset2), opts);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return _DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone2(this, { ts: newTS, zone });
    }
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone2(this, { loc });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({ locale });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values) {
    if (!this.isValid)
      return this;
    const normalized = normalizeObject(values, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, this.loc);
    const settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian(
        { ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek), ...normalized },
        minDaysInFirstWeek,
        startOfWeek
      );
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone2(this, { ts, o });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration);
    return clone2(this, adjustTime(this, dur));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return clone2(this, adjustTime(this, dur));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit, { useLocaleWeeks = false } = {}) {
    if (!this.isValid)
      return this;
    const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      case "quarters":
      case "months":
        o.day = 1;
      case "weeks":
      case "days":
        o.hour = 0;
      case "hours":
        o.minute = 0;
      case "minutes":
        o.second = 0;
      case "seconds":
        o.millisecond = 0;
        break;
      case "milliseconds":
        break;
    }
    if (normalizedUnit === "weeks") {
      if (useLocaleWeeks) {
        const startOfWeek = this.loc.getStartOfWeek();
        const { weekday } = this;
        if (weekday < startOfWeek) {
          o.weekNumber = this.weekNumber - 1;
        }
        o.weekday = startOfWeek;
      } else {
        o.weekday = 1;
      }
    }
    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }
    return this.set(o);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit, opts) {
    return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit, opts).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID4;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID4;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format === "extended";
    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format === "extended");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c = includePrefix ? "T" : "";
    return c + toISOTime(
      this,
      format === "extended",
      suppressSeconds,
      suppressMilliseconds,
      includeOffset,
      extendedZone
    );
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID4;
  }
  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
    } else {
      return `DateTime { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid)
      return {};
    const base = { ...this.c };
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
    const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff_default(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(_DateTime.now(), unit, opts);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit, opts) {
    if (!this.isValid)
      return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options = {}) {
    if (!this.isValid)
      return null;
    const base = options.base || _DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = void 0;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options = {}) {
    if (!this.isValid)
      return null;
    return diffRelative(options.base || _DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(_DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(_DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text2, fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text2, fmt);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text2, fmt, options = {}) {
    return _DateTime.fromFormatExplain(text2, fmt, options);
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
};
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}

// src/graph/builders/explicit/date_note.ts
var _add_explicit_edges_date_note = (graph, plugin, all_files) => {
  var _a, _b;
  const errors = [];
  const date_note_settings = plugin.settings.explicit_edge_sources.date_note;
  if (!date_note_settings.enabled)
    return { errors };
  else if (!plugin.settings.edge_fields.find(
    (field) => field.label === date_note_settings.default_field
  )) {
    errors.push({
      code: "invalid_setting_value",
      path: "explicit_edge_sources.date_note.default_field",
      message: `The default Date Note field "${date_note_settings.default_field}" is not a valid Breadcrumbs Edge field`
    });
    return { errors };
  }
  const date_notes = [];
  (_a = all_files.obsidian) == null ? void 0 : _a.forEach(({ file }) => {
    var _a2, _b2;
    const date = DateTime.fromFormat(
      file.basename,
      date_note_settings.date_format
    );
    if (!date.isValid)
      return;
    date_notes.push({
      date,
      path: file.path,
      ext: file.extension,
      basename: file.basename,
      // Not sure why would this be undefined?
      //   I tested and a file in the root of the vault still has a parent
      //   _it's_ parent is null, but that only happens if "file" is actually a folder
      folder: (_b2 = (_a2 = file.parent) == null ? void 0 : _a2.path) != null ? _b2 : ""
    });
  });
  (_b = all_files.dataview) == null ? void 0 : _b.forEach(({ file }) => {
    const date = DateTime.fromFormat(
      file.name,
      date_note_settings.date_format
    );
    if (!date.isValid)
      return;
    date_notes.push({
      date,
      ext: file.ext,
      path: file.path,
      folder: file.folder,
      basename: file.name
    });
  });
  date_notes.sort((a, b) => a.date.toMillis() - b.date.toMillis()).forEach((date_note, i) => {
    var _a2, _b2;
    const basename_plus_one_day = date_note.date.plus({ days: 1 }).toFormat(date_note_settings.date_format);
    const target_basename = date_note_settings.stretch_to_existing ? (_b2 = (_a2 = date_notes.at(i + 1)) == null ? void 0 : _a2.basename) != null ? _b2 : basename_plus_one_day : basename_plus_one_day;
    const target_path = Paths.build(
      date_note.folder,
      target_basename,
      date_note.ext
    );
    const target_file = plugin.app.vault.getFileByPath(target_path);
    if (!target_file) {
      graph.safe_add_node(target_path, { resolved: false });
    }
    graph.safe_add_directed_edge(date_note.path, target_path, {
      explicit: true,
      source: "date_note",
      field: date_note_settings.default_field
    });
  });
  return { errors };
};

// src/graph/builders/explicit/dendron_note.ts
var get_dendron_note_info = (plugin, metadata, path) => {
  var _a;
  const field = (_a = metadata == null ? void 0 : metadata[META_ALIAS["dendron-note-field"]]) != null ? _a : (
    //   Which is why we have a default_field on dendron_note
    plugin.settings.explicit_edge_sources.dendron_note.default_field
  );
  if (!field) {
    return fail(void 0);
  } else if (typeof field !== "string") {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: `dendron-note-field is not a string: '${field}'`
    });
  } else if (!plugin.settings.edge_fields.find((f) => f.label === field)) {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: `dendron-note-field is not a valid field: '${field}'`
    });
  }
  return succ({ field });
};
var handle_dendron_note = (plugin, graph, source_path, source_metadata, errors) => {
  const { delimiter } = plugin.settings.explicit_edge_sources.dendron_note;
  const source_basename_splits = Paths.basename(source_path).split(delimiter);
  if (source_basename_splits.length === 1)
    return;
  const dendron_note_info = get_dendron_note_info(
    plugin,
    source_metadata,
    source_path
  );
  if (!dendron_note_info.ok) {
    if (dendron_note_info.error) {
      errors.push(dendron_note_info.error);
    }
    return;
  }
  const target_path = Paths.build(
    // Use the same folder as the source
    source_path.split("/").slice(0, -1).join("/"),
    // Go one note up
    source_basename_splits.slice(0, -1).join(delimiter),
    "md"
  );
  const { field } = dendron_note_info.data;
  const target_file = plugin.app.vault.getFileByPath(target_path);
  if (!target_file) {
    graph.safe_add_node(target_path, { resolved: false });
    handle_dendron_note(
      plugin,
      graph,
      target_path,
      // This is really quite elegant :)
      //   The unresolved note has no BC-dendron field, by definition
      //   Passing undefined would just use the settings.default field
      //   But we can propagate the field from the resolved source note
      { [META_ALIAS["dendron-note-field"]]: field },
      errors
    );
  }
  graph.safe_add_directed_edge(source_path, target_path, {
    field,
    explicit: true,
    source: "dendron_note"
  });
};
var _add_explicit_edges_dendron_note = (graph, plugin, all_files) => {
  var _a, _b;
  const errors = [];
  if (!plugin.settings.explicit_edge_sources.dendron_note.enabled) {
    return { errors };
  }
  (_a = all_files.obsidian) == null ? void 0 : _a.forEach(({ file, cache }) => {
    handle_dendron_note(
      plugin,
      graph,
      file.path,
      cache == null ? void 0 : cache.frontmatter,
      errors
    );
  });
  (_b = all_files.dataview) == null ? void 0 : _b.forEach((page) => {
    handle_dendron_note(plugin, graph, page.file.path, page, errors);
  });
  return { errors };
};

// src/graph/builders/explicit/folder_note.ts
var get_folder_note_info = (plugin, metadata, path) => {
  if (!metadata)
    return fail(void 0);
  const field = metadata[META_ALIAS["folder-note-field"]];
  if (!field) {
    return fail(void 0);
  } else if (typeof field !== "string") {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: `folder-note-field is not a string: '${field}'`
    });
  } else if (!plugin.settings.edge_fields.find((f) => f.label === field)) {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: `folder-note-field is not a valid field: '${field}'`
    });
  }
  const recurse = Boolean(metadata[META_ALIAS["folder-note-recurse"]]);
  return succ({
    field,
    recurse
  });
};
var iterate_folder_files = async (plugin, folder, cb, recurse) => {
  const folder_files = await plugin.app.vault.adapter.list(folder);
  folder_files.files.forEach((path) => cb(path));
  if (recurse) {
    await Promise.all(
      folder_files.folders.map(
        (folder2) => (
          // When the subfolder is recursed, what does it mean when the callback runs?
          // Where will it point up to? The initial folder's files point up to the folder_note
          // But the subfolders don't specify a folder_note
          // NOTE: For now, the subfiles will point up to the initial folder_note
          iterate_folder_files(plugin, folder2, cb, true)
        )
      )
    );
  }
};
var _add_explicit_edges_folder_note = async (graph, plugin, all_files) => {
  var _a, _b;
  const errors = [];
  const folder_notes = [];
  (_a = all_files.obsidian) == null ? void 0 : _a.forEach(
    ({ file: folder_note_file, cache: folder_note_cache }) => {
      var _a2, _b2;
      if (!folder_note_cache)
        return;
      const folder_note_info = get_folder_note_info(
        plugin,
        folder_note_cache == null ? void 0 : folder_note_cache.frontmatter,
        folder_note_file.path
      );
      if (!folder_note_info.ok) {
        if (folder_note_info.error)
          errors.push(folder_note_info.error);
        return;
      }
      folder_notes.push({
        data: folder_note_info.data,
        file: {
          path: folder_note_file.path,
          folder: (_b2 = (_a2 = folder_note_file.parent) == null ? void 0 : _a2.path) != null ? _b2 : ""
        }
      });
    }
  );
  (_b = all_files.dataview) == null ? void 0 : _b.forEach((folder_note_page) => {
    const folder_note_info = get_folder_note_info(
      plugin,
      folder_note_page,
      folder_note_page.file.path
    );
    if (!folder_note_info.ok) {
      if (folder_note_info.error)
        errors.push(folder_note_info.error);
      return;
    }
    folder_notes.push({
      data: folder_note_info.data,
      file: {
        path: folder_note_page.file.path,
        folder: folder_note_page.file.folder
      }
    });
  });
  await Promise.all(
    folder_notes.map(
      ({ data, file: folder_note }) => iterate_folder_files(
        plugin,
        folder_note.folder,
        (target_path) => {
          if (!target_path.endsWith(".md") || target_path === folder_note.path)
            return;
          graph.safe_add_directed_edge(
            folder_note.path,
            target_path,
            {
              explicit: true,
              field: data.field,
              source: "folder_note"
            }
          );
        },
        data.recurse
      )
    )
  );
  return { errors };
};

// src/graph/builders/explicit/johnny_decimal_note.ts
var get_johnny_decimal_note_info = (plugin, metadata, path) => {
  var _a;
  const field = (_a = metadata == null ? void 0 : metadata[META_ALIAS["johnny-decimal-note-field"]]) != null ? _a : (
    //   Which is why we have a default_field on johnny_decimal_note
    plugin.settings.explicit_edge_sources.johnny_decimal_note.default_field
  );
  if (!field) {
    return fail(void 0);
  } else if (typeof field !== "string") {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: `johnny-decimal-note-field is not a string: '${field}'`
    });
  } else if (!plugin.settings.edge_fields.find((f) => f.label === field)) {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: `johnny-decimal-note-field is not a valid BC field: '${field}'`
    });
  }
  return succ({ field });
};
var handle_johnny_decimal_note = (plugin, graph, source_note, notes, errors) => {
  const johnny_decimal_note_info = get_johnny_decimal_note_info(
    plugin,
    source_note.metadata,
    source_note.path
  );
  if (!johnny_decimal_note_info.ok) {
    if (johnny_decimal_note_info.error) {
      errors.push(johnny_decimal_note_info.error);
    }
    return;
  }
  const { delimiter } = plugin.settings.explicit_edge_sources.johnny_decimal_note;
  const target_decimals = source_note.decimals.split(delimiter).slice(0, -1).join(delimiter);
  if (target_decimals === "")
    return;
  const target_note = notes.find((n2) => n2.decimals === target_decimals);
  if (!target_note)
    return;
  const target_file = plugin.app.vault.getFileByPath(target_note.path);
  if (!target_file) {
    graph.safe_add_node(target_note.path, { resolved: false });
  }
  const { field } = johnny_decimal_note_info.data;
  graph.safe_add_directed_edge(source_note.path, target_note.path, {
    field,
    explicit: true,
    source: "johnny_decimal_note"
  });
};
var _add_explicit_edges_johnny_decimal_note = (graph, plugin, all_files) => {
  var _a, _b;
  const errors = [];
  if (!plugin.settings.explicit_edge_sources.johnny_decimal_note.enabled) {
    return { errors };
  }
  const { delimiter } = plugin.settings.explicit_edge_sources.johnny_decimal_note;
  const regex2 = new RegExp(`^([\\w\\d\\${delimiter}]+)(\\s|\\${delimiter}$)`);
  const johnny_decimal_notes = [];
  (_a = all_files.obsidian) == null ? void 0 : _a.forEach(({ file, cache }) => {
    var _a2;
    const basename2 = Paths.basename(file.path);
    const decimals = (_a2 = basename2.match(regex2)) == null ? void 0 : _a2[1];
    if (!decimals)
      return;
    johnny_decimal_notes.push({
      basename: basename2,
      path: file.path,
      metadata: cache == null ? void 0 : cache.frontmatter,
      decimals: ensure_not_ends_with(decimals, delimiter)
    });
  });
  (_b = all_files.dataview) == null ? void 0 : _b.forEach((page) => {
    var _a2;
    const basename2 = Paths.basename(page.file.path);
    const decimals = (_a2 = basename2.match(regex2)) == null ? void 0 : _a2[1];
    if (!decimals)
      return;
    johnny_decimal_notes.push({
      basename: basename2,
      metadata: page,
      path: page.file.path,
      decimals: ensure_not_ends_with(decimals, delimiter)
    });
  });
  johnny_decimal_notes.forEach((note) => {
    handle_johnny_decimal_note(
      plugin,
      graph,
      note,
      johnny_decimal_notes,
      errors
    );
  });
  return { errors };
};

// src/graph/builders/explicit/list_note.ts
var import_obsidian4 = require("obsidian");

// src/utils/obsidian.ts
var import_obsidian3 = require("obsidian");
var resolve_relative_target_path = (app, relative_target_path, source_path) => {
  var _a;
  const extensioned = Paths.ensure_ext(relative_target_path);
  const target_file = app.metadataCache.getFirstLinkpathDest(
    extensioned,
    source_path
  );
  const target_path = (_a = target_file == null ? void 0 : target_file.path) != null ? _a : Links.resolve_to_absolute_path(app, extensioned, source_path);
  return [target_path, target_file];
};
var copy_to_clipboard = async (text2, options) => {
  const resolved = Object.assign({ notify: true, log: true }, options);
  if (resolved.log) {
    log.feat(text2);
  }
  await navigator.clipboard.writeText(text2);
  if (resolved.notify) {
    new import_obsidian3.Notice("Copied to clipboard and logged to console.");
  }
};

// src/graph/builders/explicit/list_note.ts
var get_list_note_info = (plugin, metadata, path) => {
  var _a;
  if (!metadata) {
    return fail(void 0);
  }
  const field = metadata[META_ALIAS["list-note-field"]];
  if (!field) {
    return fail(void 0);
  } else if (typeof field !== "string") {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: `list-note-field is not a string: '${field}'`
    });
  } else if (!plugin.settings.edge_fields.find((f) => f.label === field)) {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: `list-note-field is not a valid BC field: '${field}'`
    });
  }
  const neighbour_field = (_a = metadata[META_ALIAS["list-note-neighbour-field"]]) != null ? _a : plugin.settings.explicit_edge_sources.list_note.default_neighbour_field;
  if (neighbour_field) {
    if (typeof neighbour_field !== "string") {
      return graph_build_fail({
        path,
        code: "invalid_field_value",
        message: `list-note-neighbour-field is not a string: '${neighbour_field}'`
      });
    } else if (!plugin.settings.edge_fields.find(
      (f) => f.label === neighbour_field
    )) {
      return graph_build_fail({
        path,
        code: "invalid_field_value",
        message: `list-note-neighbour-field is not a valid BC field: '${neighbour_field}'`
      });
    }
  }
  const exclude_index = Boolean(
    metadata[META_ALIAS["list-note-exclude-index"]]
  );
  return succ({
    field,
    exclude_index,
    neighbour_field: neighbour_field != null ? neighbour_field : void 0
  });
};
var FIELD_OVERRIDE_REGEX = /^\s*([-\w\s]+)\b/;
var resolve_field_override = (plugin, list_item, path) => {
  var _a;
  const field = (_a = list_item.text.match(FIELD_OVERRIDE_REGEX)) == null ? void 0 : _a[1];
  if (!field) {
    return succ(void 0);
  } else if (!plugin.settings.edge_fields.find((f) => f.label === field)) {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: `Field override is not a valid BC field: ${field}. Line: ${list_item.position.start.line}`
    });
  } else {
    return succ({ field });
  }
};
var handle_neighbour_list_item = ({
  graph,
  plugin,
  source_path,
  list_note_page,
  list_note_info,
  source_list_item_i
}) => {
  if (!list_note_info.data.neighbour_field)
    return;
  const source_list_item = list_note_page.file.lists.values[source_list_item_i];
  let neighbour_list_item;
  for (let i = source_list_item_i + 1; i < list_note_page.file.lists.values.length; i++) {
    const item = list_note_page.file.lists.values[i];
    if (item.position.start.col < source_list_item.position.start.col) {
      break;
    } else if (item.position.start.col === source_list_item.position.start.col) {
      neighbour_list_item = item;
      break;
    }
  }
  if (!neighbour_list_item)
    return;
  const neighbour_link = neighbour_list_item.outlinks.at(0);
  if (!neighbour_link)
    return;
  const [path, file] = resolve_relative_target_path(
    plugin.app,
    neighbour_link.path,
    list_note_page.file.path
  );
  if (!file) {
    graph.safe_add_node(path, { resolved: false });
  }
  graph.safe_add_directed_edge(source_path, path, {
    explicit: true,
    source: "list_note",
    field: list_note_info.data.neighbour_field
  });
};
var _add_explicit_edges_list_note = (graph, plugin, all_files) => {
  var _a, _b;
  const errors = [];
  (_a = all_files.obsidian) == null ? void 0 : _a.forEach(
    ({ file: list_note_file, cache: list_note_cache }) => {
      if (!list_note_cache)
        return;
      const list_note_info = get_list_note_info(
        plugin,
        list_note_cache == null ? void 0 : list_note_cache.frontmatter,
        list_note_file.path
      );
      if (!list_note_info.ok) {
        if (list_note_info.error)
          errors.push(list_note_info.error);
        return;
      } else {
        new import_obsidian4.Notice(
          "list-notes are not implemented without Dataview enabled"
        );
      }
    }
  );
  (_b = all_files.dataview) == null ? void 0 : _b.forEach((list_note_page) => {
    const list_note_info = get_list_note_info(
      plugin,
      list_note_page,
      list_note_page.file.path
    );
    if (!list_note_info.ok) {
      if (list_note_info.error)
        errors.push(list_note_info.error);
      return;
    }
    list_note_page.file.lists.values.forEach(
      (source_list_item, source_list_item_i) => {
        var _a2, _b2;
        const source_link = source_list_item.outlinks.at(0);
        if (!source_link)
          return;
        const [source_path, source_file] = resolve_relative_target_path(
          plugin.app,
          source_link.path,
          list_note_page.file.path
        );
        if (!source_file) {
          graph.safe_add_node(source_path, { resolved: false });
        }
        if (!list_note_info.data.exclude_index && source_list_item.position.start.col === 0) {
          const source_override_field = resolve_field_override(
            plugin,
            source_list_item,
            list_note_page.file.path
          );
          if (!source_override_field.ok) {
            if (source_override_field.error) {
              errors.push(source_override_field.error);
            }
            return;
          }
          graph.safe_add_directed_edge(
            list_note_page.file.path,
            source_path,
            {
              explicit: true,
              source: "list_note",
              field: (_b2 = (_a2 = source_override_field.data) == null ? void 0 : _a2.field) != null ? _b2 : list_note_info.data.field
            }
          );
        }
        if (list_note_info.data.neighbour_field) {
          handle_neighbour_list_item({
            graph,
            plugin,
            source_path,
            list_note_info,
            list_note_page,
            source_list_item_i
          });
        }
        source_list_item.children.forEach((target_list_item) => {
          var _a3, _b3;
          const target_link = target_list_item.outlinks.at(0);
          if (!target_link)
            return;
          const target_override_field = resolve_field_override(
            plugin,
            target_list_item,
            list_note_page.file.path
          );
          if (!target_override_field.ok) {
            if (target_override_field.error) {
              errors.push(target_override_field.error);
            }
            return;
          }
          const [target_path, target_file] = resolve_relative_target_path(
            plugin.app,
            target_link.path,
            list_note_page.file.path
          );
          if (!target_file) {
            graph.safe_add_node(target_path, { resolved: false });
          }
          graph.safe_add_directed_edge(source_path, target_path, {
            explicit: true,
            source: "list_note",
            field: (_b3 = (_a3 = target_override_field.data) == null ? void 0 : _a3.field) != null ? _b3 : list_note_info.data.field
          });
        });
      }
    );
  });
  return { errors };
};

// src/graph/builders/explicit/regex_note.ts
var get_regex_note_info = (plugin, metadata, path) => {
  var _a;
  if (!metadata)
    return fail(void 0);
  const regex_str = metadata[META_ALIAS["regex-note-regex"]];
  if (!regex_str) {
    return fail(void 0);
  } else if (typeof regex_str !== "string") {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: `regex-note-regex is not a string: '${regex_str}'`
    });
  }
  const flags = metadata[META_ALIAS["regex-note-flags"]];
  if (flags && typeof flags !== "string") {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: `regex-note-flags is not a string: '${flags}'`
    });
  }
  let regex2;
  try {
    regex2 = new RegExp(regex_str, flags || "");
    log.debug(`get_regex_note_info > regex:`, regex2);
  } catch (e) {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: `regex-note-regex is not a valid regex: ${regex_str}`
    });
  }
  const field = (_a = metadata[META_ALIAS["regex-note-field"]]) != null ? _a : plugin.settings.explicit_edge_sources.regex_note.default_field;
  if (!field) {
    return fail(void 0);
  } else if (typeof field !== "string") {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: `regex-note-field is not a string: '${field}'`
    });
  } else if (!plugin.settings.edge_fields.find((f) => f.label === field)) {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: `dataview-note-field is not a valid field: '${field}'`
    });
  }
  return succ({
    field,
    regex: regex2
  });
};
var _add_explicit_edges_regex_note = (graph, plugin, all_files) => {
  var _a, _b;
  const errors = [];
  const regex_note_files = [];
  (_a = all_files.obsidian) == null ? void 0 : _a.forEach(({ file, cache }) => {
    const info = get_regex_note_info(plugin, cache == null ? void 0 : cache.frontmatter, file.path);
    if (!info.ok) {
      if (info.error)
        errors.push(info.error);
      return;
    }
    regex_note_files.push({ info: info.data, path: file.path });
  });
  (_b = all_files.dataview) == null ? void 0 : _b.forEach((page) => {
    const { file } = page;
    const info = get_regex_note_info(plugin, page, file.path);
    if (!info.ok) {
      if (info.error)
        errors.push(info.error);
      return;
    }
    regex_note_files.push({ info: info.data, path: file.path });
  });
  if (!regex_note_files)
    return { errors };
  const nodes = graph.mapNodes((id) => id);
  regex_note_files.forEach((regex_note) => {
    nodes.filter((node) => regex_note.info.regex.test(node)).forEach((target_path) => {
      graph.safe_add_directed_edge(regex_note.path, target_path, {
        explicit: true,
        source: "regex_note",
        field: regex_note.info.field
      });
    });
  });
  return { errors };
};

// src/graph/builders/explicit/tag_note.ts
var get_tag_note_info = (plugin, metadata, path) => {
  var _a;
  if (!metadata)
    return fail(void 0);
  let raw_tag = metadata[META_ALIAS["tag-note-tag"]];
  if (!raw_tag) {
    raw_tag = metadata["BC-tag-note"];
    if (raw_tag) {
      log.warn(
        `'BC-tag-note' is deprecated in favor of ${META_ALIAS["tag-note-tag"]}`
      );
    }
  }
  if (!raw_tag) {
    return fail(void 0);
  } else if (typeof raw_tag !== "string") {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: `tag-note-tag is not a string: '${raw_tag}'`
    });
  }
  const tag = ensure_starts_with(raw_tag, "#");
  const field = (_a = metadata[META_ALIAS["tag-note-field"]]) != null ? _a : plugin.settings.explicit_edge_sources.tag_note.default_field;
  if (!field) {
    return fail(void 0);
  } else if (typeof field !== "string") {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: `tag-note-field is not a string: '${field}'`
    });
  } else if (!plugin.settings.edge_fields.find((f) => f.label === field)) {
    return graph_build_fail({
      path,
      code: "invalid_field_value",
      message: `tag-note-field is not a valid BC field: '${field}'`
    });
  }
  const exact = Boolean(metadata[META_ALIAS["tag-note-exact"]]);
  return succ({ tag, field, exact });
};
var _add_explicit_edges_tag_note = (graph, plugin, all_files) => {
  var _a, _b;
  const errors = [];
  const tag_notes = [];
  const tag_paths_map = /* @__PURE__ */ new Map();
  (_a = all_files.obsidian) == null ? void 0 : _a.forEach(
    ({ file: tag_note_file, cache: tag_note_cache }) => {
      var _a2;
      if (!tag_note_cache)
        return;
      (_a2 = tag_note_cache == null ? void 0 : tag_note_cache.tags) == null ? void 0 : _a2.forEach(({ tag: tag2 }) => {
        var _a3;
        if (!((_a3 = tag_paths_map.get(tag2)) == null ? void 0 : _a3.push(tag_note_file.path))) {
          tag_paths_map.set(tag2, [tag_note_file.path]);
        }
      });
      const tag_note_info = get_tag_note_info(
        plugin,
        tag_note_cache == null ? void 0 : tag_note_cache.frontmatter,
        tag_note_file.path
      );
      if (!tag_note_info.ok) {
        if (tag_note_info.error)
          errors.push(tag_note_info.error);
        return;
      }
      const { tag, field, exact } = tag_note_info.data;
      tag_notes.push({
        tag,
        exact,
        field,
        source_path: tag_note_file.path
      });
    }
  );
  (_b = all_files.dataview) == null ? void 0 : _b.forEach((page) => {
    const tag_note_file = page.file;
    tag_note_file.etags.values.forEach((tag2) => {
      var _a2;
      if (!((_a2 = tag_paths_map.get(tag2)) == null ? void 0 : _a2.push(tag_note_file.path))) {
        tag_paths_map.set(tag2, [tag_note_file.path]);
      }
    });
    const tag_note_info = get_tag_note_info(
      plugin,
      page,
      tag_note_file.path
    );
    if (!tag_note_info.ok) {
      if (tag_note_info.error)
        errors.push(tag_note_info.error);
      return;
    }
    const { tag, field, exact } = tag_note_info.data;
    tag_notes.push({
      tag,
      exact,
      field,
      source_path: tag_note_file.path
    });
  });
  const all_tags = [...tag_paths_map.keys()];
  tag_notes.forEach((tag_note) => {
    const target_paths = tag_note.exact ? tag_paths_map.get(tag_note.tag) : all_tags.filter((tag) => tag.startsWith(tag_note.tag)).flatMap((tag) => tag_paths_map.get(tag));
    target_paths == null ? void 0 : target_paths.forEach((target_path) => {
      graph.safe_add_directed_edge(tag_note.source_path, target_path, {
        explicit: true,
        source: "tag_note",
        field: tag_note.field
      });
    });
  });
  return { errors };
};

// src/graph/builders/explicit/typed_link.ts
var MARKDOWN_LINK_REGEX = /\[(.+?)\]\((.+?)\)/;
var _add_explicit_edges_typed_link = (graph, plugin, all_files) => {
  var _a, _b;
  const errors = [];
  const field_labels = new Set(
    plugin.settings.edge_fields.map((f) => f.label)
  );
  (_a = all_files.obsidian) == null ? void 0 : _a.forEach(
    ({ file: source_file, cache: source_cache }) => {
      var _a2;
      (_a2 = source_cache == null ? void 0 : source_cache.frontmatterLinks) == null ? void 0 : _a2.forEach((target_link) => {
        const field = target_link.key.split(".")[0];
        if (!field_labels.has(field))
          return;
        const [target_path, target_file] = resolve_relative_target_path(
          plugin.app,
          target_link.link,
          source_file.path
        );
        if (!target_file) {
          graph.safe_add_node(target_path, { resolved: false });
        }
        graph.safe_add_directed_edge(source_file.path, target_path, {
          field,
          explicit: true,
          source: "typed_link"
        });
      });
    }
  );
  (_b = all_files.dataview) == null ? void 0 : _b.forEach((page) => {
    const source_file = page.file;
    Object.keys(page).forEach((field) => {
      if (!field_labels.has(field) || ["file", "aliases"].includes(field)) {
        return;
      }
      ensure_is_array(page[field]).flat().forEach((target_link) => {
        var _a2;
        let unsafe_target_path;
        if (!target_link)
          return;
        else if (typeof target_link === "string") {
          unsafe_target_path = (_a2 = target_link.match(MARKDOWN_LINK_REGEX)) == null ? void 0 : _a2[2];
        } else if (typeof target_link === "object" && (target_link == null ? void 0 : target_link.path)) {
          unsafe_target_path = target_link.path;
        } else if (
          // @ts-expect-error: instanceof didn't work here?
          target_link == null ? void 0 : target_link.isLuxonDateTime
        ) {
          errors.push({
            path: source_file.path,
            code: "invalid_field_value",
            message: `Invalid value for field '${field}': '${target_link}'. Dataview DateTime values are not supported, since they don't preserve the original date string.`
          });
        } else {
          errors.push({
            path: source_file.path,
            code: "invalid_field_value",
            message: `Invalid value for field '${field}': '${target_link}'. Expected wikilink or markdown link.`
          });
        }
        if (!unsafe_target_path)
          return;
        const [target_path, target_file] = resolve_relative_target_path(
          plugin.app,
          unsafe_target_path,
          source_file.path
        );
        if (!target_file) {
          graph.safe_add_node(target_path, { resolved: false });
        }
        graph.safe_add_directed_edge(
          source_file.path,
          target_path,
          {
            field,
            explicit: true,
            source: "typed_link"
          }
        );
      });
    });
  });
  return { errors };
};

// src/graph/builders/explicit/index.ts
var add_explicit_edges = {
  tag_note: _add_explicit_edges_tag_note,
  list_note: _add_explicit_edges_list_note,
  date_note: _add_explicit_edges_date_note,
  typed_link: _add_explicit_edges_typed_link,
  regex_note: _add_explicit_edges_regex_note,
  folder_note: _add_explicit_edges_folder_note,
  dendron_note: _add_explicit_edges_dendron_note,
  dataview_note: _add_explicit_edges_dataview_note,
  johnny_decimal_note: _add_explicit_edges_johnny_decimal_note
};

// src/graph/builders/explicit/files.ts
var get_all_files = (app) => {
  var _a;
  if (dataview_plugin.is_enabled(app)) {
    return {
      obsidian: null,
      dataview: (_a = dataview_plugin.get_api()) == null ? void 0 : _a.pages().values
    };
  } else {
    return {
      obsidian: app.vault.getMarkdownFiles().map((file) => ({
        file,
        cache: app.metadataCache.getFileCache(file)
      })),
      dataview: null
    };
  }
};

// src/utils/transitive_rules.ts
var stringify_transitive_relation = (rule) => `[${rule.chain.map((attr2) => url_search_params(attr2, { trim_lone_param: true })).join(", ")}] ${rule.close_reversed ? "<-" : "->"} ${rule.close_field}`;
var regex = /\[(.+)\]\s*(<-|->)\s*(.+)/;
var get_transitive_rule_name = (rule) => rule.name || stringify_transitive_relation(rule);
var parse_transitive_relation = (str) => {
  const match2 = str.match(regex);
  if (!match2) {
    return fail(null);
  } else {
    return succ({
      close_field: match2[3],
      close_reversed: match2[2] === "<-",
      chain: split_and_trim(match2[1]).map((field) => ({ field }))
    });
  }
};
var input_transitive_rule_schema = (data) => {
  const field_labels = data.fields.map((f) => f.label);
  return z.object({
    chain: z.array(
      z.object({ field: zod.schema.dynamic_enum(field_labels) })
    ),
    close_field: zod.schema.dynamic_enum(field_labels, "close_field"),
    close_reversed: z.boolean()
  });
};
var transitive_rule_to_edges = (rule) => {
  const edges = [];
  rule.chain.forEach((attr2, i) => {
    var _a;
    edges.push({
      source_id: i.toString(),
      target_id: (i + 1).toString(),
      source_attr: { resolved: true },
      target_attr: { resolved: true },
      attr: {
        explicit: true,
        field: (_a = attr2.field) != null ? _a : "<field>",
        source: "typed_link"
      }
    });
  });
  edges.push({
    source_attr: { resolved: true },
    target_attr: { resolved: true },
    source_id: rule.close_reversed ? rule.chain.length.toString() : "0",
    target_id: rule.close_reversed ? "0" : rule.chain.length.toString(),
    attr: {
      round: 1,
      explicit: false,
      field: rule.close_field,
      implied_kind: `transitive:${get_transitive_rule_name(rule)}`
    }
  });
  return edges;
};

// src/graph/builders/implied/transitive.ts
var _add_implied_edges_transitive = (graph, plugin, rule, round) => {
  const results = { edges: [], errors: [] };
  if (rule.rounds < round) {
    return results;
  } else if (!plugin.settings.edge_fields.find((f) => f.label === rule.close_field)) {
    results.errors.push({
      code: "invalid_setting_value",
      path: "implied_relations.transitive[].close_field",
      message: `close_field is not a valid BC field: '${rule.close_field}'`
    });
    return results;
  }
  const implied_kind = `transitive:${get_transitive_rule_name(rule)}`;
  graph.forEachNode((start_node) => {
    Traverse.get_transitive_chain_target_ids(
      graph,
      start_node,
      rule.chain,
      (item) => item.edge.target_id !== start_node
    ).forEach((end_node) => {
      const [source_id, target_id] = rule.close_reversed ? [end_node, start_node] : [start_node, end_node];
      results.edges.push({
        source_id,
        target_id,
        attr: {
          round,
          implied_kind,
          explicit: false,
          field: rule.close_field
        }
      });
    });
  });
  return results;
};

// src/graph/builders/index.ts
var add_initial_nodes = (graph, all_files) => {
  if (all_files.obsidian) {
    all_files.obsidian.forEach(({ file, cache }) => {
      var _a, _b, _c;
      const node_attr = {
        resolved: true
      };
      const aliases = (_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.aliases;
      if (Array.isArray(aliases) && aliases.length > 0) {
        node_attr.aliases = aliases;
      }
      if ((_b = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _b[META_ALIAS["ignore-in-edges"]]) {
        node_attr.ignore_in_edges = true;
      }
      if ((_c = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _c[META_ALIAS["ignore-out-edges"]]) {
        node_attr.ignore_out_edges = true;
      }
      graph.addNode(file.path, node_attr);
    });
  } else {
    all_files.dataview.forEach((page) => {
      const node_attr = {
        resolved: true
      };
      const aliases = page.file.aliases.values;
      if (Array.isArray(aliases) && aliases.length > 0) {
        node_attr.aliases = aliases;
      }
      if (page[META_ALIAS["ignore-in-edges"]]) {
        node_attr.ignore_in_edges = true;
      }
      if (page[META_ALIAS["ignore-out-edges"]]) {
        node_attr.ignore_out_edges = true;
      }
      graph.addNode(page.file.path, node_attr);
    });
  }
};
var rebuild_graph = async (plugin) => {
  const timer = new Timer();
  const timer2 = new Timer();
  const graph = new BCGraph();
  const all_files = get_all_files(plugin.app);
  add_initial_nodes(graph, all_files);
  log.debug(timer.elapsedMessage("Adding initial nodes"));
  timer.reset();
  const explicit_edge_results = await Promise.all(
    EXPLICIT_EDGE_SOURCES.map(async (source) => {
      const result = await add_explicit_edges[source](
        graph,
        plugin,
        all_files
      );
      return { source, errors: result.errors };
    })
  );
  log.debug(timer.elapsedMessage("Adding initial edges"));
  timer.reset();
  const max_implied_relationship_rounds = Math.max(
    ...plugin.settings.implied_relations.transitive.map(
      (imp) => imp.rounds
    )
  );
  const implied_edge_results = {
    transitive: []
  };
  const added_fields = /* @__PURE__ */ new Set();
  for (const edge of graph.edgeEntries()) {
    added_fields.add(edge.attributes.field);
  }
  for (let round = 1; round <= max_implied_relationship_rounds; round++) {
    const edges = [];
    plugin.settings.implied_relations.transitive.forEach((rule) => {
      if (!rule.chain.some((attr2) => added_fields.has(attr2.field))) {
        return;
      }
      const result = _add_implied_edges_transitive(
        graph,
        plugin,
        rule,
        round
      );
      edges.push(...result.edges);
      implied_edge_results.transitive.push(...result.errors);
    });
    added_fields.clear();
    if (edges.length === 0)
      break;
    else {
      edges.forEach((edge) => {
        graph.safe_add_directed_edge(
          edge.source_id,
          edge.target_id,
          edge.attr
        ) && added_fields.add(edge.attr.field);
      });
    }
  }
  log.debug(timer.elapsedMessage("Adding implied edges"));
  log.debug(timer2.elapsedMessage("Total Graph building"));
  return { graph, explicit_edge_results, implied_edge_results };
};

// src/settings/SettingsTab.ts
var import_obsidian24 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store2, ...callbacks) {
  if (store2 == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store2.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store2) {
  let value;
  subscribe(store2, (_) => value = _)();
  return value;
}
function component_subscribe(component, store2, callback) {
  component.$$.on_destroy.push(subscribe(store2, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props)
    if (!keys.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_svg_attributes(node, attributes) {
  for (const key in attributes) {
    attr(node, key, attributes[key]);
  }
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block12, next, get_context) {
  let o = old_blocks.length;
  let n2 = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n2;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block12(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n2--;
  }
  while (o && n2) {
    const new_block = new_blocks[n2 - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n2--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n2)
    insert2(new_blocks[n2 - 1]);
  run_all(updates);
  return new_blocks;
}

// node_modules/svelte/src/runtime/internal/spread.js
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n2 = updates[i];
    if (n2) {
      for (const key in o) {
        if (!(key in n2))
          to_null_out[key] = 1;
      }
      for (const key in n2) {
        if (!accounted_for[key]) {
          update2[key] = n2[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n2;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance56, create_fragment56, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance56 ? instance56(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment56 ? create_fragment56($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/tslib/tslib.es6.mjs
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/lucide-svelte/dist/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
var defaultAttributes_default = defaultAttributes;

// node_modules/lucide-svelte/dist/Icon.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i][0];
  child_ctx[11] = list[i][1];
  return child_ctx;
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let svelte_element_levels = [
    /*attrs*/
    ctx[11]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  return {
    c() {
      svelte_element = svg_element(
        /*tag*/
        ctx[10]
      );
      set_svg_attributes(svelte_element, svelte_element_data);
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
    },
    p(ctx2, dirty) {
      set_svg_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [dirty & /*iconNode*/
      32 && /*attrs*/
      ctx2[11]]));
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
    }
  };
}
function create_each_block(ctx) {
  let previous_tag = (
    /*tag*/
    ctx[10]
  );
  let svelte_element_anchor;
  let svelte_element = (
    /*tag*/
    ctx[10] && create_dynamic_element(ctx)
  );
  return {
    c() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*tag*/
        ctx2[10]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[10];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[10]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[10];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*tag*/
        ctx2[10];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
}
function create_fragment(ctx) {
  var _a;
  let svg;
  let each_1_anchor;
  let svg_stroke_width_value;
  let svg_class_value;
  let current;
  let each_value = ensure_array_like(
    /*iconNode*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let svg_levels = [
    defaultAttributes_default,
    /*$$restProps*/
    ctx[6],
    { width: (
      /*size*/
      ctx[2]
    ) },
    { height: (
      /*size*/
      ctx[2]
    ) },
    { stroke: (
      /*color*/
      ctx[1]
    ) },
    {
      "stroke-width": svg_stroke_width_value = /*absoluteStrokeWidth*/
      ctx[4] ? Number(
        /*strokeWidth*/
        ctx[3]
      ) * 24 / Number(
        /*size*/
        ctx[2]
      ) : (
        /*strokeWidth*/
        ctx[3]
      )
    },
    {
      class: svg_class_value = `lucide-icon lucide lucide-${/*name*/
      ctx[0]} ${/*$$props*/
      (_a = ctx[7].class) != null ? _a : ""}`
    }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  return {
    c() {
      svg = svg_element("svg");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      if (default_slot)
        default_slot.c();
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(svg, null);
        }
      }
      append(svg, each_1_anchor);
      if (default_slot) {
        default_slot.m(svg, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2;
      if (dirty & /*iconNode*/
      32) {
        each_value = ensure_array_like(
          /*iconNode*/
          ctx2[5]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(svg, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        defaultAttributes_default,
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        (!current || dirty & /*size*/
        4) && { width: (
          /*size*/
          ctx2[2]
        ) },
        (!current || dirty & /*size*/
        4) && { height: (
          /*size*/
          ctx2[2]
        ) },
        (!current || dirty & /*color*/
        2) && { stroke: (
          /*color*/
          ctx2[1]
        ) },
        (!current || dirty & /*absoluteStrokeWidth, strokeWidth, size*/
        28 && svg_stroke_width_value !== (svg_stroke_width_value = /*absoluteStrokeWidth*/
        ctx2[4] ? Number(
          /*strokeWidth*/
          ctx2[3]
        ) * 24 / Number(
          /*size*/
          ctx2[2]
        ) : (
          /*strokeWidth*/
          ctx2[3]
        ))) && { "stroke-width": svg_stroke_width_value },
        (!current || dirty & /*name, $$props*/
        129 && svg_class_value !== (svg_class_value = `lucide-icon lucide lucide-${/*name*/
        ctx2[0]} ${/*$$props*/
        (_a2 = ctx2[7].class) != null ? _a2 : ""}`)) && { class: svg_class_value }
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
      destroy_each(each_blocks, detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["name", "color", "size", "strokeWidth", "absoluteStrokeWidth", "iconNode"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name } = $$props;
  let { color = "currentColor" } = $$props;
  let { size = 24 } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { absoluteStrokeWidth = false } = $$props;
  let { iconNode } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
    if ("color" in $$new_props)
      $$invalidate(1, color = $$new_props.color);
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("strokeWidth" in $$new_props)
      $$invalidate(3, strokeWidth = $$new_props.strokeWidth);
    if ("absoluteStrokeWidth" in $$new_props)
      $$invalidate(4, absoluteStrokeWidth = $$new_props.absoluteStrokeWidth);
    if ("iconNode" in $$new_props)
      $$invalidate(5, iconNode = $$new_props.iconNode);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [
    name,
    color,
    size,
    strokeWidth,
    absoluteStrokeWidth,
    iconNode,
    $$restProps,
    $$props,
    $$scope,
    slots
  ];
}
var Icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      name: 0,
      color: 1,
      size: 2,
      strokeWidth: 3,
      absoluteStrokeWidth: 4,
      iconNode: 5
    });
  }
};
var Icon_default = Icon;

// node_modules/lucide-svelte/dist/icons/arrow-down-wide-narrow.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment2(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-down-wide-narrow" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "m3 16 4 4 4-4" }],
    ["path", { "d": "M7 20V4" }],
    ["path", { "d": "M11 4h10" }],
    ["path", { "d": "M11 8h7" }],
    ["path", { "d": "M11 12h4" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_down_wide_narrow = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
  }
};
var arrow_down_wide_narrow_default = Arrow_down_wide_narrow;

// node_modules/lucide-svelte/dist/icons/arrow-down.svelte
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment3(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-down" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "M12 5v14" }], ["path", { "d": "m19 12-7 7-7-7" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_down = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {});
  }
};
var arrow_down_default = Arrow_down;

// node_modules/lucide-svelte/dist/icons/arrow-up-narrow-wide.svelte
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment4(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-up-narrow-wide" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "m3 8 4-4 4 4" }],
    ["path", { "d": "M7 4v16" }],
    ["path", { "d": "M11 12h4" }],
    ["path", { "d": "M11 16h7" }],
    ["path", { "d": "M11 20h10" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_up_narrow_wide = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {});
  }
};
var arrow_up_narrow_wide_default = Arrow_up_narrow_wide;

// node_modules/lucide-svelte/dist/icons/arrow-up.svelte
function create_default_slot4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment5(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-up" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m5 12 7-7 7 7" }], ["path", { "d": "M12 19V5" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_up = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, {});
  }
};
var arrow_up_default = Arrow_up;

// node_modules/lucide-svelte/dist/icons/check.svelte
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment6(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "check" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot5] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "M20 6 9 17l-5-5" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Check = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, {});
  }
};
var check_default = Check;

// node_modules/lucide-svelte/dist/icons/chevron-down.svelte
function create_default_slot6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment7(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "chevron-down" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m6 9 6 6 6-6" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Chevron_down = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, {});
  }
};
var chevron_down_default = Chevron_down;

// node_modules/lucide-svelte/dist/icons/chevron-right.svelte
function create_default_slot7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment8(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "chevron-right" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot7] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m9 18 6-6-6-6" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Chevron_right = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, {});
  }
};
var chevron_right_default = Chevron_right;

// node_modules/lucide-svelte/dist/icons/chevrons-down-up.svelte
function create_default_slot8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment9(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "chevrons-down-up" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot8] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m7 20 5-5 5 5" }], ["path", { "d": "m7 4 5 5 5-5" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Chevrons_down_up = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, {});
  }
};
var chevrons_down_up_default = Chevrons_down_up;

// node_modules/lucide-svelte/dist/icons/chevrons-up-down.svelte
function create_default_slot9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment10(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "chevrons-up-down" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot9] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m7 15 5 5 5-5" }], ["path", { "d": "m7 9 5-5 5 5" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Chevrons_up_down = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment10, safe_not_equal, {});
  }
};
var chevrons_up_down_default = Chevrons_up_down;

// node_modules/lucide-svelte/dist/icons/clipboard.svelte
function create_default_slot10(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment11(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "clipboard" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot10] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "rect",
      {
        "width": "8",
        "height": "4",
        "x": "8",
        "y": "2",
        "rx": "1",
        "ry": "1"
      }
    ],
    [
      "path",
      {
        "d": "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Clipboard = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment11, safe_not_equal, {});
  }
};
var clipboard_default = Clipboard;

// node_modules/lucide-svelte/dist/icons/file-json.svelte
function create_default_slot11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment12(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-json" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot11] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
      }
    ],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    [
      "path",
      {
        "d": "M10 12a1 1 0 0 0-1 1v1a1 1 0 0 1-1 1 1 1 0 0 1 1 1v1a1 1 0 0 0 1 1"
      }
    ],
    [
      "path",
      {
        "d": "M14 18a1 1 0 0 0 1-1v-1a1 1 0 0 1 1-1 1 1 0 0 1-1-1v-1a1 1 0 0 0-1-1"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_json = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance12, create_fragment12, safe_not_equal, {});
  }
};
var file_json_default = File_json;

// node_modules/lucide-svelte/dist/icons/group.svelte
function create_default_slot12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment13(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "group" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot12] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M3 7V5c0-1.1.9-2 2-2h2" }],
    ["path", { "d": "M17 3h2c1.1 0 2 .9 2 2v2" }],
    ["path", { "d": "M21 17v2c0 1.1-.9 2-2 2h-2" }],
    ["path", { "d": "M7 21H5c-1.1 0-2-.9-2-2v-2" }],
    [
      "rect",
      {
        "width": "7",
        "height": "5",
        "x": "7",
        "y": "7",
        "rx": "1"
      }
    ],
    [
      "rect",
      {
        "width": "7",
        "height": "5",
        "x": "10",
        "y": "12",
        "rx": "1"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Group = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance13, create_fragment13, safe_not_equal, {});
  }
};
var group_default = Group;

// node_modules/lucide-svelte/dist/icons/image.svelte
function create_default_slot13(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment14(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "image" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance14($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "rect",
      {
        "width": "18",
        "height": "18",
        "x": "3",
        "y": "3",
        "rx": "2",
        "ry": "2"
      }
    ],
    ["circle", { "cx": "9", "cy": "9", "r": "2" }],
    [
      "path",
      {
        "d": "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Image = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance14, create_fragment14, safe_not_equal, {});
  }
};
var image_default = Image;

// node_modules/lucide-svelte/dist/icons/merge.svelte
function create_default_slot14(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment15(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "merge" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot14] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "m8 6 4-4 4 4" }],
    [
      "path",
      {
        "d": "M12 2v10.3a4 4 0 0 1-1.172 2.872L4 22"
      }
    ],
    ["path", { "d": "m20 22-5-5" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Merge = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance15, create_fragment15, safe_not_equal, {});
  }
};
var merge_default = Merge;

// node_modules/lucide-svelte/dist/icons/pencil.svelte
function create_default_slot15(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment16(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "pencil" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot15] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"
      }
    ],
    ["path", { "d": "m15 5 4 4" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Pencil = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance16, create_fragment16, safe_not_equal, {});
  }
};
var pencil_default = Pencil;

// node_modules/lucide-svelte/dist/icons/plus.svelte
function create_default_slot16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment17(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "plus" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot16] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance17($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "M5 12h14" }], ["path", { "d": "M12 5v14" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Plus = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance17, create_fragment17, safe_not_equal, {});
  }
};
var plus_default = Plus;

// node_modules/lucide-svelte/dist/icons/rotate-ccw.svelte
function create_default_slot17(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment18(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "rotate-ccw" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot17] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance18($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"
      }
    ],
    ["path", { "d": "M3 3v5h5" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Rotate_ccw = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance18, create_fragment18, safe_not_equal, {});
  }
};
var rotate_ccw_default = Rotate_ccw;

// node_modules/lucide-svelte/dist/icons/save.svelte
function create_default_slot18(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment19(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "save" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot18] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance19($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"
      }
    ],
    ["polyline", { "points": "17 21 17 13 7 13 7 21" }],
    ["polyline", { "points": "7 3 7 8 15 8" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Save = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance19, create_fragment19, safe_not_equal, {});
  }
};
var save_default = Save;

// node_modules/lucide-svelte/dist/icons/split.svelte
function create_default_slot19(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment20(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "split" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot19] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M16 3h5v5" }],
    ["path", { "d": "M8 3H3v5" }],
    [
      "path",
      {
        "d": "M12 22v-8.3a4 4 0 0 0-1.172-2.872L3 3"
      }
    ],
    ["path", { "d": "m15 9 6-6" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Split = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance20, create_fragment20, safe_not_equal, {});
  }
};
var split_default = Split;

// src/components/settings/EdgeFieldSettings.svelte
var import_obsidian7 = require("obsidian");

// src/const/index.ts
var ICON_SIZE = 20;

// src/components/obsidian/tag.svelte
function create_else_block(ctx) {
  let a;
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      t = text(
        /*tag*/
        ctx[0]
      );
      attr(
        a,
        "title",
        /*title*/
        ctx[2]
      );
      attr(a, "class", "tag");
      attr(a, "tabindex", "0");
      attr(a, "role", "button");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
      if (!mounted) {
        dispose = [
          listen(
            a,
            "click",
            /*click_handler_1*/
            ctx[5]
          ),
          listen(
            a,
            "keydown",
            /*keydown_handler*/
            ctx[6]
          ),
          listen(
            a,
            "contextmenu",
            /*contextmenu_handler_1*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*tag*/
      1)
        set_data(
          t,
          /*tag*/
          ctx2[0]
        );
      if (dirty & /*title*/
      4) {
        attr(
          a,
          "title",
          /*title*/
          ctx2[2]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(a);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block(ctx) {
  let a;
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      t = text(
        /*tag*/
        ctx[0]
      );
      attr(
        a,
        "href",
        /*href*/
        ctx[1]
      );
      attr(
        a,
        "title",
        /*title*/
        ctx[2]
      );
      attr(a, "class", "tag");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
      if (!mounted) {
        dispose = [
          listen(
            a,
            "click",
            /*click_handler*/
            ctx[3]
          ),
          listen(
            a,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*tag*/
      1)
        set_data(
          t,
          /*tag*/
          ctx2[0]
        );
      if (dirty & /*href*/
      2) {
        attr(
          a,
          "href",
          /*href*/
          ctx2[1]
        );
      }
      if (dirty & /*title*/
      4) {
        attr(
          a,
          "title",
          /*title*/
          ctx2[2]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(a);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment21(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*href*/
      ctx2[1] !== void 0
    )
      return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function instance21($$self, $$props, $$invalidate) {
  let { tag } = $$props;
  let { href = void 0 } = $$props;
  let { title = void 0 } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("tag" in $$props2)
      $$invalidate(0, tag = $$props2.tag);
    if ("href" in $$props2)
      $$invalidate(1, href = $$props2.href);
    if ("title" in $$props2)
      $$invalidate(2, title = $$props2.title);
  };
  return [
    tag,
    href,
    title,
    click_handler,
    contextmenu_handler,
    click_handler_1,
    keydown_handler,
    contextmenu_handler_1
  ];
}
var Tag = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance21, create_fragment21, safe_not_equal, { tag: 0, href: 1, title: 2 });
  }
};
var tag_default = Tag;

// src/components/settings/EdgeFieldSettings.svelte
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i];
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i];
  const constants_0 = (
    /*settings*/
    child_ctx[0].edge_field_groups.filter(function func_1(...args) {
      return (
        /*func_1*/
        ctx[13](
          /*field*/
          child_ctx[31],
          ...args
        )
      );
    }).map((g) => g.label)
  );
  child_ctx[32] = constants_0;
  return child_ctx;
}
function get_each_context_4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  return child_ctx;
}
function get_each_context_5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[37] = list[i];
  return child_ctx;
}
function create_if_block_6(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Unsaved changes";
      attr(span, "class", "text-warning");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_5(ctx) {
  let button;
  let arrowdown;
  let current;
  let mounted;
  let dispose;
  arrowdown = new arrow_down_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      button = element("button");
      create_component(arrowdown.$$.fragment);
      attr(button, "class", "w-10");
      attr(button, "aria-label", "Jump to bottom");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(arrowdown, button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_1*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(arrowdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arrowdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(arrowdown);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_5(ctx) {
  let div;
  let tag;
  let current;
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[11](
        /*group_label*/
        ctx[37]
      )
    );
  }
  tag = new tag_default({
    props: {
      tag: (
        /*group_label*/
        ctx[37]
      ),
      title: "Jump to group. Right click for more actions."
    }
  });
  tag.$on("click", click_handler_3);
  tag.$on("contextmenu", function() {
    if (is_function(
      /*context_menus*/
      ctx[3].field_group(
        /*field*/
        ctx[31],
        /*group_label*/
        ctx[37]
      )
    ))
      ctx[3].field_group(
        /*field*/
        ctx[31],
        /*group_label*/
        ctx[37]
      ).apply(this, arguments);
  });
  return {
    c() {
      div = element("div");
      create_component(tag.$$.fragment);
      attr(div, "class", "flex items-center gap-0.5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(tag, div, null);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const tag_changes = {};
      if (dirty[0] & /*settings, filters*/
      3)
        tag_changes.tag = /*group_label*/
        ctx[37];
      tag.$set(tag_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tag.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tag.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(tag);
    }
  };
}
function create_if_block_4(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${"<none>"}`;
      attr(span, "class", "search-empty-state my-0");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_3(ctx) {
  let option;
  let t_value = (
    /*group*/
    ctx[22].label + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*group*/
      ctx[22].label;
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*settings*/
      1 && t_value !== (t_value = /*group*/
      ctx2[22].label + ""))
        set_data(t, t_value);
      if (dirty[0] & /*settings*/
      1 && option_value_value !== (option_value_value = /*group*/
      ctx2[22].label)) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_each_block_4(ctx) {
  let show_if = !/*group*/
  ctx[22].fields.includes(
    /*field*/
    ctx[31].label
  );
  let if_block_anchor;
  let if_block = show_if && create_if_block_3(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*settings, filters*/
      3)
        show_if = !/*group*/
        ctx2[22].fields.includes(
          /*field*/
          ctx2[31].label
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_key_block(ctx) {
  let div;
  let span;
  let t1;
  let t2;
  let t3;
  let select;
  let option;
  let current;
  let mounted;
  let dispose;
  let each_value_5 = ensure_array_like(
    /*group_labels*/
    ctx[32]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_5.length; i += 1) {
    each_blocks_1[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
  }
  const out = (i) => transition_out(each_blocks_1[i], 1, 1, () => {
    each_blocks_1[i] = null;
  });
  let if_block = !/*group_labels*/
  ctx[32].length && create_if_block_4(ctx);
  let each_value_4 = ensure_array_like(
    /*settings*/
    ctx[0].edge_field_groups
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_4.length; i += 1) {
    each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
  }
  function change_handler(...args) {
    return (
      /*change_handler*/
      ctx[12](
        /*field*/
        ctx[31],
        ...args
      )
    );
  }
  return {
    c() {
      div = element("div");
      span = element("span");
      span.textContent = "Groups";
      t1 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      select = element("select");
      option = element("option");
      option.textContent = "Add to Group";
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      option.__value = "";
      set_input_value(option, option.__value);
      option.disabled = true;
      attr(select, "class", "dropdown");
      attr(div, "class", "flex flex-wrap items-center gap-1.5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(div, t1);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div, null);
        }
      }
      append(div, t2);
      if (if_block)
        if_block.m(div, null);
      append(div, t3);
      append(div, select);
      append(select, option);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(select, "");
      current = true;
      if (!mounted) {
        dispose = listen(select, "change", change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*settings, filters, actions, context_menus*/
      15) {
        each_value_5 = ensure_array_like(
          /*group_labels*/
          ctx[32]
        );
        let i;
        for (i = 0; i < each_value_5.length; i += 1) {
          const child_ctx = get_each_context_5(ctx, each_value_5, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            transition_in(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_5(child_ctx);
            each_blocks_1[i].c();
            transition_in(each_blocks_1[i], 1);
            each_blocks_1[i].m(div, t2);
          }
        }
        group_outros();
        for (i = each_value_5.length; i < each_blocks_1.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!/*group_labels*/
      ctx[32].length) {
        if (if_block) {
        } else {
          if_block = create_if_block_4(ctx);
          if_block.c();
          if_block.m(div, t3);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*settings, filters*/
      3) {
        each_value_4 = ensure_array_like(
          /*settings*/
          ctx[0].edge_field_groups
        );
        let i;
        for (i = 0; i < each_value_4.length; i += 1) {
          const child_ctx = get_each_context_4(ctx, each_value_4, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_4.length;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_5.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks_1, detaching);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_3(ctx) {
  let div1;
  let div0;
  let input;
  let input_id_value;
  let input_value_value;
  let t0;
  let button;
  let t2;
  let previous_key = (
    /*settings*/
    ctx[0].edge_field_groups
  );
  let current;
  let mounted;
  let dispose;
  function blur_handler(...args) {
    return (
      /*blur_handler*/
      ctx[9](
        /*field*/
        ctx[31],
        ...args
      )
    );
  }
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[10](
        /*field*/
        ctx[31]
      )
    );
  }
  let key_block = create_key_block(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      input = element("input");
      t0 = space();
      button = element("button");
      button.textContent = "X";
      t2 = space();
      key_block.c();
      attr(input, "id", input_id_value = /*actions*/
      ctx[2].fields.make_id(
        /*field*/
        ctx[31].label
      ));
      attr(input, "type", "text");
      attr(input, "class", "w-48 scroll-mt-40");
      attr(input, "placeholder", "Field Label");
      input.value = input_value_value = /*field*/
      ctx[31].label;
      attr(button, "class", "w-8");
      attr(button, "title", "Remove Field");
      attr(div0, "class", "flex flex-wrap items-center gap-1");
      attr(div1, "class", "flex flex-col gap-2");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, input);
      append(div0, t0);
      append(div0, button);
      append(div1, t2);
      key_block.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "blur", blur_handler),
          listen(button, "click", click_handler_2)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty[0] & /*settings, filters*/
      3 && input_id_value !== (input_id_value = /*actions*/
      ctx[2].fields.make_id(
        /*field*/
        ctx[31].label
      ))) {
        attr(input, "id", input_id_value);
      }
      if (!current || dirty[0] & /*settings, filters*/
      3 && input_value_value !== (input_value_value = /*field*/
      ctx[31].label) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
      if (dirty[0] & /*settings*/
      1 && safe_not_equal(previous_key, previous_key = /*settings*/
      ctx[0].edge_field_groups)) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div1, null);
      } else {
        key_block.p(ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      key_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2(ctx) {
  let button;
  let arrowdown;
  let current;
  let mounted;
  let dispose;
  arrowdown = new arrow_down_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      button = element("button");
      create_component(arrowdown.$$.fragment);
      attr(button, "class", "w-10");
      attr(button, "aria-label", "Jump to bottom");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(arrowdown, button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_5*/
          ctx[16]
        );
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(arrowdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arrowdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(arrowdown);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_2(ctx) {
  let div;
  let tag;
  let current;
  function click_handler_7() {
    return (
      /*click_handler_7*/
      ctx[20](
        /*field_label*/
        ctx[28]
      )
    );
  }
  tag = new tag_default({
    props: {
      tag: (
        /*field_label*/
        ctx[28]
      ),
      title: "Jump to field. Right click for more actions."
    }
  });
  tag.$on("click", click_handler_7);
  tag.$on("contextmenu", function() {
    if (is_function(
      /*context_menus*/
      ctx[3].group_field(
        /*group*/
        ctx[22],
        /*field_label*/
        ctx[28]
      )
    ))
      ctx[3].group_field(
        /*group*/
        ctx[22],
        /*field_label*/
        ctx[28]
      ).apply(this, arguments);
  });
  return {
    c() {
      div = element("div");
      create_component(tag.$$.fragment);
      attr(div, "class", "flex items-center gap-0.5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(tag, div, null);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const tag_changes = {};
      if (dirty[0] & /*settings, filters*/
      3)
        tag_changes.tag = /*field_label*/
        ctx[28];
      tag.$set(tag_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tag.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tag.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(tag);
    }
  };
}
function create_if_block_1(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${"<none>"}`;
      attr(span, "class", "search-empty-state my-0");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block2(ctx) {
  let option;
  let t_value = (
    /*edge_field*/
    ctx[25].label + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*edge_field*/
      ctx[25].label;
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*settings*/
      1 && t_value !== (t_value = /*edge_field*/
      ctx2[25].label + ""))
        set_data(t, t_value);
      if (dirty[0] & /*settings*/
      1 && option_value_value !== (option_value_value = /*edge_field*/
      ctx2[25].label)) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_each_block_1(ctx) {
  let show_if = !/*group*/
  ctx[22].fields.includes(
    /*edge_field*/
    ctx[25].label
  );
  let if_block_anchor;
  let if_block = show_if && create_if_block2(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*settings, filters*/
      3)
        show_if = !/*group*/
        ctx2[22].fields.includes(
          /*edge_field*/
          ctx2[25].label
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_each_block2(ctx) {
  let div2;
  let div0;
  let input;
  let input_id_value;
  let input_value_value;
  let t0;
  let button;
  let t2;
  let div1;
  let span;
  let t4;
  let t5;
  let t6;
  let select;
  let option;
  let current;
  let mounted;
  let dispose;
  function blur_handler_1(...args) {
    return (
      /*blur_handler_1*/
      ctx[18](
        /*group*/
        ctx[22],
        ...args
      )
    );
  }
  function click_handler_6() {
    return (
      /*click_handler_6*/
      ctx[19](
        /*group*/
        ctx[22]
      )
    );
  }
  let each_value_2 = ensure_array_like(
    /*group*/
    ctx[22].fields
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks_1[i], 1, 1, () => {
    each_blocks_1[i] = null;
  });
  let if_block = !/*group*/
  ctx[22].fields.length && create_if_block_1(ctx);
  let each_value_1 = ensure_array_like(
    /*settings*/
    ctx[0].edge_fields
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  function change_handler_1(...args) {
    return (
      /*change_handler_1*/
      ctx[21](
        /*group*/
        ctx[22],
        ...args
      )
    );
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      input = element("input");
      t0 = space();
      button = element("button");
      button.textContent = "X";
      t2 = space();
      div1 = element("div");
      span = element("span");
      span.textContent = "Fields";
      t4 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t5 = space();
      if (if_block)
        if_block.c();
      t6 = space();
      select = element("select");
      option = element("option");
      option.textContent = "Add Field";
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(input, "id", input_id_value = /*actions*/
      ctx[2].groups.make_id(
        /*group*/
        ctx[22].label
      ));
      attr(input, "type", "text");
      attr(input, "class", "w-48 scroll-mt-40");
      attr(input, "placeholder", "Group Label");
      input.value = input_value_value = /*group*/
      ctx[22].label;
      attr(button, "class", "w-8");
      attr(button, "title", "Remove Group");
      attr(div0, "class", "flex flex-wrap items-center gap-1");
      option.__value = "";
      set_input_value(option, option.__value);
      option.disabled = true;
      attr(select, "class", "dropdown");
      attr(div1, "class", "flex flex-wrap items-center gap-1.5");
      attr(div2, "class", "flex flex-col gap-2");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, input);
      append(div0, t0);
      append(div0, button);
      append(div2, t2);
      append(div2, div1);
      append(div1, span);
      append(div1, t4);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div1, null);
        }
      }
      append(div1, t5);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t6);
      append(div1, select);
      append(select, option);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(select, "");
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "blur", blur_handler_1),
          listen(button, "click", click_handler_6),
          listen(select, "change", change_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty[0] & /*settings, filters*/
      3 && input_id_value !== (input_id_value = /*actions*/
      ctx[2].groups.make_id(
        /*group*/
        ctx[22].label
      ))) {
        attr(input, "id", input_id_value);
      }
      if (!current || dirty[0] & /*settings, filters*/
      3 && input_value_value !== (input_value_value = /*group*/
      ctx[22].label) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
      if (dirty[0] & /*settings, filters, actions, context_menus*/
      15) {
        each_value_2 = ensure_array_like(
          /*group*/
          ctx[22].fields
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx, each_value_2, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            transition_in(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_2(child_ctx);
            each_blocks_1[i].c();
            transition_in(each_blocks_1[i], 1);
            each_blocks_1[i].m(div1, t5);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks_1.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!/*group*/
      ctx[22].fields.length) {
        if (if_block) {
        } else {
          if_block = create_if_block_1(ctx);
          if_block.c();
          if_block.m(div1, t6);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*settings, filters*/
      3) {
        each_value_1 = ensure_array_like(
          /*settings*/
          ctx[0].edge_fields
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks_1, detaching);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment22(ctx) {
  let div7;
  let div0;
  let button0;
  let saveicon;
  let t0;
  let t1;
  let t2;
  let div2;
  let h40;
  let t4;
  let div1;
  let input0;
  let t5;
  let button1;
  let t6;
  let button1_disabled_value;
  let t7;
  let t8;
  let div3;
  let t9;
  let button2;
  let plusicon0;
  let t10;
  let t11;
  let hr;
  let t12;
  let div5;
  let h41;
  let t14;
  let div4;
  let input1;
  let t15;
  let button3;
  let t16;
  let button3_disabled_value;
  let t17;
  let t18;
  let div6;
  let t19;
  let button4;
  let plusicon1;
  let t20;
  let current;
  let mounted;
  let dispose;
  saveicon = new save_default({ props: { size: ICON_SIZE } });
  let if_block0 = (
    /*settings*/
    ctx[0].is_dirty && create_if_block_6(ctx)
  );
  let if_block1 = (
    /*settings*/
    ctx[0].edge_fields.length > 3 && create_if_block_5(ctx)
  );
  let each_value_3 = ensure_array_like(
    /*settings*/
    ctx[0].edge_fields.filter(
      /*func*/
      ctx[8]
    )
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  const out = (i) => transition_out(each_blocks_1[i], 1, 1, () => {
    each_blocks_1[i] = null;
  });
  plusicon0 = new plus_default({ props: { size: ICON_SIZE } });
  let if_block2 = (
    /*settings*/
    ctx[0].edge_field_groups.length > 3 && create_if_block_2(ctx)
  );
  let each_value = ensure_array_like(
    /*settings*/
    ctx[0].edge_field_groups.filter(
      /*func_3*/
      ctx[17]
    )
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out_1 = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  plusicon1 = new plus_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      div7 = element("div");
      div0 = element("div");
      button0 = element("button");
      create_component(saveicon.$$.fragment);
      t0 = text("\n			Save");
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      div2 = element("div");
      h40 = element("h4");
      h40.textContent = "Fields";
      t4 = space();
      div1 = element("div");
      input0 = element("input");
      t5 = space();
      button1 = element("button");
      t6 = text("X");
      t7 = space();
      if (if_block1)
        if_block1.c();
      t8 = space();
      div3 = element("div");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t9 = space();
      button2 = element("button");
      create_component(plusicon0.$$.fragment);
      t10 = text("\n			New Edge Field");
      t11 = space();
      hr = element("hr");
      t12 = space();
      div5 = element("div");
      h41 = element("h4");
      h41.textContent = "Groups";
      t14 = space();
      div4 = element("div");
      input1 = element("input");
      t15 = space();
      button3 = element("button");
      t16 = text("X");
      t17 = space();
      if (if_block2)
        if_block2.c();
      t18 = space();
      div6 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t19 = space();
      button4 = element("button");
      create_component(plusicon1.$$.fragment);
      t20 = text("\n			New Group");
      attr(button0, "class", "flex items-center gap-1");
      attr(div0, "class", "my-2 flex items-center gap-2");
      attr(input0, "type", "text");
      attr(input0, "placeholder", "Filter Fields by Name");
      attr(button1, "class", "w-8");
      attr(button1, "aria-label", "Clear Filter");
      button1.disabled = button1_disabled_value = /*filters*/
      ctx[1].fields === "";
      attr(div1, "class", "flex gap-1");
      attr(div2, "class", "flex items-center gap-4");
      attr(button2, "class", "flex items-center gap-1");
      attr(div3, "class", "flex flex-col gap-7");
      attr(input1, "type", "text");
      attr(input1, "placeholder", "Filter Groups by Name");
      attr(button3, "class", "w-8");
      attr(button3, "aria-label", "Clear Filter");
      button3.disabled = button3_disabled_value = /*filters*/
      ctx[1].groups === "";
      attr(div4, "class", "flex gap-1");
      attr(div5, "class", "flex items-center gap-4");
      attr(button4, "class", "flex items-center gap-1");
      attr(div6, "class", "flex flex-col gap-7");
      attr(div7, "class", "flex flex-col");
    },
    m(target, anchor) {
      insert(target, div7, anchor);
      append(div7, div0);
      append(div0, button0);
      mount_component(saveicon, button0, null);
      append(button0, t0);
      append(div0, t1);
      if (if_block0)
        if_block0.m(div0, null);
      append(div7, t2);
      append(div7, div2);
      append(div2, h40);
      append(div2, t4);
      append(div2, div1);
      append(div1, input0);
      set_input_value(
        input0,
        /*filters*/
        ctx[1].fields
      );
      append(div1, t5);
      append(div1, button1);
      append(button1, t6);
      append(div2, t7);
      if (if_block1)
        if_block1.m(div2, null);
      append(div7, t8);
      append(div7, div3);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div3, null);
        }
      }
      append(div3, t9);
      append(div3, button2);
      mount_component(plusicon0, button2, null);
      append(button2, t10);
      append(div7, t11);
      append(div7, hr);
      append(div7, t12);
      append(div7, div5);
      append(div5, h41);
      append(div5, t14);
      append(div5, div4);
      append(div4, input1);
      set_input_value(
        input1,
        /*filters*/
        ctx[1].groups
      );
      append(div4, t15);
      append(div4, button3);
      append(button3, t16);
      append(div5, t17);
      if (if_block2)
        if_block2.m(div5, null);
      append(div7, t18);
      append(div7, div6);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div6, null);
        }
      }
      append(div6, t19);
      append(div6, button4);
      mount_component(plusicon1, button4, null);
      append(button4, t20);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*actions*/
            ctx[2].save
          ),
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[5]
          ),
          listen(
            button1,
            "click",
            /*click_handler*/
            ctx[6]
          ),
          listen(
            button2,
            "click",
            /*actions*/
            ctx[2].fields.add
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[14]
          ),
          listen(
            button3,
            "click",
            /*click_handler_4*/
            ctx[15]
          ),
          listen(
            button4,
            "click",
            /*actions*/
            ctx[2].groups.add
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*settings*/
        ctx2[0].is_dirty
      ) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_6(ctx2);
          if_block0.c();
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & /*filters*/
      2 && input0.value !== /*filters*/
      ctx2[1].fields) {
        set_input_value(
          input0,
          /*filters*/
          ctx2[1].fields
        );
      }
      if (!current || dirty[0] & /*filters*/
      2 && button1_disabled_value !== (button1_disabled_value = /*filters*/
      ctx2[1].fields === "")) {
        button1.disabled = button1_disabled_value;
      }
      if (
        /*settings*/
        ctx2[0].edge_fields.length > 3
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*settings*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_5(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*settings, actions, filters, context_menus*/
      15) {
        each_value_3 = ensure_array_like(
          /*settings*/
          ctx2[0].edge_fields.filter(
            /*func*/
            ctx2[8]
          )
        );
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            transition_in(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_3(child_ctx);
            each_blocks_1[i].c();
            transition_in(each_blocks_1[i], 1);
            each_blocks_1[i].m(div3, t9);
          }
        }
        group_outros();
        for (i = each_value_3.length; i < each_blocks_1.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (dirty[0] & /*filters*/
      2 && input1.value !== /*filters*/
      ctx2[1].groups) {
        set_input_value(
          input1,
          /*filters*/
          ctx2[1].groups
        );
      }
      if (!current || dirty[0] & /*filters*/
      2 && button3_disabled_value !== (button3_disabled_value = /*filters*/
      ctx2[1].groups === "")) {
        button3.disabled = button3_disabled_value;
      }
      if (
        /*settings*/
        ctx2[0].edge_field_groups.length > 3
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*settings*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div5, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*actions, settings, filters, context_menus*/
      15) {
        each_value = ensure_array_like(
          /*settings*/
          ctx2[0].edge_field_groups.filter(
            /*func_3*/
            ctx2[17]
          )
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div6, t19);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out_1(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(saveicon.$$.fragment, local);
      transition_in(if_block1);
      for (let i = 0; i < each_value_3.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      transition_in(plusicon0.$$.fragment, local);
      transition_in(if_block2);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(plusicon1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(saveicon.$$.fragment, local);
      transition_out(if_block1);
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      transition_out(plusicon0.$$.fragment, local);
      transition_out(if_block2);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(plusicon1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div7);
      }
      destroy_component(saveicon);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_each(each_blocks_1, detaching);
      destroy_component(plusicon0);
      if (if_block2)
        if_block2.d();
      destroy_each(each_blocks, detaching);
      destroy_component(plusicon1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance22($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  const settings = plugin.settings;
  let filters = { fields: "", groups: "" };
  const actions = {
    save: () => __awaiter(void 0, void 0, void 0, function* () {
      yield Promise.all([plugin.saveSettings(), plugin.refresh({ redraw_side_views: true })]);
      $$invalidate(4, plugin);
    }),
    fields: {
      make_id: (label) => `BC-edge-field-${label}`,
      scroll_to: (label) => {
        const el = document.getElementById(actions.fields.make_id(label));
        if (el) {
          el.scrollIntoView({ behavior: "smooth", block: "center" });
          el.focus();
        }
      },
      add: () => {
        const field = {
          label: `Edge Field ${settings.edge_fields.length + 1}`
        };
        settings.edge_fields.push(field);
        setTimeout(() => actions.fields.scroll_to(field.label), 0);
        $$invalidate(0, settings.is_dirty = true, settings);
        $$invalidate(4, plugin);
      },
      remove: (edge_field) => {
        $$invalidate(0, settings.edge_fields = settings.edge_fields.filter((f) => f.label !== edge_field.label), settings);
        settings.edge_field_groups.forEach((group) => {
          group.fields = group.fields.filter((f) => f !== edge_field.label);
        });
        $$invalidate(0, settings.is_dirty = true, settings);
        $$invalidate(4, plugin);
      },
      rename: (edge_field, new_label) => {
        if (edge_field.label === new_label) {
          return;
        } else if (new_label === "") {
          return new import_obsidian7.Notice("Field label cannot be empty.");
        } else if (settings.edge_fields.some((f) => f.label === new_label)) {
          return new import_obsidian7.Notice("Field label must be unique.");
        }
        settings.edge_field_groups.forEach((group) => {
          const index = group.fields.indexOf(edge_field.label);
          if (index === -1)
            return;
          group.fields[index] = new_label;
        });
        settings.implied_relations.transitive.forEach((rule) => {
          rule.chain = rule.chain.map((attr2) => attr2.field === edge_field.label ? Object.assign(Object.assign({}, attr2), { field: new_label }) : attr2);
          rule.close_field = rule.close_field === edge_field.label ? new_label : rule.close_field;
        });
        $$invalidate(
          0,
          settings.explicit_edge_sources.tag_note.default_field = settings.explicit_edge_sources.tag_note.default_field === edge_field.label ? new_label : settings.explicit_edge_sources.tag_note.default_field,
          settings
        );
        $$invalidate(
          0,
          settings.explicit_edge_sources.list_note.default_neighbour_field = settings.explicit_edge_sources.list_note.default_neighbour_field === edge_field.label ? new_label : settings.explicit_edge_sources.list_note.default_neighbour_field,
          settings
        );
        $$invalidate(
          0,
          settings.explicit_edge_sources.dendron_note.default_field = settings.explicit_edge_sources.dendron_note.default_field === edge_field.label ? new_label : settings.explicit_edge_sources.dendron_note.default_field,
          settings
        );
        $$invalidate(
          0,
          settings.explicit_edge_sources.johnny_decimal_note.default_field = settings.explicit_edge_sources.johnny_decimal_note.default_field === edge_field.label ? new_label : settings.explicit_edge_sources.johnny_decimal_note.default_field,
          settings
        );
        $$invalidate(
          0,
          settings.explicit_edge_sources.date_note.default_field = settings.explicit_edge_sources.date_note.default_field === edge_field.label ? new_label : settings.explicit_edge_sources.date_note.default_field,
          settings
        );
        $$invalidate(
          0,
          settings.explicit_edge_sources.regex_note.default_field = settings.explicit_edge_sources.regex_note.default_field === edge_field.label ? new_label : settings.explicit_edge_sources.regex_note.default_field,
          settings
        );
        edge_field.label = new_label;
        $$invalidate(0, settings.is_dirty = true, settings);
        $$invalidate(4, plugin);
      }
    },
    groups: {
      make_id: (label) => `BC-edge-group-${label}`,
      scroll_to: (label) => {
        const el = document.getElementById(actions.groups.make_id(label));
        if (el) {
          el.scrollIntoView({ behavior: "smooth", block: "center" });
          el.focus();
        }
      },
      add: () => {
        const group = {
          label: `Group ${settings.edge_field_groups.length + 1}`,
          fields: []
        };
        settings.edge_field_groups.push(group);
        setTimeout(() => actions.groups.scroll_to(group.label), 0);
        $$invalidate(0, settings.is_dirty = true, settings);
        $$invalidate(4, plugin);
      },
      remove: (group) => {
        $$invalidate(0, settings.edge_field_groups = settings.edge_field_groups.filter((g) => g.label !== group.label), settings);
        $$invalidate(0, settings.is_dirty = true, settings);
        $$invalidate(4, plugin);
      },
      rename: (group, new_label) => {
        if (group.label === new_label)
          return;
        $$invalidate(0, settings.views.page.trail.field_group_labels = settings.views.page.trail.field_group_labels.map((label) => label === group.label ? new_label : label), settings);
        $$invalidate(0, settings.views.page.prev_next.field_group_labels.prev = settings.views.page.prev_next.field_group_labels.prev.map((label) => label === group.label ? new_label : label), settings);
        $$invalidate(0, settings.views.page.prev_next.field_group_labels.next = settings.views.page.prev_next.field_group_labels.next.map((label) => label === group.label ? new_label : label), settings);
        $$invalidate(0, settings.views.side.matrix.field_group_labels = settings.views.side.matrix.field_group_labels.map((label) => label === group.label ? new_label : label), settings);
        $$invalidate(0, settings.views.side.matrix.field_group_labels = settings.views.side.matrix.field_group_labels.map((label) => label === group.label ? new_label : label), settings);
        group.label = new_label;
        $$invalidate(0, settings.is_dirty = true, settings);
        $$invalidate(4, plugin);
      },
      add_field: (group, field_label) => {
        if (!group)
          return;
        group.fields.push(field_label);
        $$invalidate(0, settings.is_dirty = true, settings);
        $$invalidate(4, plugin);
      },
      remove_field: (group, field_label) => {
        if (!group)
          return;
        group.fields = group.fields.filter((f) => f !== field_label);
        $$invalidate(0, settings.is_dirty = true, settings);
        $$invalidate(4, plugin);
      }
    }
  };
  const context_menus = {
    field_group: (edge_field, group_label) => (e) => {
      const menu = new import_obsidian7.Menu();
      menu.addItem((item) => item.setTitle("Remove from Group").setIcon("x").onClick(() => actions.groups.remove_field(settings.edge_field_groups.find((g) => g.label === group_label), edge_field.label)));
      menu.showAtMouseEvent(e);
    },
    group_field: (group, field_label) => (e) => {
      const menu = new import_obsidian7.Menu();
      menu.addItem((item) => item.setTitle("Remove Field").setIcon("x").onClick(() => actions.groups.remove_field(group, field_label)));
      menu.showAtMouseEvent(e);
    }
  };
  function input0_input_handler() {
    filters.fields = this.value;
    $$invalidate(1, filters);
  }
  const click_handler = () => $$invalidate(1, filters.fields = "", filters);
  const click_handler_1 = () => {
    var _a, _b;
    return actions.fields.scroll_to((_b = (_a = settings.edge_fields.last()) == null ? void 0 : _a.label) != null ? _b : "");
  };
  const func = (f) => f.label.includes(filters.fields.toLowerCase());
  const blur_handler = (field, e) => actions.fields.rename(field, e.currentTarget.value);
  const click_handler_2 = (field) => actions.fields.remove(field);
  const click_handler_3 = (group_label) => actions.groups.scroll_to(group_label);
  const change_handler = (field, e) => {
    if (e.currentTarget.value) {
      actions.groups.add_field(settings.edge_field_groups.find((g) => g.label === e.currentTarget.value), field.label);
      e.currentTarget.value = "";
    }
  };
  const func_1 = (field, group) => group.fields.includes(field.label);
  function input1_input_handler() {
    filters.groups = this.value;
    $$invalidate(1, filters);
  }
  const click_handler_4 = () => $$invalidate(1, filters.groups = "", filters);
  const click_handler_5 = () => {
    var _a, _b;
    return actions.groups.scroll_to((_b = (_a = settings.edge_field_groups.last()) == null ? void 0 : _a.label) != null ? _b : "");
  };
  const func_3 = (group) => group.label.includes(filters.groups.toLowerCase());
  const blur_handler_1 = (group, e) => actions.groups.rename(group, e.currentTarget.value);
  const click_handler_6 = (group) => actions.groups.remove(group);
  const click_handler_7 = (field_label) => actions.fields.scroll_to(field_label);
  const change_handler_1 = (group, e) => {
    if (e.currentTarget.value) {
      actions.groups.add_field(group, e.currentTarget.value);
      e.currentTarget.value = "";
    }
  };
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(4, plugin = $$props2.plugin);
  };
  return [
    settings,
    filters,
    actions,
    context_menus,
    plugin,
    input0_input_handler,
    click_handler,
    click_handler_1,
    func,
    blur_handler,
    click_handler_2,
    click_handler_3,
    change_handler,
    func_1,
    input1_input_handler,
    click_handler_4,
    click_handler_5,
    func_3,
    blur_handler_1,
    click_handler_6,
    click_handler_7,
    change_handler_1
  ];
}
var EdgeFieldSettings = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance22, create_fragment22, safe_not_equal, { plugin: 4 }, null, [-1, -1]);
  }
};
var EdgeFieldSettings_default = EdgeFieldSettings;

// src/components/settings/TransitiveImpliedRelations.svelte
var import_obsidian10 = require("obsidian");

// src/components/button/ChevronOpener.svelte
function create_else_block2(ctx) {
  let chevronright;
  let current;
  chevronright = new chevron_right_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      create_component(chevronright.$$.fragment);
    },
    m(target, anchor) {
      mount_component(chevronright, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(chevronright.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chevronright.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(chevronright, detaching);
    }
  };
}
function create_if_block3(ctx) {
  let chevrondown;
  let current;
  chevrondown = new chevron_down_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      create_component(chevrondown.$$.fragment);
    },
    m(target, anchor) {
      mount_component(chevrondown, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(chevrondown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chevrondown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(chevrondown, detaching);
    }
  };
}
function create_fragment23(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*open*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance23($$self, $$props, $$invalidate) {
  let { open } = $$props;
  $$self.$$set = ($$props2) => {
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
  };
  return [open];
}
var ChevronOpener = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance23, create_fragment23, safe_not_equal, { open: 0 });
  }
};
var ChevronOpener_default = ChevronOpener;

// src/components/obsidian/RenderMarkdown.svelte
var import_obsidian9 = require("obsidian");

// src/stores/active_file.ts
var import_obsidian8 = require("obsidian");

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// src/stores/active_file.ts
var store = writable(null);
var active_file_store = {
  ...store,
  refresh: (app) => store.set(app.workspace.getActiveFile())
};

// src/components/obsidian/RenderMarkdown.svelte
function create_fragment24(ctx) {
  let div;
  let div_class_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", div_class_value = "markdown-rendered " + /*cls*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[5](div);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*cls*/
      1 && div_class_value !== (div_class_value = "markdown-rendered " + /*cls*/
      ctx2[0])) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[5](null);
    }
  };
}
function instance24($$self, $$props, $$invalidate) {
  let $active_file_store;
  component_subscribe($$self, active_file_store, ($$value) => $$invalidate(6, $active_file_store = $$value));
  let { cls = "" } = $$props;
  let { markdown } = $$props;
  let { plugin } = $$props;
  let { source_path = void 0 } = $$props;
  let el;
  const render = (markdown2, el2) => {
    var _a;
    if (!el2)
      return;
    log.debug("rendering markdown");
    el2.empty();
    import_obsidian9.MarkdownRenderer.render(
      plugin.app,
      markdown2,
      el2,
      (_a = source_path !== null && source_path !== void 0 ? source_path : $active_file_store === null || $active_file_store === void 0 ? void 0 : $active_file_store.path) !== null && _a !== void 0 ? _a : "",
      plugin
    );
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("cls" in $$props2)
      $$invalidate(0, cls = $$props2.cls);
    if ("markdown" in $$props2)
      $$invalidate(2, markdown = $$props2.markdown);
    if ("plugin" in $$props2)
      $$invalidate(3, plugin = $$props2.plugin);
    if ("source_path" in $$props2)
      $$invalidate(4, source_path = $$props2.source_path);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*markdown, el*/
    6) {
      $:
        render(markdown, el);
    }
  };
  return [cls, el, markdown, plugin, source_path, div_binding];
}
var RenderMarkdown = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance24, create_fragment24, safe_not_equal, {
      cls: 0,
      markdown: 2,
      plugin: 3,
      source_path: 4
    });
  }
};
var RenderMarkdown_default = RenderMarkdown;

// src/components/obsidian/RenderExternalCodeblock.svelte
function create_fragment25(ctx) {
  let rendermarkdown;
  let updating_plugin;
  let current;
  function rendermarkdown_plugin_binding(value) {
    ctx[4](value);
  }
  let rendermarkdown_props = {
    source_path: (
      /*source_path*/
      ctx[3]
    ),
    markdown: wrap_in_codeblock(
      /*code*/
      ctx[1],
      /*type*/
      ctx[2]
    )
  };
  if (
    /*plugin*/
    ctx[0] !== void 0
  ) {
    rendermarkdown_props.plugin = /*plugin*/
    ctx[0];
  }
  rendermarkdown = new RenderMarkdown_default({ props: rendermarkdown_props });
  binding_callbacks.push(() => bind(rendermarkdown, "plugin", rendermarkdown_plugin_binding));
  return {
    c() {
      create_component(rendermarkdown.$$.fragment);
    },
    m(target, anchor) {
      mount_component(rendermarkdown, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const rendermarkdown_changes = {};
      if (dirty & /*source_path*/
      8)
        rendermarkdown_changes.source_path = /*source_path*/
        ctx2[3];
      if (dirty & /*code, type*/
      6)
        rendermarkdown_changes.markdown = wrap_in_codeblock(
          /*code*/
          ctx2[1],
          /*type*/
          ctx2[2]
        );
      if (!updating_plugin && dirty & /*plugin*/
      1) {
        updating_plugin = true;
        rendermarkdown_changes.plugin = /*plugin*/
        ctx2[0];
        add_flush_callback(() => updating_plugin = false);
      }
      rendermarkdown.$set(rendermarkdown_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(rendermarkdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rendermarkdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(rendermarkdown, detaching);
    }
  };
}
function instance25($$self, $$props, $$invalidate) {
  let { code } = $$props;
  let { type } = $$props;
  let { plugin } = $$props;
  let { source_path = void 0 } = $$props;
  function rendermarkdown_plugin_binding(value) {
    plugin = value;
    $$invalidate(0, plugin);
  }
  $$self.$$set = ($$props2) => {
    if ("code" in $$props2)
      $$invalidate(1, code = $$props2.code);
    if ("type" in $$props2)
      $$invalidate(2, type = $$props2.type);
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("source_path" in $$props2)
      $$invalidate(3, source_path = $$props2.source_path);
  };
  return [plugin, code, type, source_path, rendermarkdown_plugin_binding];
}
var RenderExternalCodeblock = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance25, create_fragment25, safe_not_equal, {
      code: 1,
      type: 2,
      plugin: 0,
      source_path: 3
    });
  }
};
var RenderExternalCodeblock_default = RenderExternalCodeblock;

// src/components/selector/EdgeFieldSelector.svelte
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i].label;
  return child_ctx;
}
function create_each_block3(ctx) {
  let option;
  let t_value = (
    /*label*/
    ctx[5] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*label*/
      ctx[5];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*fields*/
      2 && t_value !== (t_value = /*label*/
      ctx2[5] + ""))
        set_data(t, t_value);
      if (dirty & /*fields*/
      2 && option_value_value !== (option_value_value = /*label*/
      ctx2[5])) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_fragment26(ctx) {
  let select;
  let option;
  let t;
  let select_value_value;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*fields*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  return {
    c() {
      select = element("select");
      option = element("option");
      t = text("Select Field");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      option.__value = void 0;
      set_input_value(option, option.__value);
      option.disabled = true;
      attr(select, "class", "dropdown");
    },
    m(target, anchor) {
      var _a;
      insert(target, select, anchor);
      append(select, option);
      append(option, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*field*/
        (_a = ctx[0]) == null ? void 0 : _a.label
      );
      if (!mounted) {
        dispose = listen(
          select,
          "change",
          /*change_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a, _b;
      if (dirty & /*fields*/
      2) {
        each_value = ensure_array_like(
          /*fields*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*field, fields, undefined*/
      3 && select_value_value !== (select_value_value = /*field*/
      (_a = ctx2[0]) == null ? void 0 : _a.label)) {
        select_option(
          select,
          /*field*/
          (_b = ctx2[0]) == null ? void 0 : _b.label
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(select);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance26($$self, $$props, $$invalidate) {
  let { fields } = $$props;
  let { undefine_on_change = true } = $$props;
  let { field = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  const change_handler = (e) => {
    $$invalidate(0, field = fields.find((field2) => field2.label === e.currentTarget.value));
    dispatch("select", field);
    if (undefine_on_change)
      $$invalidate(0, field = void 0);
  };
  $$self.$$set = ($$props2) => {
    if ("fields" in $$props2)
      $$invalidate(1, fields = $$props2.fields);
    if ("undefine_on_change" in $$props2)
      $$invalidate(2, undefine_on_change = $$props2.undefine_on_change);
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  return [field, fields, undefine_on_change, dispatch, change_handler];
}
var EdgeFieldSelector = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance26, create_fragment26, safe_not_equal, {
      fields: 1,
      undefine_on_change: 2,
      field: 0
    });
  }
};
var EdgeFieldSelector_default = EdgeFieldSelector;

// src/components/settings/TransitiveImpliedRelations.svelte
function add_css(target) {
  append_styles(target, "svelte-91sdw2", ".border.svelte-91sdw2{border-radius:var(--radius-m);border:var(--modal-border-width) solid\n			var(--background-modifier-border)}");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i].rule;
  child_ctx[26] = list[i].rule_i;
  child_ctx[27] = list[i].name;
  child_ctx[28] = list;
  child_ctx[29] = i;
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[30] = list[i];
  child_ctx[32] = i;
  return child_ctx;
}
function create_if_block_32(ctx) {
  let button;
  let arrowdown;
  let current;
  let mounted;
  let dispose;
  arrowdown = new arrow_down_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      button = element("button");
      create_component(arrowdown.$$.fragment);
      attr(button, "class", "w-10");
      attr(button, "aria-label", "Jump to bottom");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(arrowdown, button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_1*/
          ctx[9]
        );
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(arrowdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arrowdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(arrowdown);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_22(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Unsaved changes";
      attr(span, "class", "text-warning");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_else_block3(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "No fields in the chain.";
      attr(span, "class", "search-empty-state my-0");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_12(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value_1 = ensure_array_like(
    /*rule*/
    ctx[25].chain
  );
  const get_key = (ctx2) => {
    var _a;
    return (
      /*attr_i*/
      ctx2[32] + /*attr*/
      ((_a = ctx2[30].field) != null ? _a : "")
    );
  };
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_12(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_12(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "flex flex-wrap gap-3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*transitives, filter, context_menus*/
      76) {
        each_value_1 = ensure_array_like(
          /*rule*/
          ctx2[25].chain
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, div, outro_and_destroy_block, create_each_block_12, null, get_each_context_12);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function create_each_block_12(key_1, ctx) {
  var _a;
  let first;
  let tag;
  let current;
  tag = new tag_default({
    props: {
      tag: (
        /*attr*/
        (_a = ctx[30].field) != null ? _a : ""
      ),
      title: "Right click for more actions."
    }
  });
  tag.$on("contextmenu", function() {
    if (is_function(
      /*context_menus*/
      ctx[6].chain_field(
        /*rule_i*/
        ctx[26],
        /*attr_i*/
        ctx[32]
      )
    ))
      ctx[6].chain_field(
        /*rule_i*/
        ctx[26],
        /*attr_i*/
        ctx[32]
      ).apply(this, arguments);
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(tag.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(tag, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      const tag_changes = {};
      if (dirty[0] & /*transitives, filter*/
      12)
        tag_changes.tag = /*attr*/
        (_a2 = ctx[30].field) != null ? _a2 : "";
      tag.$set(tag_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tag.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tag.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(tag, detaching);
    }
  };
}
function create_if_block4(ctx) {
  let renderexternalcodeblock;
  let current;
  renderexternalcodeblock = new RenderExternalCodeblock_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      type: "mermaid",
      code: Mermaid.from_edges(transitive_rule_to_edges(
        /*rule*/
        ctx[25]
      ), {
        show_attributes: ["field"],
        collapse_opposing_edges: false
      })
    }
  });
  return {
    c() {
      create_component(renderexternalcodeblock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(renderexternalcodeblock, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const renderexternalcodeblock_changes = {};
      if (dirty[0] & /*plugin*/
      1)
        renderexternalcodeblock_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty[0] & /*transitives, filter*/
      12)
        renderexternalcodeblock_changes.code = Mermaid.from_edges(transitive_rule_to_edges(
          /*rule*/
          ctx2[25]
        ), {
          show_attributes: ["field"],
          collapse_opposing_edges: false
        });
      renderexternalcodeblock.$set(renderexternalcodeblock_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(renderexternalcodeblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(renderexternalcodeblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(renderexternalcodeblock, detaching);
    }
  };
}
function create_key_block2(ctx) {
  let div6;
  let div0;
  let span0;
  let t1;
  let current_block_type_index;
  let if_block0;
  let t2;
  let edgefieldselector0;
  let t3;
  let div1;
  let span1;
  let t5;
  let edgefieldselector1;
  let t6;
  let div2;
  let span2;
  let t8;
  let input0;
  let t9;
  let div3;
  let span3;
  let t11;
  let input1;
  let input1_min_value;
  let input1_max_value;
  let input1_value_value;
  let t12;
  let div5;
  let span4;
  let t14;
  let div4;
  let input2;
  let input2_value_value;
  let t15;
  let button;
  let t17;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_12, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*rule*/
      ctx2[25].chain.length
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function select_handler(...args) {
    return (
      /*select_handler*/
      ctx[16](
        /*rule_i*/
        ctx[26],
        ...args
      )
    );
  }
  edgefieldselector0 = new EdgeFieldSelector_default({
    props: { fields: (
      /*settings*/
      ctx[1].edge_fields
    ) }
  });
  edgefieldselector0.$on("select", select_handler);
  function func_2(...args) {
    return (
      /*func_2*/
      ctx[17](
        /*rule*/
        ctx[25],
        ...args
      )
    );
  }
  function select_handler_1(...args) {
    return (
      /*select_handler_1*/
      ctx[18](
        /*rule_i*/
        ctx[26],
        ...args
      )
    );
  }
  edgefieldselector1 = new EdgeFieldSelector_default({
    props: {
      undefine_on_change: false,
      fields: (
        /*settings*/
        ctx[1].edge_fields
      ),
      field: (
        /*settings*/
        ctx[1].edge_fields.find(func_2)
      )
    }
  });
  edgefieldselector1.$on("select", select_handler_1);
  function input0_change_handler() {
    ctx[19].call(
      input0,
      /*each_value*/
      ctx[28],
      /*each_index*/
      ctx[29]
    );
  }
  function click_handler_6(...args) {
    return (
      /*click_handler_6*/
      ctx[20](
        /*rule_i*/
        ctx[26],
        ...args
      )
    );
  }
  function blur_handler(...args) {
    return (
      /*blur_handler*/
      ctx[21](
        /*rule_i*/
        ctx[26],
        ...args
      )
    );
  }
  function blur_handler_1(...args) {
    return (
      /*blur_handler_1*/
      ctx[22](
        /*rule_i*/
        ctx[26],
        ...args
      )
    );
  }
  function click_handler_7() {
    return (
      /*click_handler_7*/
      ctx[23](
        /*rule_i*/
        ctx[26]
      )
    );
  }
  let if_block1 = (
    /*opens*/
    ctx[4][
      /*rule_i*/
      ctx[26]
    ] && create_if_block4(ctx)
  );
  return {
    c() {
      div6 = element("div");
      div0 = element("div");
      span0 = element("span");
      span0.textContent = "Edge Chain:";
      t1 = space();
      if_block0.c();
      t2 = space();
      create_component(edgefieldselector0.$$.fragment);
      t3 = space();
      div1 = element("div");
      span1 = element("span");
      span1.textContent = "Closing Field:";
      t5 = space();
      create_component(edgefieldselector1.$$.fragment);
      t6 = space();
      div2 = element("div");
      span2 = element("span");
      span2.textContent = "Close Reversed:";
      t8 = space();
      input0 = element("input");
      t9 = space();
      div3 = element("div");
      span3 = element("span");
      span3.textContent = "Rounds:";
      t11 = space();
      input1 = element("input");
      t12 = space();
      div5 = element("div");
      span4 = element("span");
      span4.textContent = "Name (optional):";
      t14 = space();
      div4 = element("div");
      input2 = element("input");
      t15 = space();
      button = element("button");
      button.textContent = "X";
      t17 = space();
      if (if_block1)
        if_block1.c();
      attr(span0, "class", "font-semibold");
      attr(div0, "class", "flex flex-wrap items-center gap-3");
      attr(span1, "class", "font-semibold");
      attr(span2, "class", "font-semibold");
      attr(input0, "type", "checkbox");
      attr(div2, "class", "flex items-center gap-2");
      attr(span3, "class", "font-semibold");
      attr(input1, "type", "number");
      attr(input1, "min", input1_min_value = 0);
      attr(input1, "max", input1_max_value = 100);
      input1.value = input1_value_value = /*rule*/
      ctx[25].rounds;
      attr(span4, "class", "font-semibold");
      attr(input2, "type", "text");
      input2.value = input2_value_value = /*rule*/
      ctx[25].name;
      attr(input2, "placeholder", "Rule Name");
      attr(button, "aria-label", "Reset Name");
      attr(div4, "class", "flex gap-1");
      attr(div5, "class", "flex flex-wrap items-center gap-3");
      attr(div6, "class", "my-2 flex flex-col gap-3 px-4 py-2");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div0);
      append(div0, span0);
      append(div0, t1);
      if_blocks[current_block_type_index].m(div0, null);
      append(div0, t2);
      mount_component(edgefieldselector0, div0, null);
      append(div6, t3);
      append(div6, div1);
      append(div1, span1);
      append(div1, t5);
      mount_component(edgefieldselector1, div1, null);
      append(div6, t6);
      append(div6, div2);
      append(div2, span2);
      append(div2, t8);
      append(div2, input0);
      input0.checked = /*rule*/
      ctx[25].close_reversed;
      append(div6, t9);
      append(div6, div3);
      append(div3, span3);
      append(div3, t11);
      append(div3, input1);
      append(div6, t12);
      append(div6, div5);
      append(div5, span4);
      append(div5, t14);
      append(div5, div4);
      append(div4, input2);
      append(div4, t15);
      append(div4, button);
      append(div6, t17);
      if (if_block1)
        if_block1.m(div6, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input0, "change", input0_change_handler),
          listen(input0, "click", click_handler_6),
          listen(input1, "blur", blur_handler),
          listen(input2, "blur", blur_handler_1),
          listen(button, "click", click_handler_7)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block0.c();
        } else {
          if_block0.p(ctx, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div0, t2);
      }
      const edgefieldselector0_changes = {};
      if (dirty[0] & /*settings*/
      2)
        edgefieldselector0_changes.fields = /*settings*/
        ctx[1].edge_fields;
      edgefieldselector0.$set(edgefieldselector0_changes);
      const edgefieldselector1_changes = {};
      if (dirty[0] & /*settings*/
      2)
        edgefieldselector1_changes.fields = /*settings*/
        ctx[1].edge_fields;
      if (dirty[0] & /*settings, transitives, filter*/
      14)
        edgefieldselector1_changes.field = /*settings*/
        ctx[1].edge_fields.find(func_2);
      edgefieldselector1.$set(edgefieldselector1_changes);
      if (dirty[0] & /*transitives, filter*/
      12) {
        input0.checked = /*rule*/
        ctx[25].close_reversed;
      }
      if (!current || dirty[0] & /*transitives, filter*/
      12 && input1_value_value !== (input1_value_value = /*rule*/
      ctx[25].rounds) && input1.value !== input1_value_value) {
        input1.value = input1_value_value;
      }
      if (!current || dirty[0] & /*transitives, filter*/
      12 && input2_value_value !== (input2_value_value = /*rule*/
      ctx[25].name) && input2.value !== input2_value_value) {
        input2.value = input2_value_value;
      }
      if (
        /*opens*/
        ctx[4][
          /*rule_i*/
          ctx[26]
        ]
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty[0] & /*opens, transitives, filter*/
          28) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block4(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div6, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(edgefieldselector0.$$.fragment, local);
      transition_in(edgefieldselector1.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(edgefieldselector0.$$.fragment, local);
      transition_out(edgefieldselector1.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      if_blocks[current_block_type_index].d();
      destroy_component(edgefieldselector0);
      destroy_component(edgefieldselector1);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block4(key_1, ctx) {
  let details;
  let summary;
  let div0;
  let chevronopener;
  let t0;
  let code;
  let t1_value = (
    /*name*/
    ctx[27] + ""
  );
  let t1;
  let t2;
  let div1;
  let button0;
  let arrowup;
  let button0_disabled_value;
  let t3;
  let button1;
  let arrowdown;
  let button1_disabled_value;
  let t4;
  let button2;
  let clipboardicon;
  let t5;
  let button3;
  let t7;
  let previous_key = (
    /*rule*/
    ctx[25]
  );
  let details_id_value;
  let current;
  let mounted;
  let dispose;
  chevronopener = new ChevronOpener_default({
    props: {
      open: (
        /*opens*/
        ctx[4][
          /*rule_i*/
          ctx[26]
        ]
      )
    }
  });
  arrowup = new arrow_up_default({ props: { size: ICON_SIZE } });
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[12](
        /*rule_i*/
        ctx[26]
      )
    );
  }
  arrowdown = new arrow_down_default({ props: { size: ICON_SIZE } });
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[13](
        /*rule_i*/
        ctx[26]
      )
    );
  }
  clipboardicon = new clipboard_default({ props: { size: ICON_SIZE } });
  function click_handler_4() {
    return (
      /*click_handler_4*/
      ctx[14](
        /*rule_i*/
        ctx[26]
      )
    );
  }
  function click_handler_5() {
    return (
      /*click_handler_5*/
      ctx[15](
        /*rule_i*/
        ctx[26]
      )
    );
  }
  let key_block = create_key_block2(ctx);
  function details_toggle_handler() {
    ctx[24].call(
      details,
      /*rule_i*/
      ctx[26]
    );
  }
  return {
    key: key_1,
    first: null,
    c() {
      details = element("details");
      summary = element("summary");
      div0 = element("div");
      create_component(chevronopener.$$.fragment);
      t0 = space();
      code = element("code");
      t1 = text(t1_value);
      t2 = space();
      div1 = element("div");
      button0 = element("button");
      create_component(arrowup.$$.fragment);
      t3 = space();
      button1 = element("button");
      create_component(arrowdown.$$.fragment);
      t4 = space();
      button2 = element("button");
      create_component(clipboardicon.$$.fragment);
      t5 = space();
      button3 = element("button");
      button3.textContent = "X";
      t7 = space();
      key_block.c();
      attr(div0, "class", "flex items-center gap-2");
      button0.disabled = button0_disabled_value = /*rule_i*/
      ctx[26] === 0;
      button1.disabled = button1_disabled_value = /*rule_i*/
      ctx[26] === /*transitives*/
      ctx[3].length - 1;
      attr(button2, "aria-label", "Copy Transitive Implied Relation");
      attr(button3, "aria-label", "Delete Transitive Implied Relation");
      attr(div1, "class", "flex gap-1");
      attr(summary, "class", "flex items-center justify-between gap-2");
      attr(details, "id", details_id_value = /*actions*/
      ctx[5].make_id(
        /*rule_i*/
        ctx[26]
      ));
      attr(details, "class", "scroll-mt-40 border p-2 svelte-91sdw2");
      this.first = details;
    },
    m(target, anchor) {
      insert(target, details, anchor);
      append(details, summary);
      append(summary, div0);
      mount_component(chevronopener, div0, null);
      append(div0, t0);
      append(div0, code);
      append(code, t1);
      append(summary, t2);
      append(summary, div1);
      append(div1, button0);
      mount_component(arrowup, button0, null);
      append(div1, t3);
      append(div1, button1);
      mount_component(arrowdown, button1, null);
      append(div1, t4);
      append(div1, button2);
      mount_component(clipboardicon, button2, null);
      append(div1, t5);
      append(div1, button3);
      append(details, t7);
      key_block.m(details, null);
      details.open = /*opens*/
      ctx[4][
        /*rule_i*/
        ctx[26]
      ];
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", click_handler_2),
          listen(button1, "click", click_handler_3),
          listen(button2, "click", click_handler_4),
          listen(button3, "click", click_handler_5),
          listen(details, "toggle", details_toggle_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const chevronopener_changes = {};
      if (dirty[0] & /*opens, transitives, filter*/
      28)
        chevronopener_changes.open = /*opens*/
        ctx[4][
          /*rule_i*/
          ctx[26]
        ];
      chevronopener.$set(chevronopener_changes);
      if ((!current || dirty[0] & /*transitives, filter*/
      12) && t1_value !== (t1_value = /*name*/
      ctx[27] + ""))
        set_data(t1, t1_value);
      if (!current || dirty[0] & /*transitives, filter*/
      12 && button0_disabled_value !== (button0_disabled_value = /*rule_i*/
      ctx[26] === 0)) {
        button0.disabled = button0_disabled_value;
      }
      if (!current || dirty[0] & /*transitives, filter*/
      12 && button1_disabled_value !== (button1_disabled_value = /*rule_i*/
      ctx[26] === /*transitives*/
      ctx[3].length - 1)) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty[0] & /*transitives, filter*/
      12 && safe_not_equal(previous_key, previous_key = /*rule*/
      ctx[25])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block2(ctx);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(details, null);
      } else {
        key_block.p(ctx, dirty);
      }
      if (!current || dirty[0] & /*transitives, filter*/
      12 && details_id_value !== (details_id_value = /*actions*/
      ctx[5].make_id(
        /*rule_i*/
        ctx[26]
      ))) {
        attr(details, "id", details_id_value);
      }
      if (dirty[0] & /*opens, transitives, filter*/
      28) {
        details.open = /*opens*/
        ctx[4][
          /*rule_i*/
          ctx[26]
        ];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(chevronopener.$$.fragment, local);
      transition_in(arrowup.$$.fragment, local);
      transition_in(arrowdown.$$.fragment, local);
      transition_in(clipboardicon.$$.fragment, local);
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(chevronopener.$$.fragment, local);
      transition_out(arrowup.$$.fragment, local);
      transition_out(arrowdown.$$.fragment, local);
      transition_out(clipboardicon.$$.fragment, local);
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(details);
      }
      destroy_component(chevronopener);
      destroy_component(arrowup);
      destroy_component(arrowdown);
      destroy_component(clipboardicon);
      key_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment27(ctx) {
  let div4;
  let p0;
  let t0;
  let em;
  let t2;
  let code0;
  let t5;
  let t6;
  let div1;
  let button0;
  let saveicon;
  let t7;
  let t8;
  let div0;
  let input;
  let t9;
  let button1;
  let t10;
  let button1_disabled_value;
  let t11;
  let t12;
  let t13;
  let div3;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t14;
  let button2;
  let plusicon;
  let t15;
  let t16;
  let details;
  let summary;
  let t18;
  let div2;
  let p1;
  let t22;
  let textarea;
  let t23;
  let button3;
  let current;
  let mounted;
  let dispose;
  saveicon = new save_default({ props: { size: ICON_SIZE } });
  let if_block0 = (
    /*transitives*/
    ctx[3].length > 3 && create_if_block_32(ctx)
  );
  let if_block1 = (
    /*settings*/
    ctx[1].is_dirty && create_if_block_22(ctx)
  );
  let each_value = ensure_array_like(
    /*transitives*/
    ctx[3].map(
      /*func*/
      ctx[10]
    ).filter(
      /*func_1*/
      ctx[11]
    )
  );
  const get_key = (ctx2) => (
    /*name*/
    ctx2[27] + /*rule_i*/
    ctx2[26]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context4(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block4(key, child_ctx));
  }
  plusicon = new plus_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      div4 = element("div");
      p0 = element("p");
      t0 = text("Transitive implied relations represent ");
      em = element("em");
      em.textContent = "chains";
      t2 = text(' of your\n		Breadcrumbs fields that collapse into a single field. For example, if\n		you have the fields: "spouse", "sibling", and "sibling-in-law", you can\n		add the transitive chain\n		');
      code0 = element("code");
      code0.textContent = `${stringify_transitive_relation({
        close_reversed: false,
        close_field: "sibling-in-law",
        chain: [{ field: "spouse" }, { field: "sibling" }]
      })} `;
      t5 = text(". In other words, your spouse's sibling is your sibling-in-law.");
      t6 = space();
      div1 = element("div");
      button0 = element("button");
      create_component(saveicon.$$.fragment);
      t7 = text("\n			Save");
      t8 = space();
      div0 = element("div");
      input = element("input");
      t9 = space();
      button1 = element("button");
      t10 = text("X");
      t11 = space();
      if (if_block0)
        if_block0.c();
      t12 = space();
      if (if_block1)
        if_block1.c();
      t13 = space();
      div3 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t14 = space();
      button2 = element("button");
      create_component(plusicon.$$.fragment);
      t15 = text("\n			Add New Transitive Implied Relation");
      t16 = space();
      details = element("details");
      summary = element("summary");
      summary.textContent = "Bulk Add Rules (Advanced)";
      t18 = space();
      div2 = element("div");
      p1 = element("p");
      p1.innerHTML = `Quickly add multiple rules using the shorthand syntax: <code>[field-one, field-two] -&gt; close-field
					</code>. Each rule should be on a new line.`;
      t22 = space();
      textarea = element("textarea");
      t23 = space();
      button3 = element("button");
      button3.textContent = "Bulk Add";
      attr(button0, "class", "flex items-center gap-1");
      attr(input, "type", "text");
      attr(input, "placeholder", "Filter Rules by Name");
      attr(button1, "class", "w-8");
      attr(button1, "aria-label", "Clear Filter");
      button1.disabled = button1_disabled_value = /*filter*/
      ctx[2] === "";
      attr(div0, "class", "flex gap-1");
      attr(div1, "class", "my-2 flex items-center gap-2");
      attr(button2, "class", "flex items-center gap-1");
      attr(textarea, "id", "BC-transitive-bulk-str");
      attr(textarea, "class", "h-32 w-60");
      attr(textarea, "placeholder", "[up] <- down");
      attr(button3, "class", "w-60");
      attr(div2, "class", "flex flex-col gap-1");
      attr(div3, "class", "flex flex-col gap-3");
      attr(div4, "class", "BC-custom-transitive-implied-relations");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, p0);
      append(p0, t0);
      append(p0, em);
      append(p0, t2);
      append(p0, code0);
      append(p0, t5);
      append(div4, t6);
      append(div4, div1);
      append(div1, button0);
      mount_component(saveicon, button0, null);
      append(button0, t7);
      append(div1, t8);
      append(div1, div0);
      append(div0, input);
      set_input_value(
        input,
        /*filter*/
        ctx[2]
      );
      append(div0, t9);
      append(div0, button1);
      append(button1, t10);
      append(div1, t11);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t12);
      if (if_block1)
        if_block1.m(div1, null);
      append(div4, t13);
      append(div4, div3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div3, null);
        }
      }
      append(div3, t14);
      append(div3, button2);
      mount_component(plusicon, button2, null);
      append(button2, t15);
      append(div3, t16);
      append(div3, details);
      append(details, summary);
      append(details, t18);
      append(details, div2);
      append(div2, p1);
      append(div2, t22);
      append(div2, textarea);
      append(div2, t23);
      append(div2, button3);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*actions*/
            ctx[5].save
          ),
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[7]
          ),
          listen(
            button1,
            "click",
            /*click_handler*/
            ctx[8]
          ),
          listen(
            button2,
            "click",
            /*actions*/
            ctx[5].add_transitive
          ),
          listen(
            button3,
            "click",
            /*actions*/
            ctx[5].add_bulk
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*filter*/
      4 && input.value !== /*filter*/
      ctx2[2]) {
        set_input_value(
          input,
          /*filter*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*filter*/
      4 && button1_disabled_value !== (button1_disabled_value = /*filter*/
      ctx2[2] === "")) {
        button1.disabled = button1_disabled_value;
      }
      if (
        /*transitives*/
        ctx2[3].length > 3
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*transitives*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_32(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t12);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*settings*/
        ctx2[1].is_dirty
      ) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block_22(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & /*actions, transitives, filter, opens, plugin, settings, context_menus*/
      127) {
        each_value = ensure_array_like(
          /*transitives*/
          ctx2[3].map(
            /*func*/
            ctx2[10]
          ).filter(
            /*func_1*/
            ctx2[11]
          )
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div3, outro_and_destroy_block, create_each_block4, t14, get_each_context4);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(saveicon.$$.fragment, local);
      transition_in(if_block0);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(plusicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(saveicon.$$.fragment, local);
      transition_out(if_block0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(plusicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      destroy_component(saveicon);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      destroy_component(plusicon);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance27($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  const settings = plugin.settings;
  let filter = "";
  let transitives = [...settings.implied_relations.transitive];
  const opens = transitives.map(() => false);
  const actions = {
    save: () => __awaiter(void 0, void 0, void 0, function* () {
      for (const { close_field } of transitives) {
        if (!close_field) {
          return new import_obsidian10.Notice("Closing field cannot be empty.");
        }
      }
      $$invalidate(1, settings.implied_relations.transitive = transitives, settings);
      yield Promise.all([plugin.saveSettings(), plugin.refresh({ redraw_side_views: true })]);
      $$invalidate(0, plugin);
    }),
    make_id: (rule_i) => `BC-transitive-rule-${rule_i}`,
    scroll_to: (rule_i) => {
      var _a;
      return (_a = document.getElementById(actions.make_id(rule_i))) === null || _a === void 0 ? void 0 : _a.scrollIntoView({ behavior: "smooth" });
    },
    add_transitive: () => {
      const new_length = transitives.push({
        name: "",
        chain: [],
        // NOTE: Max by default, users can lower if needed
        // It seems to fit with intuition that the implied relations just keep going
        rounds: 10,
        close_reversed: false,
        close_field: settings.edge_fields[0].label
      });
      $$invalidate(4, opens[new_length - 1] = true, opens);
      setTimeout(() => actions.scroll_to(new_length - 1), 0);
      $$invalidate(3, transitives);
      $$invalidate(1, settings.is_dirty = true, settings);
    },
    add_bulk: () => {
      const textarea = document.getElementById("BC-transitive-bulk-str");
      if (!textarea)
        return new import_obsidian10.Notice("Could not find textarea.");
      const value = textarea.value.trim();
      if (!value)
        return new import_obsidian10.Notice("No rules to parse.");
      const lines = split_and_trim(value, "\n").filter(Boolean);
      const parsed = lines.map(parse_transitive_relation).filter((r) => r.ok);
      if (parsed.length !== lines.length) {
        return new import_obsidian10.Notice("Some rules could not be parsed. Ensure you're using the correct syntax of `[field-one, field-two] -> close-field`, with each rule of a new line.");
      }
      const validated = parsed.map((r) => input_transitive_rule_schema({ fields: plugin.settings.edge_fields }).safeParse(r.data));
      const validation_errors = validated.filter((r) => !r.success);
      if (validation_errors.length) {
        log.error("Bulk-add transitive rule errors >", validation_errors.map((r) => {
          var _a;
          return r.success ? null : (_a = r.error) === null || _a === void 0 ? void 0 : _a.issues;
        }));
        return new import_obsidian10.Notice("Some rules could not be parsed. Check the logs for more information.");
      }
      validated.forEach((r) => {
        if (r.success) {
          transitives.push(Object.assign(Object.assign({}, r.data), { name: "", rounds: 10 }));
        }
      });
      new import_obsidian10.Notice(`Bulk added ${validated.length} rules \u2705`);
      $$invalidate(3, transitives);
      $$invalidate(1, settings.is_dirty = true, settings);
    },
    copy_transitive: (i) => {
      const new_length = transitives.push(Object.assign(Object.assign({}, transitives[i]), {
        name: `${get_transitive_rule_name(transitives[i])} (copy)`
      }));
      $$invalidate(4, opens[new_length - 1] = true, opens);
      setTimeout(() => actions.scroll_to(new_length - 1), 0);
      $$invalidate(3, transitives);
      $$invalidate(1, settings.is_dirty = true, settings);
    },
    remove_transitive: (i) => {
      $$invalidate(3, transitives = transitives.filter((_, j) => j !== i));
      $$invalidate(1, settings.is_dirty = true, settings);
    },
    rename_transitive: (i, new_name) => {
      if (transitives[i].name === new_name)
        return;
      $$invalidate(3, transitives[i].name = new_name, transitives);
      $$invalidate(3, transitives);
      $$invalidate(1, settings.is_dirty = true, settings);
    },
    reorder_transitive: (i, j) => {
      const temp = transitives[i];
      $$invalidate(3, transitives[i] = transitives[j], transitives);
      $$invalidate(3, transitives[j] = temp, transitives);
      $$invalidate(3, transitives);
      $$invalidate(1, settings.is_dirty = true, settings);
    },
    add_chain_field: (i, field) => {
      if (!field)
        return;
      transitives[i].chain.push({ field: field.label });
      $$invalidate(3, transitives);
      $$invalidate(1, settings.is_dirty = true, settings);
    },
    remove_chain_field: (i, j) => {
      $$invalidate(3, transitives[i].chain = transitives[i].chain.filter((_, k) => k !== j), transitives);
      $$invalidate(3, transitives);
      $$invalidate(1, settings.is_dirty = true, settings);
    },
    set_close_field: (i, field) => {
      if (!field)
        return;
      $$invalidate(3, transitives[i].close_field = field.label, transitives);
      $$invalidate(3, transitives);
      $$invalidate(1, settings.is_dirty = true, settings);
    },
    set_rounds: (i, rounds) => {
      if (isNaN(rounds) || rounds < 0)
        return;
      $$invalidate(3, transitives[i].rounds = rounds, transitives);
      $$invalidate(3, transitives);
      $$invalidate(1, settings.is_dirty = true, settings);
    },
    set_close_reversed: (i, reversed) => {
      $$invalidate(3, transitives[i].close_reversed = reversed, transitives);
      $$invalidate(3, transitives);
      $$invalidate(1, settings.is_dirty = true, settings);
    }
  };
  const context_menus = {
    chain_field: (rule_i, attr_i) => (e) => {
      const menu = new import_obsidian10.Menu();
      menu.addItem((item) => item.setTitle("Remove Field").setIcon("x").onClick(() => actions.remove_chain_field(rule_i, attr_i)));
      menu.showAtMouseEvent(e);
    }
  };
  function input_input_handler() {
    filter = this.value;
    $$invalidate(2, filter);
  }
  const click_handler = () => $$invalidate(2, filter = "");
  const click_handler_1 = () => actions.scroll_to(transitives.length - 1);
  const func = (rule, rule_i) => ({
    rule,
    rule_i,
    name: get_transitive_rule_name(rule)
  });
  const func_1 = (r) => r.name.includes(filter.toLowerCase());
  const click_handler_2 = (rule_i) => actions.reorder_transitive(rule_i, rule_i - 1);
  const click_handler_3 = (rule_i) => actions.reorder_transitive(rule_i, rule_i + 1);
  const click_handler_4 = (rule_i) => actions.copy_transitive(rule_i);
  const click_handler_5 = (rule_i) => actions.remove_transitive(rule_i);
  const select_handler = (rule_i, e) => actions.add_chain_field(rule_i, e.detail);
  const func_2 = (rule, f) => f.label === rule.close_field;
  const select_handler_1 = (rule_i, e) => actions.set_close_field(rule_i, e.detail);
  function input0_change_handler(each_value, each_index) {
    each_value[each_index].rule.close_reversed = this.checked;
    $$invalidate(3, transitives);
    $$invalidate(2, filter);
  }
  const click_handler_6 = (rule_i, e) => actions.set_close_reversed(rule_i, e.currentTarget.checked);
  const blur_handler = (rule_i, e) => actions.set_rounds(rule_i, +e.currentTarget.value);
  const blur_handler_1 = (rule_i, e) => actions.rename_transitive(rule_i, e.currentTarget.value);
  const click_handler_7 = (rule_i) => actions.rename_transitive(rule_i, "");
  function details_toggle_handler(rule_i) {
    opens[rule_i] = this.open;
    $$invalidate(4, opens);
  }
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  return [
    plugin,
    settings,
    filter,
    transitives,
    opens,
    actions,
    context_menus,
    input_input_handler,
    click_handler,
    click_handler_1,
    func,
    func_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    select_handler,
    func_2,
    select_handler_1,
    input0_change_handler,
    click_handler_6,
    blur_handler,
    blur_handler_1,
    click_handler_7,
    details_toggle_handler
  ];
}
var TransitiveImpliedRelations = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance27, create_fragment27, safe_not_equal, { plugin: 0 }, add_css, [-1, -1]);
  }
};
var TransitiveImpliedRelations_default = TransitiveImpliedRelations;

// src/settings/ShowNodeOptions.ts
var import_obsidian11 = require("obsidian");
var _add_settings_show_node_options = (plugin, containerEl, cb, options) => {
  let show_node_options = cb.get();
  const setting = new import_obsidian11.Setting(containerEl).setName("Note display options").setDesc("How to display note links");
  setting.controlEl.addClasses(["flex", "flex-wrap", "gap-2"]);
  setting.addToggle((toggle) => {
    toggle.toggleEl.before("Folder");
    toggle.setTooltip("Folder path").setValue(show_node_options.folder).onChange(async (value) => {
      show_node_options.folder = value;
      cb.set(show_node_options);
      if ((options == null ? void 0 : options.save_and_refresh) !== false) {
        await Promise.all([plugin.saveSettings()]);
        plugin.refresh({ rebuild_graph: false });
      }
    });
  });
  setting.addToggle((toggle) => {
    toggle.toggleEl.before("Extension");
    toggle.setTooltip("File extension").setValue(show_node_options.ext).onChange(async (value) => {
      show_node_options.ext = value;
      cb.set(show_node_options);
      if ((options == null ? void 0 : options.save_and_refresh) !== false) {
        await Promise.all([plugin.saveSettings()]);
        plugin.refresh({ rebuild_graph: false });
      }
    });
  });
  setting.addToggle((toggle) => {
    toggle.toggleEl.before("Alias");
    toggle.setTooltip("Alias (first alias, if available)").setValue(show_node_options.alias).onChange(async (value) => {
      show_node_options.alias = value;
      cb.set(show_node_options);
      if ((options == null ? void 0 : options.save_and_refresh) !== false) {
        await Promise.all([plugin.saveSettings()]);
        plugin.refresh({ rebuild_graph: false });
      }
    });
  });
  return setting;
};

// src/settings/CodeblockSettings.ts
var _add_settings_codeblocks = (plugin, containerEl) => {
  _add_settings_show_node_options(plugin, containerEl, {
    get: () => plugin.settings.views.codeblocks.show_node_options,
    set: (value) => plugin.settings.views.codeblocks.show_node_options = value
  });
};

// src/settings/DateNoteSettings.ts
var import_obsidian13 = require("obsidian");

// src/utils/settings.ts
var import_obsidian12 = require("obsidian");
var new_setting = (container_el, config) => {
  const setting = new import_obsidian12.Setting(container_el);
  if (config.name)
    setting.setName(config.name);
  if (config.desc)
    setting.setDesc(config.desc);
  if (config.toggle) {
    setting.addToggle((toggle) => {
      toggle.setValue(config.toggle.value).onChange(config.toggle.cb);
    });
  } else if (config.input) {
    setting.addText((text2) => {
      var _a;
      if ((_a = config.input) == null ? void 0 : _a.placeholder) {
        text2.setPlaceholder(config.input.placeholder);
      }
      text2.setValue(config.input.value);
      text2.inputEl.onblur = () => {
        config.input.cb(text2.getValue());
      };
    });
  } else if (config.select) {
    setting.addDropdown((dropdown) => {
      const options = Array.isArray(config.select.options) ? config.select.options.reduce(
        (acc, option) => {
          acc[option] = option;
          return acc;
        },
        {}
      ) : config.select.options;
      dropdown.addOptions(options).setValue(config.select.value).onChange(config.select.cb);
    });
  } else if (config.checklist) {
    const checklist_el = setting.controlEl.createEl("div", {
      attr: { class: "flex flex-wrap gap-3" }
    });
    let state = { ...config.checklist.options };
    Object.keys(config.checklist.options).forEach((key) => {
      const attr2 = { type: "checkbox" };
      if (config.checklist.options[key])
        attr2.checked = true;
      checklist_el.createEl("label", {
        text: key,
        cls: "flex items-center gap-1.5 grow"
      }).createEl("input", { attr: attr2 }, (el) => {
        el.classList.add("shrink");
        el.onchange = (e) => {
          if (!(e.target instanceof HTMLInputElement))
            return;
          state[key] = e.target.checked;
          config.checklist.cb(state);
        };
      });
    });
  }
  return setting;
};

// src/settings/DateNoteSettings.ts
var _add_settings_date_note = (plugin, containerEl) => {
  new_setting(containerEl, {
    name: "Enabled",
    desc: "Look for date notes to use as edge sources",
    toggle: {
      value: plugin.settings.explicit_edge_sources.date_note.enabled,
      cb: async (value) => {
        plugin.settings.explicit_edge_sources.date_note.enabled = value;
        await Promise.all([plugin.refresh(), plugin.saveSettings()]);
      }
    }
  });
  new_setting(containerEl, {
    name: "Default Field",
    desc: "Field used to join date notes together. Breadcrumbs takes the current note's date, adds one day, and joins the two notes with this field.",
    select: {
      value: plugin.settings.explicit_edge_sources.date_note.default_field,
      options: plugin.settings.edge_fields.map((f) => f.label),
      cb: async (value) => {
        plugin.settings.explicit_edge_sources.date_note.default_field = value;
        await Promise.all([plugin.refresh(), plugin.saveSettings()]);
      }
    }
  });
  const date_format_fragment = new DocumentFragment();
  date_format_fragment.createEl(
    "span",
    {},
    (el) => el.innerHTML = `<a href="https://moment.github.io/luxon/#/formatting?id=table-of-tokens">Luxon date format</a> to use`
  );
  new_setting(containerEl, {
    name: "Date Format",
    desc: date_format_fragment,
    input: {
      value: plugin.settings.explicit_edge_sources.date_note.date_format,
      cb: async (value) => {
        if (!value)
          new import_obsidian13.Notice("Date format cannot be empty");
        else {
          plugin.settings.explicit_edge_sources.date_note.date_format = value;
          await Promise.all([
            plugin.refresh(),
            plugin.saveSettings()
          ]);
        }
      }
    }
  });
  new_setting(containerEl, {
    name: "Stretch to Existing",
    desc: "If there is a gap from one day to another, should the next note be the unresolved one in one day or should it 'stretch' to the next resolved (existing) note?",
    toggle: {
      value: plugin.settings.explicit_edge_sources.date_note.stretch_to_existing,
      cb: async (value) => {
        plugin.settings.explicit_edge_sources.date_note.stretch_to_existing = value;
        await Promise.all([plugin.refresh(), plugin.saveSettings()]);
      }
    }
  });
};

// src/settings/DebugSettings.ts
var _add_settings_debug = (plugin, containerEl) => {
  new_setting(containerEl, {
    name: "Debug Level",
    desc: "Set the level of debug logging",
    select: {
      options: LOG_LEVELS,
      value: plugin.settings.debug.level,
      cb: async (value) => {
        log.set_level(value);
        plugin.settings.debug.level = value;
        await plugin.saveSettings();
      }
    }
  });
};

// src/settings/DendronNoteSettings.ts
var import_obsidian14 = require("obsidian");
var _add_settings_dendron_note = (plugin, containerEl) => {
  new_setting(containerEl, {
    name: "Enabled",
    desc: "Look for dendron notes to use as edge sources",
    toggle: {
      value: plugin.settings.explicit_edge_sources.dendron_note.enabled,
      cb: async (value) => {
        plugin.settings.explicit_edge_sources.dendron_note.enabled = value;
        await Promise.all([plugin.refresh(), plugin.saveSettings()]);
      }
    }
  });
  new_setting(containerEl, {
    name: "Delimiter",
    desc: "Delimiter to use to split the note name",
    input: {
      value: plugin.settings.explicit_edge_sources.dendron_note.delimiter,
      cb: async (value) => {
        if (!value)
          new import_obsidian14.Notice("Delimiter cannot be empty");
        else {
          plugin.settings.explicit_edge_sources.dendron_note.delimiter = value;
          await Promise.all([
            plugin.refresh(),
            plugin.saveSettings()
          ]);
        }
      }
    }
  });
  new_setting(containerEl, {
    name: "Default Field",
    desc: "Field to use if the BC-dendron-note-field is not specified",
    select: {
      value: plugin.settings.explicit_edge_sources.dendron_note.default_field,
      options: plugin.settings.edge_fields.map((f) => f.label),
      cb: async (value) => {
        plugin.settings.explicit_edge_sources.dendron_note.default_field = value;
        await Promise.all([plugin.refresh(), plugin.saveSettings()]);
      }
    }
  });
  new_setting(containerEl, {
    name: "Display Trimmed",
    desc: "Display Dendron note names as the right-most split of the delimiter. e.g. `a.b.c` -> `c`",
    toggle: {
      value: plugin.settings.explicit_edge_sources.dendron_note.display_trimmed,
      cb: async (value) => {
        plugin.settings.explicit_edge_sources.dendron_note.display_trimmed = value;
        await Promise.all([plugin.refresh(), plugin.saveSettings()]);
      }
    }
  });
};

// src/settings/EdgeFieldSuggestorSettings.ts
var import_obsidian15 = require("obsidian");
var _add_settings_edge_field_suggestor = (plugin, contentEl) => {
  const { settings } = plugin;
  new_setting(contentEl, {
    name: "Enabled",
    desc: "Whether to enable the edge field suggestor",
    toggle: {
      value: settings.suggestors.edge_field.enabled,
      cb: async (value) => {
        settings.suggestors.edge_field.enabled = value;
        if (value) {
          new import_obsidian15.Notice(
            "Please restart Obsidian for the changes to take effect"
          );
        }
        await plugin.saveSettings();
      }
    }
  });
  new_setting(contentEl, {
    name: "Trigger String",
    desc: "The string that triggers the suggestor (when entered at the start of a line)",
    input: {
      value: settings.suggestors.edge_field.trigger,
      cb: async (value) => {
        if (!value) {
          new import_obsidian15.Notice("Trigger string cannot be empty");
          return;
        }
        settings.suggestors.edge_field.trigger = value;
        await plugin.saveSettings();
      }
    }
  });
};

// src/settings/FreezeImpliedEdgesSettings.ts
var _add_settings_freeze_implied_edges = (plugin, contentEl) => {
  const { settings } = plugin;
  new_setting(contentEl, {
    name: "Destination",
    desc: "Where to write the frozen edges to",
    select: {
      options: ["frontmatter", "dataview-inline"],
      value: settings.commands.freeze_implied_edges.default_options.destination,
      cb: async (value) => {
        settings.commands.freeze_implied_edges.default_options.destination = value;
        await plugin.saveSettings();
      }
    }
  });
};

// src/settings/GridSettings.ts
var import_obsidian17 = require("obsidian");

// src/menus/FieldGroupsSelector.ts
var import_obsidian16 = require("obsidian");
var FieldGroupsSelectorMenu = ({
  cb,
  value,
  edge_field_groups
}) => {
  const menu = new import_obsidian16.Menu();
  const checks = edge_field_groups.map(
    (group) => value.includes(group.label)
  );
  const all_checked = checks.every((check) => check);
  menu.addItem(
    (item) => item.setTitle(all_checked ? "None" : "All").onClick(() => {
      value = all_checked ? [] : edge_field_groups.map((group) => group.label);
      cb(value);
    })
  );
  menu.addSeparator();
  edge_field_groups.forEach((group, group_i) => {
    const checked = checks[group_i];
    menu.addItem(
      (item) => item.setTitle(group.label).setChecked(checked).onClick(() => {
        if (checked) {
          value = value.filter((label) => label !== group.label);
        } else {
          value.push(group.label);
        }
        cb(value);
      })
    );
  });
  return menu;
};

// src/components/selector/FieldGroupLabelsSelector.svelte
function create_fragment28(ctx) {
  let button;
  let groupicon;
  let current;
  let mounted;
  let dispose;
  groupicon = new group_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      button = element("button");
      create_component(groupicon.$$.fragment);
      attr(
        button,
        "class",
        /*cls*/
        ctx[1]
      );
      attr(button, "aria-label", "Choose edge field groups");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(groupicon, button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*cls*/
      2) {
        attr(
          button,
          "class",
          /*cls*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(groupicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(groupicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(groupicon);
      mounted = false;
      dispose();
    }
  };
}
function instance28($$self, $$props, $$invalidate) {
  let { cls = "" } = $$props;
  let { field_group_labels } = $$props;
  let { edge_field_groups } = $$props;
  const click_handler = (e) => {
    FieldGroupsSelectorMenu({
      edge_field_groups,
      value: field_group_labels,
      cb: (value) => $$invalidate(0, field_group_labels = value)
    }).showAtMouseEvent(e);
  };
  $$self.$$set = ($$props2) => {
    if ("cls" in $$props2)
      $$invalidate(1, cls = $$props2.cls);
    if ("field_group_labels" in $$props2)
      $$invalidate(0, field_group_labels = $$props2.field_group_labels);
    if ("edge_field_groups" in $$props2)
      $$invalidate(2, edge_field_groups = $$props2.edge_field_groups);
  };
  return [field_group_labels, cls, edge_field_groups, click_handler];
}
var FieldGroupLabelsSelector = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance28, create_fragment28, safe_not_equal, {
      cls: 1,
      field_group_labels: 0,
      edge_field_groups: 2
    });
  }
};
var FieldGroupLabelsSelector_default = FieldGroupLabelsSelector;

// src/components/settings/SettingItem.svelte
function create_fragment29(ctx) {
  let div4;
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let div3;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(
        /*name*/
        ctx[0]
      );
      t1 = space();
      div1 = element("div");
      t2 = text(
        /*description*/
        ctx[1]
      );
      t3 = space();
      div3 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "setting-item-name");
      attr(div1, "class", "setting-item-description");
      attr(div2, "class", "setting-item-info");
      attr(div3, "class", "setting-item-control");
      attr(div4, "class", "setting-item");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      append(div4, t3);
      append(div4, div3);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*name*/
      1)
        set_data(
          t0,
          /*name*/
          ctx2[0]
        );
      if (!current || dirty & /*description*/
      2)
        set_data(
          t2,
          /*description*/
          ctx2[1]
        );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance29($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name } = $$props;
  let { description } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [name, description, $$scope, slots];
}
var SettingItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance29, create_fragment29, safe_not_equal, { name: 0, description: 1 });
  }
};
var SettingItem_default = SettingItem;

// src/components/settings/FieldGroupLabelsSettingItem.svelte
function create_default_slot20(ctx) {
  let fieldgrouplabelsselector;
  let updating_field_group_labels;
  let current;
  function fieldgrouplabelsselector_field_group_labels_binding(value) {
    ctx[4](value);
  }
  let fieldgrouplabelsselector_props = {
    edge_field_groups: (
      /*edge_field_groups*/
      ctx[3]
    )
  };
  if (
    /*field_group_labels*/
    ctx[0] !== void 0
  ) {
    fieldgrouplabelsselector_props.field_group_labels = /*field_group_labels*/
    ctx[0];
  }
  fieldgrouplabelsselector = new FieldGroupLabelsSelector_default({ props: fieldgrouplabelsselector_props });
  binding_callbacks.push(() => bind(fieldgrouplabelsselector, "field_group_labels", fieldgrouplabelsselector_field_group_labels_binding));
  return {
    c() {
      create_component(fieldgrouplabelsselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fieldgrouplabelsselector, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const fieldgrouplabelsselector_changes = {};
      if (dirty & /*edge_field_groups*/
      8)
        fieldgrouplabelsselector_changes.edge_field_groups = /*edge_field_groups*/
        ctx2[3];
      if (!updating_field_group_labels && dirty & /*field_group_labels*/
      1) {
        updating_field_group_labels = true;
        fieldgrouplabelsselector_changes.field_group_labels = /*field_group_labels*/
        ctx2[0];
        add_flush_callback(() => updating_field_group_labels = false);
      }
      fieldgrouplabelsselector.$set(fieldgrouplabelsselector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldgrouplabelsselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldgrouplabelsselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fieldgrouplabelsselector, detaching);
    }
  };
}
function create_fragment30(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: (
        /*name*/
        ctx[1]
      ),
      description: (
        /*description*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot20] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const settingitem_changes = {};
      if (dirty & /*name*/
      2)
        settingitem_changes.name = /*name*/
        ctx2[1];
      if (dirty & /*description*/
      4)
        settingitem_changes.description = /*description*/
        ctx2[2];
      if (dirty & /*$$scope, edge_field_groups, field_group_labels*/
      73) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function instance30($$self, $$props, $$invalidate) {
  let { name = "Field Groups" } = $$props;
  let { description = "Select the field groups to use for this traversal." } = $$props;
  let { field_group_labels } = $$props;
  let { edge_field_groups } = $$props;
  const dispatch = createEventDispatcher();
  function fieldgrouplabelsselector_field_group_labels_binding(value) {
    field_group_labels = value;
    $$invalidate(0, field_group_labels);
  }
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(1, name = $$props2.name);
    if ("description" in $$props2)
      $$invalidate(2, description = $$props2.description);
    if ("field_group_labels" in $$props2)
      $$invalidate(0, field_group_labels = $$props2.field_group_labels);
    if ("edge_field_groups" in $$props2)
      $$invalidate(3, edge_field_groups = $$props2.edge_field_groups);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*field_group_labels*/
    1) {
      $:
        if (field_group_labels) {
          dispatch("select", field_group_labels);
        }
    }
  };
  return [
    field_group_labels,
    name,
    description,
    edge_field_groups,
    fieldgrouplabelsselector_field_group_labels_binding
  ];
}
var FieldGroupLabelsSettingItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance30, create_fragment30, safe_not_equal, {
      name: 1,
      description: 2,
      field_group_labels: 0,
      edge_field_groups: 3
    });
  }
};
var FieldGroupLabelsSettingItem_default = FieldGroupLabelsSettingItem;

// src/settings/GridSettings.ts
var _add_settings_trail_view = (plugin, containerEl) => {
  new_setting(containerEl, {
    name: "Enable trail view",
    desc: "Show the trail view at the top of the page",
    toggle: {
      value: plugin.settings.views.page.trail.enabled,
      cb: async (value) => {
        plugin.settings.views.page.trail.enabled = value;
        await Promise.all([plugin.saveSettings()]);
        plugin.refresh({ rebuild_graph: false });
      }
    }
  });
  new_setting(containerEl, {
    name: "Format",
    desc: "Format of the trail view",
    select: {
      value: plugin.settings.views.page.trail.format,
      options: ["grid", "path"],
      cb: async (value) => {
        plugin.settings.views.page.trail.format = value;
        await Promise.all([
          plugin.saveSettings(),
          plugin.refresh({ rebuild_graph: false })
        ]);
      }
    }
  });
  new_setting(containerEl, {
    name: "Path Selection",
    desc: "How to select the path(s) to display in the trail view",
    select: {
      value: plugin.settings.views.page.trail.selection,
      options: ["all", "shortest", "longest"],
      cb: async (value) => {
        plugin.settings.views.page.trail.selection = value;
        await Promise.all([
          plugin.saveSettings(),
          plugin.refresh({ rebuild_graph: false })
        ]);
      }
    }
  });
  new_setting(containerEl, {
    name: "Default depth",
    desc: "Default depth of the trail view",
    input: {
      value: plugin.settings.views.page.trail.default_depth.toString(),
      cb: async (value) => {
        const int2 = parseInt(value);
        if (isNaN(int2)) {
          return new import_obsidian17.Notice("Depth must be a number");
        } else if (int2 < 0) {
          return new import_obsidian17.Notice("Depth must be a non-negative number");
        }
        plugin.settings.views.page.trail.default_depth = int2;
        await Promise.all([
          plugin.saveSettings(),
          plugin.refresh({ rebuild_graph: false })
        ]);
      }
    }
  });
  new FieldGroupLabelsSettingItem_default({
    target: containerEl,
    props: {
      edge_field_groups: plugin.settings.edge_field_groups,
      field_group_labels: plugin.settings.views.page.trail.field_group_labels
    }
  }).$on("select", async (e) => {
    plugin.settings.views.page.trail.field_group_labels = e.detail;
    await Promise.all([
      plugin.saveSettings(),
      plugin.refresh({ rebuild_graph: false })
    ]);
  });
  new_setting(containerEl, {
    name: "Merge Fields",
    desc: "Merge fields in the traversal, instead of keeping their paths separate",
    toggle: {
      value: plugin.settings.views.page.trail.merge_fields,
      cb: async (value) => {
        plugin.settings.views.page.trail.merge_fields = value;
        await Promise.all([
          plugin.saveSettings(),
          plugin.refresh({ rebuild_graph: false })
        ]);
      }
    }
  });
  new_setting(containerEl, {
    name: "Show controls",
    desc: "Show controls to change the depth/format/path-selection of the trail view",
    toggle: {
      value: plugin.settings.views.page.trail.show_controls,
      cb: async (value) => {
        plugin.settings.views.page.trail.show_controls = value;
        await Promise.all([
          plugin.saveSettings(),
          plugin.refresh({ rebuild_graph: false })
        ]);
      }
    }
  });
  new_setting(containerEl, {
    name: "No path message",
    desc: "Message to display when there is no path to display. Leave blank to hide the trail view when there is no path.",
    input: {
      value: plugin.settings.views.page.trail.no_path_message,
      cb: async (value) => {
        plugin.settings.views.page.trail.no_path_message = value;
        await Promise.all([
          plugin.saveSettings(),
          plugin.refresh({ rebuild_graph: false })
        ]);
      }
    }
  });
  _add_settings_show_node_options(plugin, containerEl, {
    get: () => plugin.settings.views.page.trail.show_node_options,
    set: (value) => plugin.settings.views.page.trail.show_node_options = value
  });
};

// src/settings/JohnnyDecimalSettings.ts
var import_obsidian18 = require("obsidian");
var _add_settings_johnny_decimal_note = (plugin, containerEl) => {
  new_setting(containerEl, {
    name: "Enabled",
    desc: "Look for Johnny Decimal notes to use as edge sources",
    toggle: {
      value: plugin.settings.explicit_edge_sources.johnny_decimal_note.enabled,
      cb: async (value) => {
        plugin.settings.explicit_edge_sources.johnny_decimal_note.enabled = value;
        await Promise.all([plugin.refresh(), plugin.saveSettings()]);
      }
    }
  });
  new_setting(containerEl, {
    name: "Delimiter",
    desc: "Delimiter to use to split the note name",
    input: {
      value: plugin.settings.explicit_edge_sources.johnny_decimal_note.delimiter,
      cb: async (value) => {
        if (!value)
          new import_obsidian18.Notice("Delimiter cannot be empty");
        else {
          plugin.settings.explicit_edge_sources.johnny_decimal_note.delimiter = value;
          await Promise.all([
            plugin.refresh(),
            plugin.saveSettings()
          ]);
        }
      }
    }
  });
  new_setting(containerEl, {
    name: "Default Field",
    desc: "Field to use to point to next note in the Johnny Decimal system",
    select: {
      value: plugin.settings.explicit_edge_sources.johnny_decimal_note.default_field,
      options: plugin.settings.edge_fields.map((f) => f.label),
      cb: async (value) => {
        plugin.settings.explicit_edge_sources.johnny_decimal_note.default_field = value;
        await Promise.all([plugin.refresh(), plugin.saveSettings()]);
      }
    }
  });
};

// src/menus/EdgeSortIdMenu.ts
var import_obsidian19 = require("obsidian");
var ORDERS = [1, -1];
var EdgeSortIdMenu = ({
  cb,
  value,
  exclude_fields
}) => {
  const menu = new import_obsidian19.Menu();
  ORDERS.forEach((order) => {
    menu.addItem(
      (item) => item.setTitle(`Order: ${order === 1 ? "asc" : "desc"}`).setChecked(value.order === order).onClick(() => {
        value.order = order;
        cb(value);
      })
    );
  });
  menu.addSeparator();
  SIMPLE_EDGE_SORT_FIELDS.filter((f) => !(exclude_fields == null ? void 0 : exclude_fields.includes(f))).forEach(
    (field) => {
      menu.addItem(
        (item) => item.setTitle("Field: " + field).setChecked(value.field === field).onClick(() => {
          value.field = field;
          cb(value);
        })
      );
    }
  );
  return menu;
};

// src/components/selector/EdgeSortIdSelector.svelte
function create_else_block4(ctx) {
  let arrowdownwidenarrow;
  let current;
  arrowdownwidenarrow = new arrow_down_wide_narrow_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      create_component(arrowdownwidenarrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(arrowdownwidenarrow, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(arrowdownwidenarrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arrowdownwidenarrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(arrowdownwidenarrow, detaching);
    }
  };
}
function create_if_block5(ctx) {
  let arrowupnarrowwide;
  let current;
  arrowupnarrowwide = new arrow_up_narrow_wide_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      create_component(arrowupnarrowwide.$$.fragment);
    },
    m(target, anchor) {
      mount_component(arrowupnarrowwide, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(arrowupnarrowwide.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arrowupnarrowwide.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(arrowupnarrowwide, detaching);
    }
  };
}
function create_fragment31(ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block5, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*edge_sort_id*/
      ctx2[0].order === 1
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(button, "class", button_class_value = "flex gap-1 " + /*cls*/
      ctx[2]);
      attr(button, "aria-label", "Change sort field/order");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(button, null);
      }
      if (!current || dirty & /*cls*/
      4 && button_class_value !== (button_class_value = "flex gap-1 " + /*cls*/
      ctx2[2])) {
        attr(button, "class", button_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function instance31($$self, $$props, $$invalidate) {
  let { edge_sort_id } = $$props;
  let { exclude_fields = [] } = $$props;
  let { cls = "" } = $$props;
  const click_handler = (e) => {
    EdgeSortIdMenu({
      exclude_fields,
      value: edge_sort_id,
      cb: (value) => $$invalidate(0, edge_sort_id = value)
    }).showAtMouseEvent(e);
  };
  $$self.$$set = ($$props2) => {
    if ("edge_sort_id" in $$props2)
      $$invalidate(0, edge_sort_id = $$props2.edge_sort_id);
    if ("exclude_fields" in $$props2)
      $$invalidate(1, exclude_fields = $$props2.exclude_fields);
    if ("cls" in $$props2)
      $$invalidate(2, cls = $$props2.cls);
  };
  return [edge_sort_id, exclude_fields, cls, click_handler];
}
var EdgeSortIdSelector = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance31, create_fragment31, safe_not_equal, {
      edge_sort_id: 0,
      exclude_fields: 1,
      cls: 2
    });
  }
};
var EdgeSortIdSelector_default = EdgeSortIdSelector;

// src/components/settings/EdgeSortIdSettingItem.svelte
function create_default_slot21(ctx) {
  let edgesortidselector;
  let updating_edge_sort_id;
  let current;
  function edgesortidselector_edge_sort_id_binding(value) {
    ctx[1](value);
  }
  let edgesortidselector_props = {};
  if (
    /*edge_sort_id*/
    ctx[0] !== void 0
  ) {
    edgesortidselector_props.edge_sort_id = /*edge_sort_id*/
    ctx[0];
  }
  edgesortidselector = new EdgeSortIdSelector_default({ props: edgesortidselector_props });
  binding_callbacks.push(() => bind(edgesortidselector, "edge_sort_id", edgesortidselector_edge_sort_id_binding));
  return {
    c() {
      create_component(edgesortidselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(edgesortidselector, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const edgesortidselector_changes = {};
      if (!updating_edge_sort_id && dirty & /*edge_sort_id*/
      1) {
        updating_edge_sort_id = true;
        edgesortidselector_changes.edge_sort_id = /*edge_sort_id*/
        ctx2[0];
        add_flush_callback(() => updating_edge_sort_id = false);
      }
      edgesortidselector.$set(edgesortidselector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(edgesortidselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edgesortidselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(edgesortidselector, detaching);
    }
  };
}
function create_fragment32(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: "Edge Sort",
      description: "Select the sorting method for the edges in the graph.",
      $$slots: { default: [create_default_slot21] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const settingitem_changes = {};
      if (dirty & /*$$scope, edge_sort_id*/
      9) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function instance32($$self, $$props, $$invalidate) {
  let { edge_sort_id } = $$props;
  const dispatch = createEventDispatcher();
  function edgesortidselector_edge_sort_id_binding(value) {
    edge_sort_id = value;
    $$invalidate(0, edge_sort_id);
  }
  $$self.$$set = ($$props2) => {
    if ("edge_sort_id" in $$props2)
      $$invalidate(0, edge_sort_id = $$props2.edge_sort_id);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*edge_sort_id*/
    1) {
      $:
        if (edge_sort_id) {
          dispatch("select", edge_sort_id);
        }
    }
  };
  return [edge_sort_id, edgesortidselector_edge_sort_id_binding];
}
var EdgeSortIdSettingItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance32, create_fragment32, safe_not_equal, { edge_sort_id: 0 });
  }
};
var EdgeSortIdSettingItem_default = EdgeSortIdSettingItem;

// src/menus/ShowAttributesMenu.ts
var import_obsidian20 = require("obsidian");
var ShowAttributesSelectorMenu = ({
  cb,
  value,
  exclude_attributes
}) => {
  const menu = new import_obsidian20.Menu();
  const possible = EDGE_ATTRIBUTES.filter(
    (attr2) => !(exclude_attributes == null ? void 0 : exclude_attributes.includes(attr2))
  );
  const all = possible.length === value.length;
  menu.addItem(
    (item) => item.setTitle(all ? "None" : "All").onClick(() => {
      cb(all ? [] : possible);
    })
  );
  menu.addSeparator();
  const add_item = (attr2) => {
    const included = value.includes(attr2);
    menu.addItem(
      (item) => item.setTitle(attr2).setChecked(included).onClick(() => {
        if (included) {
          cb(value.filter((v) => v !== attr2));
        } else {
          cb([...value, attr2]);
        }
      })
    );
  };
  ["field", "explicit"].filter((attr2) => !(exclude_attributes == null ? void 0 : exclude_attributes.includes(attr2))).forEach(add_item);
  menu.addSeparator();
  ["source"].filter((attr2) => !(exclude_attributes == null ? void 0 : exclude_attributes.includes(attr2))).forEach(add_item);
  menu.addSeparator();
  ["implied_kind", "round"].filter((attr2) => !(exclude_attributes == null ? void 0 : exclude_attributes.includes(attr2))).forEach(add_item);
  return menu;
};

// src/components/selector/ShowAttributesSelectorMenu.svelte
function create_fragment33(ctx) {
  let button;
  let filejson;
  let current;
  let mounted;
  let dispose;
  filejson = new file_json_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      button = element("button");
      create_component(filejson.$$.fragment);
      attr(
        button,
        "class",
        /*cls*/
        ctx[2]
      );
      attr(button, "aria-label", "Change which edge attributes show");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(filejson, button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*cls*/
      4) {
        attr(
          button,
          "class",
          /*cls*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(filejson.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filejson.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(filejson);
      mounted = false;
      dispose();
    }
  };
}
function instance33($$self, $$props, $$invalidate) {
  let { show_attributes } = $$props;
  let { exclude_attributes = [] } = $$props;
  let { cls = "" } = $$props;
  if (exclude_attributes === null || exclude_attributes === void 0 ? void 0 : exclude_attributes.length) {
    show_attributes = show_attributes.filter((v) => !(exclude_attributes === null || exclude_attributes === void 0 ? void 0 : exclude_attributes.includes(v)));
  }
  const click_handler = (e) => {
    ShowAttributesSelectorMenu({
      exclude_attributes,
      value: show_attributes,
      cb: (value) => $$invalidate(0, show_attributes = value)
    }).showAtMouseEvent(e);
  };
  $$self.$$set = ($$props2) => {
    if ("show_attributes" in $$props2)
      $$invalidate(0, show_attributes = $$props2.show_attributes);
    if ("exclude_attributes" in $$props2)
      $$invalidate(1, exclude_attributes = $$props2.exclude_attributes);
    if ("cls" in $$props2)
      $$invalidate(2, cls = $$props2.cls);
  };
  return [show_attributes, exclude_attributes, cls, click_handler];
}
var ShowAttributesSelectorMenu_1 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance33, create_fragment33, safe_not_equal, {
      show_attributes: 0,
      exclude_attributes: 1,
      cls: 2
    });
  }
};
var ShowAttributesSelectorMenu_default = ShowAttributesSelectorMenu_1;

// src/components/settings/ShowAttributesSettingItem.svelte
function create_default_slot22(ctx) {
  let showattributesselectormenu;
  let updating_show_attributes;
  let current;
  function showattributesselectormenu_show_attributes_binding(value) {
    ctx[2](value);
  }
  let showattributesselectormenu_props = {
    exclude_attributes: (
      /*exclude_attributes*/
      ctx[1]
    )
  };
  if (
    /*show_attributes*/
    ctx[0] !== void 0
  ) {
    showattributesselectormenu_props.show_attributes = /*show_attributes*/
    ctx[0];
  }
  showattributesselectormenu = new ShowAttributesSelectorMenu_default({ props: showattributesselectormenu_props });
  binding_callbacks.push(() => bind(showattributesselectormenu, "show_attributes", showattributesselectormenu_show_attributes_binding));
  return {
    c() {
      create_component(showattributesselectormenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(showattributesselectormenu, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const showattributesselectormenu_changes = {};
      if (dirty & /*exclude_attributes*/
      2)
        showattributesselectormenu_changes.exclude_attributes = /*exclude_attributes*/
        ctx2[1];
      if (!updating_show_attributes && dirty & /*show_attributes*/
      1) {
        updating_show_attributes = true;
        showattributesselectormenu_changes.show_attributes = /*show_attributes*/
        ctx2[0];
        add_flush_callback(() => updating_show_attributes = false);
      }
      showattributesselectormenu.$set(showattributesselectormenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(showattributesselectormenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(showattributesselectormenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(showattributesselectormenu, detaching);
    }
  };
}
function create_fragment34(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: "Show Attributes",
      description: "Select the edge attributes to show.",
      $$slots: { default: [create_default_slot22] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const settingitem_changes = {};
      if (dirty & /*$$scope, exclude_attributes, show_attributes*/
      19) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function instance34($$self, $$props, $$invalidate) {
  let { show_attributes } = $$props;
  let { exclude_attributes = [] } = $$props;
  const dispatch = createEventDispatcher();
  function showattributesselectormenu_show_attributes_binding(value) {
    show_attributes = value;
    $$invalidate(0, show_attributes);
  }
  $$self.$$set = ($$props2) => {
    if ("show_attributes" in $$props2)
      $$invalidate(0, show_attributes = $$props2.show_attributes);
    if ("exclude_attributes" in $$props2)
      $$invalidate(1, exclude_attributes = $$props2.exclude_attributes);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*show_attributes*/
    1) {
      $:
        if (show_attributes) {
          dispatch("select", show_attributes);
        }
    }
  };
  return [
    show_attributes,
    exclude_attributes,
    showattributesselectormenu_show_attributes_binding
  ];
}
var ShowAttributesSettingItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance34, create_fragment34, safe_not_equal, {
      show_attributes: 0,
      exclude_attributes: 1
    });
  }
};
var ShowAttributesSettingItem_default = ShowAttributesSettingItem;

// src/const/links.ts
var LINK_KINDS = ["none", "wiki", "markdown"];

// src/settings/ListIndexSettings.ts
var _add_settings_list_index = (plugin, contentEl) => {
  const { settings } = plugin;
  new FieldGroupLabelsSettingItem_default({
    target: contentEl,
    props: {
      edge_field_groups: plugin.settings.edge_field_groups,
      field_group_labels: settings.commands.list_index.default_options.field_group_labels
    }
  }).$on("select", async (e) => {
    settings.commands.list_index.default_options.field_group_labels = e.detail;
    settings.commands.list_index.default_options.fields = resolve_field_group_labels(
      plugin.settings.edge_field_groups,
      settings.commands.list_index.default_options.field_group_labels
    );
    await plugin.saveSettings();
  });
  new_setting(contentEl, {
    name: "Link Kind",
    desc: "Format to use for links",
    select: {
      options: LINK_KINDS,
      value: settings.commands.list_index.default_options.link_kind,
      cb: async (value) => {
        settings.commands.list_index.default_options.link_kind = value;
        await plugin.saveSettings();
      }
    }
  });
  new_setting(contentEl, {
    name: "Indent",
    desc: "Indentation to use for each level",
    input: {
      value: settings.commands.list_index.default_options.indent,
      cb: async (value) => {
        settings.commands.list_index.default_options.indent = value;
        await plugin.saveSettings();
      }
    }
  });
  new EdgeSortIdSettingItem_default({
    target: contentEl,
    props: {
      edge_sort_id: settings.commands.list_index.default_options.edge_sort_id
    }
  }).$on("select", async (e) => {
    settings.commands.list_index.default_options.edge_sort_id = e.detail;
    await plugin.saveSettings();
  });
  new ShowAttributesSettingItem_default({
    target: contentEl,
    props: {
      show_attributes: settings.commands.list_index.default_options.show_attributes
    }
  }).$on("select", async (e) => {
    settings.commands.list_index.default_options.show_attributes = e.detail;
    await plugin.saveSettings();
  });
  _add_settings_show_node_options(plugin, contentEl, {
    get: () => settings.commands.list_index.default_options.show_node_options,
    set: (value) => settings.commands.list_index.default_options.show_node_options = value
  });
};

// src/settings/ListNoteSettings.ts
var _add_settings_list_note = (plugin, containerEl) => {
  new_setting(containerEl, {
    name: "Default Neighbour Field",
    desc: "Field to use to join neighbouring list items.",
    select: {
      value: plugin.settings.explicit_edge_sources.list_note.default_neighbour_field,
      options: [""].concat(
        plugin.settings.edge_fields.map((f) => f.label)
      ),
      cb: async (value) => {
        plugin.settings.explicit_edge_sources.list_note.default_neighbour_field = value;
        await Promise.all([plugin.refresh(), plugin.saveSettings()]);
      }
    }
  });
};

// src/settings/MatrixSettings.ts
var _add_settings_matrix = (plugin, containerEl) => {
  new_setting(containerEl, {
    name: "Collapse",
    desc: "Collapse the matrix by default",
    toggle: {
      value: plugin.settings.views.side.matrix.collapse,
      cb: async (checked) => {
        plugin.settings.views.side.matrix.collapse = checked;
        await Promise.all([
          plugin.saveSettings(),
          plugin.refresh({
            redraw_side_views: true,
            rebuild_graph: false
          })
        ]);
      }
    }
  });
  new EdgeSortIdSettingItem_default({
    target: containerEl,
    props: { edge_sort_id: plugin.settings.views.side.matrix.edge_sort_id }
  }).$on("select", async (e) => {
    plugin.settings.views.side.matrix.edge_sort_id = e.detail;
    await Promise.all([
      plugin.saveSettings(),
      plugin.refresh({ redraw_side_views: true, rebuild_graph: false })
    ]);
  });
  new ShowAttributesSettingItem_default({
    target: containerEl,
    props: {
      exclude_attributes: ["field", "explicit"],
      show_attributes: plugin.settings.views.side.matrix.show_attributes
    }
  }).$on("select", async (e) => {
    plugin.settings.views.side.matrix.show_attributes = e.detail;
    await Promise.all([
      plugin.saveSettings(),
      plugin.refresh({ redraw_side_views: true, rebuild_graph: false })
    ]);
  });
  new FieldGroupLabelsSettingItem_default({
    target: containerEl,
    props: {
      edge_field_groups: plugin.settings.edge_field_groups,
      field_group_labels: plugin.settings.views.side.matrix.field_group_labels
    }
  }).$on("select", async (e) => {
    plugin.settings.views.side.matrix.field_group_labels = e.detail;
    await Promise.all([
      plugin.saveSettings(),
      plugin.refresh({ redraw_side_views: true, rebuild_graph: false })
    ]);
  });
  _add_settings_show_node_options(plugin, containerEl, {
    get: () => plugin.settings.views.side.matrix.show_node_options,
    set: (value) => plugin.settings.views.side.matrix.show_node_options = value
  });
};

// src/views/page.ts
var import_obsidian22 = require("obsidian");

// src/components/ObsidianLink.svelte
var import_obsidian21 = require("obsidian");
function create_fragment35(ctx) {
  let span;
  let t;
  let span_class_value;
  let span_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      var _a;
      span = element("span");
      t = text(
        /*display*/
        ctx[1]
      );
      attr(span, "role", "link");
      attr(span, "class", span_class_value = "internal-link cursor-pointer " + /*cls*/
      ctx[4]);
      attr(
        span,
        "data-href",
        /*path*/
        ctx[0]
      );
      attr(span, "aria-label", span_aria_label_value = /*no_ext*/
      ctx[6] === /*display*/
      ctx[1] ? "" : (
        /*path*/
        ctx[0]
      ));
      toggle_class(span, "is-unresolved", !/*resolved*/
      ctx[2]);
      toggle_class(
        span,
        "BC-active-note",
        /*$active_file_store*/
        ((_a = ctx[5]) == null ? void 0 : _a.path) === /*path*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
      if (!mounted) {
        dispose = [
          listen(
            span,
            "mouseover",
            /*mouseover_handler*/
            ctx[7]
          ),
          listen(
            span,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[8]
          ),
          listen(
            span,
            "auxclick",
            /*auxclick_handler*/
            ctx[9]
          ),
          listen(
            span,
            "click",
            /*click_handler*/
            ctx[10]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a;
      if (dirty & /*display*/
      2)
        set_data(
          t,
          /*display*/
          ctx2[1]
        );
      if (dirty & /*cls*/
      16 && span_class_value !== (span_class_value = "internal-link cursor-pointer " + /*cls*/
      ctx2[4])) {
        attr(span, "class", span_class_value);
      }
      if (dirty & /*path*/
      1) {
        attr(
          span,
          "data-href",
          /*path*/
          ctx2[0]
        );
      }
      if (dirty & /*display, path*/
      3 && span_aria_label_value !== (span_aria_label_value = /*no_ext*/
      ctx2[6] === /*display*/
      ctx2[1] ? "" : (
        /*path*/
        ctx2[0]
      ))) {
        attr(span, "aria-label", span_aria_label_value);
      }
      if (dirty & /*cls, resolved*/
      20) {
        toggle_class(span, "is-unresolved", !/*resolved*/
        ctx2[2]);
      }
      if (dirty & /*cls, $active_file_store, path*/
      49) {
        toggle_class(
          span,
          "BC-active-note",
          /*$active_file_store*/
          ((_a = ctx2[5]) == null ? void 0 : _a.path) === /*path*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance35($$self, $$props, $$invalidate) {
  let $active_file_store;
  component_subscribe($$self, active_file_store, ($$value) => $$invalidate(5, $active_file_store = $$value));
  let { path } = $$props;
  let { display } = $$props;
  let { resolved } = $$props;
  let { plugin } = $$props;
  let { cls = "" } = $$props;
  const no_ext = Paths.drop_ext(path);
  const mouseover_handler = (event) => {
    plugin.app.workspace.trigger("hover-link", {
      event,
      linktext: path,
      // Must match `plugin.registerHoverSource` source (in `main.ts`)
      source: "breadcrumbs",
      targetEl: event.currentTarget,
      hoverParent: event.currentTarget.parentElement
    });
  };
  const contextmenu_handler = (e) => {
    const menu = new import_obsidian21.Menu();
    plugin.app.workspace.handleLinkContextMenu(menu, display, path);
    menu.showAtMouseEvent(e);
  };
  const auxclick_handler = (e) => {
    log.debug("on:auxclick e.button", e.button);
    if (e.button === 1) {
      plugin.app.workspace.openLinkText(path, "", "tab");
    }
  };
  const click_handler = (e) => {
    plugin.app.workspace.openLinkText(path, "", import_obsidian21.Keymap.isModEvent(e));
  };
  $$self.$$set = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(0, path = $$props2.path);
    if ("display" in $$props2)
      $$invalidate(1, display = $$props2.display);
    if ("resolved" in $$props2)
      $$invalidate(2, resolved = $$props2.resolved);
    if ("plugin" in $$props2)
      $$invalidate(3, plugin = $$props2.plugin);
    if ("cls" in $$props2)
      $$invalidate(4, cls = $$props2.cls);
  };
  return [
    path,
    display,
    resolved,
    plugin,
    cls,
    $active_file_store,
    no_ext,
    mouseover_handler,
    contextmenu_handler,
    auxclick_handler,
    click_handler
  ];
}
var ObsidianLink = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance35, create_fragment35, safe_not_equal, {
      path: 0,
      display: 1,
      resolved: 2,
      plugin: 3,
      cls: 4
    });
  }
};
var ObsidianLink_default = ObsidianLink;

// src/components/EdgeLink.svelte
function create_fragment36(ctx) {
  let obsidianlink;
  let current;
  obsidianlink = new ObsidianLink_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[1]
      ),
      display: (
        /*display*/
        ctx[3]
      ),
      path: (
        /*edge*/
        ctx[0].target_id
      ),
      resolved: (
        /*edge*/
        ctx[0].target_attr.resolved
      ),
      cls: (
        /*cls*/
        ctx[2] + " BC-edge " + /*edge*/
        (ctx[0].attr.explicit ? "BC-edge-explicit" : `BC-edge-implied BC-edge-implied-${/*edge*/
        ctx[0].attr.implied_kind}`)
      )
    }
  });
  return {
    c() {
      create_component(obsidianlink.$$.fragment);
    },
    m(target, anchor) {
      mount_component(obsidianlink, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const obsidianlink_changes = {};
      if (dirty & /*plugin*/
      2)
        obsidianlink_changes.plugin = /*plugin*/
        ctx2[1];
      if (dirty & /*edge*/
      1)
        obsidianlink_changes.path = /*edge*/
        ctx2[0].target_id;
      if (dirty & /*edge*/
      1)
        obsidianlink_changes.resolved = /*edge*/
        ctx2[0].target_attr.resolved;
      if (dirty & /*cls, edge*/
      5)
        obsidianlink_changes.cls = /*cls*/
        ctx2[2] + " BC-edge " + /*edge*/
        (ctx2[0].attr.explicit ? "BC-edge-explicit" : `BC-edge-implied BC-edge-implied-${/*edge*/
        ctx2[0].attr.implied_kind}`);
      obsidianlink.$set(obsidianlink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(obsidianlink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(obsidianlink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(obsidianlink, detaching);
    }
  };
}
function instance36($$self, $$props, $$invalidate) {
  let { edge } = $$props;
  let { plugin } = $$props;
  let { show_node_options } = $$props;
  let { cls = "" } = $$props;
  const { dendron_note } = plugin.settings.explicit_edge_sources;
  const display = stringify_node(edge.target_id, edge.target_attr, {
    show_node_options,
    trim_basename_delimiter: dendron_note.enabled && dendron_note.display_trimmed ? dendron_note.delimiter : void 0
  });
  $$self.$$set = ($$props2) => {
    if ("edge" in $$props2)
      $$invalidate(0, edge = $$props2.edge);
    if ("plugin" in $$props2)
      $$invalidate(1, plugin = $$props2.plugin);
    if ("show_node_options" in $$props2)
      $$invalidate(4, show_node_options = $$props2.show_node_options);
    if ("cls" in $$props2)
      $$invalidate(2, cls = $$props2.cls);
  };
  return [edge, plugin, cls, display, show_node_options];
}
var EdgeLink = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance36, create_fragment36, safe_not_equal, {
      edge: 0,
      plugin: 1,
      show_node_options: 4,
      cls: 2
    });
  }
};
var EdgeLink_default = EdgeLink;

// src/components/page_views/PrevNextView.svelte
function add_css2(target) {
  append_styles(target, "svelte-deyewb", ".BC-prev-next-view.svelte-deyewb>div.svelte-deyewb{border:1px solid var(--background-modifier-border)}");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function get_each_context_13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_if_block6(ctx) {
  var _a, _b, _c, _d;
  let div0;
  let t;
  let div1;
  let current;
  let each_value_1 = ensure_array_like(
    /*grouped_out_edges*/
    (_b = (_a = ctx[2]) == null ? void 0 : _a.prev) != null ? _b : []
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_13(get_each_context_13(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks_1[i], 1, 1, () => {
    each_blocks_1[i] = null;
  });
  let each_value = ensure_array_like(
    /*grouped_out_edges*/
    (_d = (_c = ctx[2]) == null ? void 0 : _c.next) != null ? _d : []
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const out_1 = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div0 = element("div");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "flex w-full flex-col svelte-deyewb");
      set_style(div0, "border-radius", "var(--radius-m) 0 0 var(--radius-m)");
      attr(div1, "class", "flex w-full flex-col svelte-deyewb");
      set_style(div1, "border-radius", "0 var(--radius-m) var(--radius-m) 0");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div0, null);
        }
      }
      insert(target, t, anchor);
      insert(target, div1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2, _d2;
      if (dirty & /*grouped_out_edges, plugin, show_node_options*/
      7) {
        each_value_1 = ensure_array_like(
          /*grouped_out_edges*/
          (_b2 = (_a2 = ctx2[2]) == null ? void 0 : _a2.prev) != null ? _b2 : []
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_13(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            transition_in(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_13(child_ctx);
            each_blocks_1[i].c();
            transition_in(each_blocks_1[i], 1);
            each_blocks_1[i].m(div0, null);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (dirty & /*grouped_out_edges, plugin, show_node_options*/
      7) {
        each_value = ensure_array_like(
          /*grouped_out_edges*/
          (_d2 = (_c2 = ctx2[2]) == null ? void 0 : _c2.next) != null ? _d2 : []
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out_1(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t);
        detach(div1);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_13(ctx) {
  let div;
  let span;
  let t1;
  let edgelink;
  let t2;
  let current;
  edgelink = new EdgeLink_default({
    props: {
      cls: "grow",
      edge: (
        /*edge*/
        ctx[7]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      show_node_options: (
        /*show_node_options*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      div = element("div");
      span = element("span");
      span.textContent = `${/*edge*/
      ctx[7].attr.field}`;
      t1 = space();
      create_component(edgelink.$$.fragment);
      t2 = space();
      attr(span, "class", "BC-field pl-2");
      attr(div, "class", "BC-next-prev-item flex gap-3 p-1 text-left");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(div, t1);
      mount_component(edgelink, div, null);
      append(div, t2);
      current = true;
    },
    p(ctx2, dirty) {
      const edgelink_changes = {};
      if (dirty & /*plugin*/
      1)
        edgelink_changes.plugin = /*plugin*/
        ctx2[0];
      edgelink.$set(edgelink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(edgelink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edgelink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(edgelink);
    }
  };
}
function create_each_block5(ctx) {
  let div;
  let edgelink;
  let t0;
  let span;
  let t2;
  let current;
  edgelink = new EdgeLink_default({
    props: {
      cls: "grow",
      edge: (
        /*edge*/
        ctx[7]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      show_node_options: (
        /*show_node_options*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(edgelink.$$.fragment);
      t0 = space();
      span = element("span");
      span.textContent = `${/*edge*/
      ctx[7].attr.field}`;
      t2 = space();
      attr(span, "class", "BC-field pr-2");
      attr(div, "class", "BC-next-prev-item flex gap-3 p-1 text-right");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(edgelink, div, null);
      append(div, t0);
      append(div, span);
      append(div, t2);
      current = true;
    },
    p(ctx2, dirty) {
      const edgelink_changes = {};
      if (dirty & /*plugin*/
      1)
        edgelink_changes.plugin = /*plugin*/
        ctx2[0];
      edgelink.$set(edgelink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(edgelink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edgelink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(edgelink);
    }
  };
}
function create_fragment37(ctx) {
  var _a, _b, _c, _d;
  let div;
  let current;
  let if_block = (
    /*grouped_out_edges*/
    (((_b = (_a = ctx[2]) == null ? void 0 : _a.prev) == null ? void 0 : _b.length) || /*grouped_out_edges*/
    ((_d = (_c = ctx[2]) == null ? void 0 : _c.next) == null ? void 0 : _d.length)) && create_if_block6(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "BC-prev-next-view flex svelte-deyewb");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2, _c2, _d2;
      if (
        /*grouped_out_edges*/
        ((_b2 = (_a2 = ctx2[2]) == null ? void 0 : _a2.prev) == null ? void 0 : _b2.length) || /*grouped_out_edges*/
        ((_d2 = (_c2 = ctx2[2]) == null ? void 0 : _c2.next) == null ? void 0 : _d2.length)
      )
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance37($$self, $$props, $$invalidate) {
  let { file_path } = $$props;
  let { plugin } = $$props;
  const { field_group_labels, show_node_options } = plugin.settings.views.page.prev_next;
  const edge_field_labels = {
    prev: resolve_field_group_labels(plugin.settings.edge_field_groups, field_group_labels.prev),
    next: resolve_field_group_labels(plugin.settings.edge_field_groups, field_group_labels.next)
  };
  const merged_field_labels = remove_duplicates([...edge_field_labels.prev, ...edge_field_labels.next]);
  const grouped_out_edges = plugin.graph.hasNode(file_path) ? group_by(plugin.graph.get_out_edges(file_path).filter((e) => has_edge_attrs(e, { $or_fields: merged_field_labels })), (e) => edge_field_labels.prev.includes(e.attr.field) ? "prev" : "next") : null;
  $$self.$$set = ($$props2) => {
    if ("file_path" in $$props2)
      $$invalidate(3, file_path = $$props2.file_path);
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  return [plugin, show_node_options, grouped_out_edges, file_path];
}
var PrevNextView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance37, create_fragment37, safe_not_equal, { file_path: 3, plugin: 0 }, add_css2);
  }
};
var PrevNextView_default = PrevNextView;

// src/components/button/MergeFieldsButton.svelte
function create_else_block5(ctx) {
  let spliticon;
  let current;
  spliticon = new split_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      create_component(spliticon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spliticon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(spliticon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spliticon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spliticon, detaching);
    }
  };
}
function create_if_block7(ctx) {
  let mergeicon;
  let current;
  mergeicon = new merge_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      create_component(mergeicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(mergeicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(mergeicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(mergeicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(mergeicon, detaching);
    }
  };
}
function create_fragment38(ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let button_aria_label_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block7, create_else_block5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*merge_fields*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(
        button,
        "class",
        /*cls*/
        ctx[1]
      );
      attr(button, "aria-label", button_aria_label_value = /*merge_fields*/
      ctx[0] ? "Separate Fields" : "Merge Fields");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(button, null);
      }
      if (!current || dirty & /*cls*/
      2) {
        attr(
          button,
          "class",
          /*cls*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*merge_fields*/
      1 && button_aria_label_value !== (button_aria_label_value = /*merge_fields*/
      ctx2[0] ? "Separate Fields" : "Merge Fields")) {
        attr(button, "aria-label", button_aria_label_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function instance38($$self, $$props, $$invalidate) {
  let { cls = "" } = $$props;
  let { merge_fields } = $$props;
  const click_handler = () => $$invalidate(0, merge_fields = !merge_fields);
  $$self.$$set = ($$props2) => {
    if ("cls" in $$props2)
      $$invalidate(1, cls = $$props2.cls);
    if ("merge_fields" in $$props2)
      $$invalidate(0, merge_fields = $$props2.merge_fields);
  };
  return [merge_fields, cls, click_handler];
}
var MergeFieldsButton = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance38, create_fragment38, safe_not_equal, { cls: 1, merge_fields: 0 });
  }
};
var MergeFieldsButton_default = MergeFieldsButton;

// src/components/page_views/TrailViewGrid.svelte
function add_css3(target) {
  append_styles(target, "svelte-fynvrm", ".BC-trail-view.svelte-fynvrm{overflow:hidden;border-radius:var(--radius-m);border:1px solid var(--background-modifier-border)}.BC-trail-view-item.svelte-fynvrm{margin:-1px -1px 0 0;border-right:1px solid var(--background-modifier-border);border-top:1px solid var(--background-modifier-border)}");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  child_ctx[7] = i;
  return child_ctx;
}
function get_each_context_14(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i].first;
  child_ctx[9] = list[i].last;
  const constants_0 = (
    /*square*/
    child_ctx[1][
      /*first*/
      child_ctx[8]
    ][
      /*j*/
      child_ctx[7]
    ]
  );
  child_ctx[10] = constants_0;
  return child_ctx;
}
function create_if_block8(ctx) {
  let edgelink;
  let current;
  edgelink = new EdgeLink_default({
    props: {
      edge: (
        /*edge*/
        ctx[10]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      cls: "p-1 grow flex justify-center items-center",
      show_node_options: (
        /*plugin*/
        ctx[0].settings.views.page.trail.show_node_options
      )
    }
  });
  return {
    c() {
      create_component(edgelink.$$.fragment);
    },
    m(target, anchor) {
      mount_component(edgelink, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const edgelink_changes = {};
      if (dirty & /*plugin*/
      1)
        edgelink_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*plugin*/
      1)
        edgelink_changes.show_node_options = /*plugin*/
        ctx2[0].settings.views.page.trail.show_node_options;
      edgelink.$set(edgelink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(edgelink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edgelink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(edgelink, detaching);
    }
  };
}
function create_each_block_14(ctx) {
  let div;
  let t;
  let current;
  let if_block = (
    /*edge*/
    ctx[10] && create_if_block8(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      attr(div, "class", "BC-trail-view-item flex svelte-fynvrm");
      set_style(
        div,
        "grid-area",
        /*first*/
        ctx[8] + 1 + " / " + /*j*/
        (ctx[7] + 1) + " / " + /*last*/
        (ctx[9] + 2) + " / " + /*j*/
        (ctx[7] + 2)
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*edge*/
        ctx2[10]
      )
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function create_each_block6(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*col*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_14(get_each_context_14(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*col_runs, square, plugin*/
      7) {
        each_value_1 = ensure_array_like(
          /*col*/
          ctx2[5]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_14(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_14(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment39(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*col_runs*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      var _a, _b;
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "BC-trail-view grid svelte-fynvrm");
      set_style(div, "grid-template-rows", "min-content");
      set_style(div, "grid-template-columns", "1fr ".repeat(
        /*square*/
        (_b = (_a = ctx[1].at(0)) == null ? void 0 : _a.length) != null ? _b : 0
      ));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*col_runs, square, plugin*/
      7) {
        each_value = ensure_array_like(
          /*col_runs*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance39($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let { all_paths } = $$props;
  const reversed = all_paths.map((path) => [...path].reverse());
  const square = ensure_square_array(reversed, null, true);
  const col_runs = transpose(square).map((col) => gather_by_runs(col, (e) => e ? e.target_id : null));
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("all_paths" in $$props2)
      $$invalidate(3, all_paths = $$props2.all_paths);
  };
  return [plugin, square, col_runs, all_paths];
}
var TrailViewGrid = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance39, create_fragment39, safe_not_equal, { plugin: 0, all_paths: 3 }, add_css3);
  }
};
var TrailViewGrid_default = TrailViewGrid;

// src/components/page_views/TrailViewPath.svelte
function add_css4(target) {
  append_styles(target, "svelte-4v6yoh", '.BC-trail-view.svelte-4v6yoh{overflow:hidden;border-radius:var(--radius-m);border:1px solid var(--background-modifier-border)}.BC-trail-view-item-separator.svelte-4v6yoh::before{content:">"}');
}
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function get_each_context_15(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[8] = i;
  return child_ctx;
}
function create_if_block9(ctx) {
  let span;
  let span_aria_label_value;
  return {
    c() {
      span = element("span");
      attr(span, "class", "BC-trail-view-item-separator svelte-4v6yoh");
      attr(span, "aria-label", span_aria_label_value = url_search_params(untyped_pick(
        /*edge*/
        ctx[6].attr,
        ["source", "implied_kind", "round"]
      )));
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_each_block_15(ctx) {
  let div;
  let t;
  let edgelink;
  let current;
  let if_block = (
    /*j*/
    ctx[8] !== 0 && create_if_block9(ctx)
  );
  edgelink = new EdgeLink_default({
    props: {
      edge: (
        /*edge*/
        ctx[6]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      show_node_options: (
        /*plugin*/
        ctx[0].settings.views.page.trail.show_node_options
      )
    }
  });
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      create_component(edgelink.$$.fragment);
      attr(div, "class", "BC-trail-view-item");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t);
      mount_component(edgelink, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*j*/
        ctx2[8] !== 0
      )
        if_block.p(ctx2, dirty);
      const edgelink_changes = {};
      if (dirty & /*plugin*/
      1)
        edgelink_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*plugin*/
      1)
        edgelink_changes.show_node_options = /*plugin*/
        ctx2[0].settings.views.page.trail.show_node_options;
      edgelink.$set(edgelink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(edgelink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edgelink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
      destroy_component(edgelink);
    }
  };
}
function create_each_block7(ctx) {
  let div;
  let t;
  let current;
  let each_value_1 = ensure_array_like(
    /*path*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_15(get_each_context_15(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      attr(div, "class", "BC-trail-view-path flex gap-1.5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*reversed, plugin*/
      3) {
        each_value_1 = ensure_array_like(
          /*path*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_15(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_15(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, t);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment40(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*reversed*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block7(get_each_context7(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "BC-trail-view flex flex-col gap-1 px-3 py-2 svelte-4v6yoh");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*reversed, plugin*/
      3) {
        each_value = ensure_array_like(
          /*reversed*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block7(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance40($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let { all_paths } = $$props;
  const reversed = all_paths.map((path) => [...path].reverse());
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("all_paths" in $$props2)
      $$invalidate(2, all_paths = $$props2.all_paths);
  };
  return [plugin, reversed, all_paths];
}
var TrailViewPath = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance40, create_fragment40, safe_not_equal, { plugin: 0, all_paths: 2 }, add_css4);
  }
};
var TrailViewPath_default = TrailViewPath;

// src/components/page_views/TrailView.svelte
function get_each_context8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  return child_ctx;
}
function get_each_context_16(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  return child_ctx;
}
function create_if_block_33(ctx) {
  let p;
  let t_value = (
    /*plugin*/
    ctx[0].settings.views.page.trail.no_path_message + ""
  );
  let t;
  return {
    c() {
      p = element("p");
      t = text(t_value);
      attr(p, "class", "BC-trail-view-no-path search-empty-state");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*plugin*/
      1 && t_value !== (t_value = /*plugin*/
      ctx2[0].settings.views.page.trail.no_path_message + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block10(ctx) {
  let div1;
  let select0;
  let t0;
  let select1;
  let t1;
  let mergefieldsbutton;
  let updating_merge_fields;
  let t2;
  let div0;
  let button0;
  let t3;
  let button0_disabled_value;
  let t4;
  let span;
  let t5;
  let t6;
  let t7;
  let t8;
  let button1;
  let t9;
  let button1_disabled_value;
  let t10;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = ensure_array_like(["grid", "path"]);
  let each_blocks_1 = [];
  for (let i = 0; i < 2; i += 1) {
    each_blocks_1[i] = create_each_block_16(get_each_context_16(ctx, each_value_1, i));
  }
  let each_value = ensure_array_like(["all", "shortest", "longest"]);
  let each_blocks = [];
  for (let i = 0; i < 3; i += 1) {
    each_blocks[i] = create_each_block8(get_each_context8(ctx, each_value, i));
  }
  function mergefieldsbutton_merge_fields_binding(value) {
    ctx[14](value);
  }
  let mergefieldsbutton_props = {};
  if (
    /*plugin*/
    ctx[0].settings.views.page.trail.merge_fields !== void 0
  ) {
    mergefieldsbutton_props.merge_fields = /*plugin*/
    ctx[0].settings.views.page.trail.merge_fields;
  }
  mergefieldsbutton = new MergeFieldsButton_default({ props: mergefieldsbutton_props });
  binding_callbacks.push(() => bind(mergefieldsbutton, "merge_fields", mergefieldsbutton_merge_fields_binding));
  const if_block_creators = [create_if_block_13, create_if_block_23];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*plugin*/
      ctx2[0].settings.views.page.trail.format === "grid"
    )
      return 0;
    if (
      /*plugin*/
      ctx2[0].settings.views.page.trail.format === "path"
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div1 = element("div");
      select0 = element("select");
      for (let i = 0; i < 2; i += 1) {
        each_blocks_1[i].c();
      }
      t0 = space();
      select1 = element("select");
      for (let i = 0; i < 3; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      create_component(mergefieldsbutton.$$.fragment);
      t2 = space();
      div0 = element("div");
      button0 = element("button");
      t3 = text("-");
      t4 = space();
      span = element("span");
      t5 = text(
        /*depth*/
        ctx[2]
      );
      t6 = text("/");
      t7 = text(
        /*MAX_DEPTH*/
        ctx[1]
      );
      t8 = space();
      button1 = element("button");
      t9 = text("+");
      t10 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(select0, "class", "dropdown");
      if (
        /*plugin*/
        ctx[0].settings.views.page.trail.format === void 0
      )
        add_render_callback(() => (
          /*select0_change_handler*/
          ctx[10].call(select0)
        ));
      attr(select1, "class", "dropdown");
      if (
        /*plugin*/
        ctx[0].settings.views.page.trail.selection === void 0
      )
        add_render_callback(() => (
          /*select1_change_handler*/
          ctx[12].call(select1)
        ));
      attr(button0, "class", "aspect-square text-lg");
      attr(button0, "aria-label", "Decrease max depth");
      button0.disabled = button0_disabled_value = /*depth*/
      ctx[2] <= 1;
      attr(span, "class", "font-mono");
      attr(span, "aria-label", "Max depth");
      attr(button1, "class", "aspect-square text-lg");
      attr(button1, "aria-label", "Increase max depth");
      button1.disabled = button1_disabled_value = /*depth*/
      ctx[2] >= /*MAX_DEPTH*/
      ctx[1];
      attr(div0, "class", "flex items-center gap-1");
      attr(div1, "class", "mb-1 flex flex-wrap justify-between gap-3");
      toggle_class(div1, "hidden", !/*plugin*/
      ctx[0].settings.views.page.trail.show_controls);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, select0);
      for (let i = 0; i < 2; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(select0, null);
        }
      }
      select_option(
        select0,
        /*plugin*/
        ctx[0].settings.views.page.trail.format,
        true
      );
      append(div1, t0);
      append(div1, select1);
      for (let i = 0; i < 3; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select1, null);
        }
      }
      select_option(
        select1,
        /*plugin*/
        ctx[0].settings.views.page.trail.selection,
        true
      );
      append(div1, t1);
      mount_component(mergefieldsbutton, div1, null);
      append(div1, t2);
      append(div1, div0);
      append(div0, button0);
      append(button0, t3);
      append(div0, t4);
      append(div0, span);
      append(span, t5);
      append(span, t6);
      append(span, t7);
      append(div0, t8);
      append(div0, button1);
      append(button1, t9);
      insert(target, t10, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            select0,
            "change",
            /*select0_change_handler*/
            ctx[10]
          ),
          listen(
            select0,
            "change",
            /*change_handler*/
            ctx[11]
          ),
          listen(
            select1,
            "change",
            /*select1_change_handler*/
            ctx[12]
          ),
          listen(
            select1,
            "change",
            /*change_handler_1*/
            ctx[13]
          ),
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[15]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[16]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*plugin*/
      1) {
        select_option(
          select0,
          /*plugin*/
          ctx2[0].settings.views.page.trail.format
        );
      }
      if (dirty & /*plugin*/
      1) {
        select_option(
          select1,
          /*plugin*/
          ctx2[0].settings.views.page.trail.selection
        );
      }
      const mergefieldsbutton_changes = {};
      if (!updating_merge_fields && dirty & /*plugin*/
      1) {
        updating_merge_fields = true;
        mergefieldsbutton_changes.merge_fields = /*plugin*/
        ctx2[0].settings.views.page.trail.merge_fields;
        add_flush_callback(() => updating_merge_fields = false);
      }
      mergefieldsbutton.$set(mergefieldsbutton_changes);
      if (!current || dirty & /*depth*/
      4 && button0_disabled_value !== (button0_disabled_value = /*depth*/
      ctx2[2] <= 1)) {
        button0.disabled = button0_disabled_value;
      }
      if (!current || dirty & /*depth*/
      4)
        set_data(
          t5,
          /*depth*/
          ctx2[2]
        );
      if (!current || dirty & /*MAX_DEPTH*/
      2)
        set_data(
          t7,
          /*MAX_DEPTH*/
          ctx2[1]
        );
      if (!current || dirty & /*depth, MAX_DEPTH*/
      6 && button1_disabled_value !== (button1_disabled_value = /*depth*/
      ctx2[2] >= /*MAX_DEPTH*/
      ctx2[1])) {
        button1.disabled = button1_disabled_value;
      }
      if (!current || dirty & /*plugin*/
      1) {
        toggle_class(div1, "hidden", !/*plugin*/
        ctx2[0].settings.views.page.trail.show_controls);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(mergefieldsbutton.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(mergefieldsbutton.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t10);
        detach(if_block_anchor);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      destroy_component(mergefieldsbutton);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block_16(ctx) {
  let option;
  let option_value_value;
  return {
    c() {
      option = element("option");
      option.textContent = `${/*format*/
      ctx[21]} `;
      option.__value = option_value_value = /*format*/
      ctx[21];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_each_block8(ctx) {
  let option;
  let option_value_value;
  return {
    c() {
      option = element("option");
      option.textContent = `${/*s*/
      ctx[18]} `;
      option.__value = option_value_value = /*s*/
      ctx[18];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_if_block_23(ctx) {
  let trailviewpath;
  let current;
  trailviewpath = new TrailViewPath_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      all_paths: (
        /*sorted_paths*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(trailviewpath.$$.fragment);
    },
    m(target, anchor) {
      mount_component(trailviewpath, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const trailviewpath_changes = {};
      if (dirty & /*plugin*/
      1)
        trailviewpath_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*sorted_paths*/
      8)
        trailviewpath_changes.all_paths = /*sorted_paths*/
        ctx2[3];
      trailviewpath.$set(trailviewpath_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(trailviewpath.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(trailviewpath.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(trailviewpath, detaching);
    }
  };
}
function create_if_block_13(ctx) {
  let trailviewgrid;
  let current;
  trailviewgrid = new TrailViewGrid_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      all_paths: (
        /*sorted_paths*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(trailviewgrid.$$.fragment);
    },
    m(target, anchor) {
      mount_component(trailviewgrid, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const trailviewgrid_changes = {};
      if (dirty & /*plugin*/
      1)
        trailviewgrid_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*sorted_paths*/
      8)
        trailviewgrid_changes.all_paths = /*sorted_paths*/
        ctx2[3];
      trailviewgrid.$set(trailviewgrid_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(trailviewgrid.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(trailviewgrid.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(trailviewgrid, detaching);
    }
  };
}
function create_key_block3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block10, create_if_block_33];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*sorted_paths*/
      ctx2[3].length
    )
      return 0;
    if (
      /*plugin*/
      ctx2[0].settings.views.page.trail.no_path_message
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
function create_fragment41(ctx) {
  let div;
  let previous_key = (
    /*sorted_paths*/
    ctx[3]
  );
  let current;
  let key_block = create_key_block3(ctx);
  return {
    c() {
      div = element("div");
      key_block.c();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      key_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*sorted_paths*/
      8 && safe_not_equal(previous_key, previous_key = /*sorted_paths*/
      ctx2[3])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block3(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div, null);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      key_block.d(detaching);
    }
  };
}
function instance41($$self, $$props, $$invalidate) {
  let edge_field_labels;
  let all_paths;
  let selected_paths;
  let MAX_DEPTH2;
  let depth;
  let sliced_paths;
  let deduped_paths;
  let sorted_paths;
  let { plugin } = $$props;
  let { file_path } = $$props;
  const base_traversal = (attr2) => Traverse.tree_to_all_paths(Traverse.build_tree(plugin.graph, file_path, {}, (e) => has_edge_attrs(e, attr2)));
  function select0_change_handler() {
    plugin.settings.views.page.trail.format = select_value(this);
    $$invalidate(0, plugin);
  }
  const change_handler = async () => await plugin.saveSettings();
  function select1_change_handler() {
    plugin.settings.views.page.trail.selection = select_value(this);
    $$invalidate(0, plugin);
  }
  const change_handler_1 = async () => await plugin.saveSettings();
  function mergefieldsbutton_merge_fields_binding(value) {
    if ($$self.$$.not_equal(plugin.settings.views.page.trail.merge_fields, value)) {
      plugin.settings.views.page.trail.merge_fields = value;
      $$invalidate(0, plugin);
    }
  }
  const click_handler = () => $$invalidate(2, depth = Math.max(1, depth - 1));
  const click_handler_1 = () => $$invalidate(2, depth = Math.min(MAX_DEPTH2, depth + 1));
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("file_path" in $$props2)
      $$invalidate(4, file_path = $$props2.file_path);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*plugin*/
    1) {
      $:
        $$invalidate(9, edge_field_labels = resolve_field_group_labels(plugin.settings.edge_field_groups, plugin.settings.views.page.trail.field_group_labels));
    }
    if ($$self.$$.dirty & /*plugin, file_path, edge_field_labels*/
    529) {
      $:
        $$invalidate(8, all_paths = plugin.graph.hasNode(file_path) ? plugin.settings.views.page.trail.merge_fields ? base_traversal({ $or_fields: edge_field_labels }) : edge_field_labels.flatMap((field) => base_traversal({ field })) : []);
    }
    if ($$self.$$.dirty & /*plugin, all_paths*/
    257) {
      $:
        $$invalidate(7, selected_paths = plugin.settings.views.page.trail.selection === "all" ? all_paths : plugin.settings.views.page.trail.selection === "shortest" ? all_paths.slice(-1) : plugin.settings.views.page.trail.selection === "longest" ? all_paths.slice(0, 1) : [[]]);
    }
    if ($$self.$$.dirty & /*selected_paths*/
    128) {
      $:
        $$invalidate(1, MAX_DEPTH2 = Math.max(0, ...selected_paths.map((p) => p.length)));
    }
    if ($$self.$$.dirty & /*MAX_DEPTH, plugin*/
    3) {
      $:
        $$invalidate(2, depth = Math.min(MAX_DEPTH2, plugin.settings.views.page.trail.default_depth));
    }
    if ($$self.$$.dirty & /*selected_paths, depth*/
    132) {
      $:
        $$invalidate(6, sliced_paths = selected_paths.map((path) => path.slice(0, depth)));
    }
    if ($$self.$$.dirty & /*depth, MAX_DEPTH, sliced_paths*/
    70) {
      $:
        $$invalidate(5, deduped_paths = // There are no duplicates if the depth is the max depth.
        // The traversal wouldn't add them in the first place.
        depth === MAX_DEPTH2 ? sliced_paths : remove_duplicates_by(sliced_paths, (path) => path.map((p) => p.target_id).join("/")));
    }
    if ($$self.$$.dirty & /*deduped_paths*/
    32) {
      $:
        $$invalidate(3, sorted_paths = deduped_paths.sort((a, b) => {
          const len_diff = b.length - a.length;
          if (len_diff !== 0)
            return len_diff;
          else
            return a[0].target_id.localeCompare(b[0].target_id);
        }));
    }
  };
  return [
    plugin,
    MAX_DEPTH2,
    depth,
    sorted_paths,
    file_path,
    deduped_paths,
    sliced_paths,
    selected_paths,
    all_paths,
    edge_field_labels,
    select0_change_handler,
    change_handler,
    select1_change_handler,
    change_handler_1,
    mergefieldsbutton_merge_fields_binding,
    click_handler,
    click_handler_1
  ];
}
var TrailView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance41, create_fragment41, safe_not_equal, { plugin: 0, file_path: 4 });
  }
};
var TrailView_default = TrailView;

// src/components/page_views/index.svelte
function create_if_block11(ctx) {
  let div;
  let t;
  let current;
  let if_block0 = (
    /*enabled_views*/
    ctx[2].grid && create_if_block_24(ctx)
  );
  let if_block1 = (
    /*enabled_views*/
    ctx[2].prev_next && create_if_block_14(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr(div, "class", "markdown-rendered mb-4 flex flex-col gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*enabled_views*/
        ctx2[2].grid
      )
        if_block0.p(ctx2, dirty);
      if (
        /*enabled_views*/
        ctx2[2].prev_next
      )
        if_block1.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_24(ctx) {
  let trailview;
  let current;
  trailview = new TrailView_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      file_path: (
        /*file_path*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(trailview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(trailview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const trailview_changes = {};
      if (dirty & /*plugin*/
      1)
        trailview_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*file_path*/
      2)
        trailview_changes.file_path = /*file_path*/
        ctx2[1];
      trailview.$set(trailview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(trailview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(trailview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(trailview, detaching);
    }
  };
}
function create_if_block_14(ctx) {
  let prevnextview;
  let current;
  prevnextview = new PrevNextView_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      file_path: (
        /*file_path*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(prevnextview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(prevnextview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const prevnextview_changes = {};
      if (dirty & /*plugin*/
      1)
        prevnextview_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*file_path*/
      2)
        prevnextview_changes.file_path = /*file_path*/
        ctx2[1];
      prevnextview.$set(prevnextview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(prevnextview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(prevnextview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(prevnextview, detaching);
    }
  };
}
function create_fragment42(ctx) {
  let show_if = Object.values(
    /*enabled_views*/
    ctx[2]
  ).some(Boolean);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block11(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (show_if)
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance42($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let { file_path } = $$props;
  const enabled_views = {
    grid: plugin.settings.views.page.trail.enabled,
    prev_next: plugin.settings.views.page.prev_next.enabled
  };
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("file_path" in $$props2)
      $$invalidate(1, file_path = $$props2.file_path);
  };
  return [plugin, file_path, enabled_views];
}
var Page_views = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance42, create_fragment42, safe_not_equal, { plugin: 0, file_path: 1 });
  }
};
var page_views_default = Page_views;

// src/views/page.ts
var redraw_page_views = (plugin) => {
  const markdown_views = plugin.app.workspace.getLeavesOfType("markdown");
  if (!markdown_views.length) {
    log.info("redraw_page_views > No markdown views found");
    return;
  }
  markdown_views.forEach((leaf) => {
    var _a, _b, _c;
    if (!(leaf.view instanceof import_obsidian22.MarkdownView))
      return;
    const markdown_view = leaf.view;
    const mode = markdown_view.getMode();
    const page_views_el = (_a = markdown_view.containerEl.querySelector(".BC-page-views")) != null ? _a : markdown_view.containerEl.createDiv({
      cls: "BC-page-views w-full mx-auto"
    });
    const max_width = plugin.settings.views.page.all.readable_line_width ? "var(--file-line-width)" : "none";
    page_views_el.setAttribute("style", `max-width: ${max_width};`);
    page_views_el.classList.toggle(
      "BC-page-views-sticky",
      plugin.settings.views.page.all.sticky
    );
    page_views_el.empty();
    if (mode === "preview") {
      const view_parent = markdown_view.containerEl.querySelector(
        ".markdown-reading-view > .markdown-preview-view"
      );
      if (!view_parent) {
        return log.info(
          "redraw_page_views > No view_parent (mode=preview)"
        );
      }
      view_parent.insertBefore(page_views_el, view_parent.firstChild);
    } else {
      const view_parent = markdown_view.containerEl.querySelector(".cm-scroller");
      if (!view_parent) {
        return log.info(
          "redraw_page_views > No view_parent (mode=source)"
        );
      }
      view_parent.addClass("flex-col");
      view_parent.insertBefore(page_views_el, view_parent.firstChild);
    }
    new page_views_default({
      target: page_views_el,
      props: { plugin, file_path: (_c = (_b = markdown_view.file) == null ? void 0 : _b.path) != null ? _c : "" }
    });
  });
};

// src/settings/PageViewSettings.ts
var _add_settings_page_views = (plugin, container_el) => {
  new_setting(container_el, {
    name: "Sticky",
    desc: "Keep the page views pinned to the top of the note as you scroll",
    toggle: {
      value: plugin.settings.views.page.all.sticky,
      cb: async (value) => {
        plugin.settings.views.page.all.sticky = value;
        await plugin.saveSettings();
        redraw_page_views(plugin);
      }
    }
  });
  new_setting(container_el, {
    name: "Readable line width",
    desc: "Limit to the width of the text in the editor",
    toggle: {
      value: plugin.settings.views.page.all.readable_line_width,
      cb: async (value) => {
        plugin.settings.views.page.all.readable_line_width = value;
        await plugin.saveSettings();
        redraw_page_views(plugin);
      }
    }
  });
};

// src/settings/PrevNextSettings.ts
var import_obsidian23 = require("obsidian");
var _add_settings_prev_next_view = (plugin, containerEl) => {
  new import_obsidian23.Setting(containerEl).setName("Enable Previous/Next view").setDesc("Show the Previous/Next view at the top of the page").addToggle((toggle) => {
    toggle.setValue(plugin.settings.views.page.prev_next.enabled).onChange(async (value) => {
      plugin.settings.views.page.prev_next.enabled = value;
      await Promise.all([plugin.saveSettings()]);
      plugin.refresh({
        rebuild_graph: false,
        active_file_store: false
      });
    });
  });
  new FieldGroupLabelsSettingItem_default({
    target: containerEl,
    props: {
      name: "Field Groups for Left",
      description: "Select the field groups to show in the left side of this view",
      edge_field_groups: plugin.settings.edge_field_groups,
      field_group_labels: plugin.settings.views.page.prev_next.field_group_labels.prev
    }
  }).$on("select", async (e) => {
    plugin.settings.views.page.prev_next.field_group_labels.prev = e.detail;
    await Promise.all([
      plugin.saveSettings(),
      plugin.refresh({ rebuild_graph: false })
    ]);
  });
  new FieldGroupLabelsSettingItem_default({
    target: containerEl,
    props: {
      name: "Field Groups for Right",
      description: "Select the field groups to show in the right side of this view",
      edge_field_groups: plugin.settings.edge_field_groups,
      field_group_labels: plugin.settings.views.page.prev_next.field_group_labels.next
    }
  }).$on("select", async (e) => {
    plugin.settings.views.page.prev_next.field_group_labels.next = e.detail;
    await Promise.all([
      plugin.saveSettings(),
      plugin.refresh({ rebuild_graph: false })
    ]);
  });
  _add_settings_show_node_options(plugin, containerEl, {
    get: () => plugin.settings.views.page.prev_next.show_node_options,
    set: (value) => plugin.settings.views.page.prev_next.show_node_options = value
  });
};

// src/settings/RebuildGraphSettings.ts
var _add_settings_rebuild_graph = (plugin, containerEl) => {
  new_setting(containerEl, {
    name: "Notify on refresh",
    desc: "Show a notification when the graph is rebuilt",
    toggle: {
      value: plugin.settings.commands.rebuild_graph.notify,
      cb: async (value) => {
        plugin.settings.commands.rebuild_graph.notify = value;
        await Promise.all([plugin.saveSettings(), plugin.refresh({})]);
      }
    }
  });
  new_setting(containerEl, {
    name: "Triggers",
    desc: "When to rebuild the graph",
    checklist: {
      options: {
        note_save: plugin.settings.commands.rebuild_graph.trigger.note_save,
        layout_change: plugin.settings.commands.rebuild_graph.trigger.layout_change
      },
      cb: async (value) => {
        plugin.settings.commands.rebuild_graph.trigger = value;
        await Promise.all([plugin.saveSettings(), plugin.refresh({})]);
      }
    }
  });
};

// src/settings/RegexNoteSettings.ts
var _add_settings_regex_note = (plugin, containerEl) => {
  new_setting(containerEl, {
    name: "Default Field",
    desc: "Field to use if the BC-regex-note-field is not specified",
    select: {
      value: plugin.settings.explicit_edge_sources.regex_note.default_field,
      options: plugin.settings.edge_fields.map((f) => f.label),
      cb: async (value) => {
        plugin.settings.explicit_edge_sources.regex_note.default_field = value;
        await Promise.all([plugin.refresh(), plugin.saveSettings()]);
      }
    }
  });
};

// src/settings/TagNoteSettings.ts
var _add_settings_tag_note = (plugin, containerEl) => {
  new_setting(containerEl, {
    name: "Default Field",
    desc: "Field to use if the BC-tag-note-field is not specified",
    select: {
      value: plugin.settings.explicit_edge_sources.tag_note.default_field,
      options: plugin.settings.edge_fields.map((f) => f.label),
      cb: async (value) => {
        plugin.settings.explicit_edge_sources.tag_note.default_field = value;
        await Promise.all([plugin.refresh(), plugin.saveSettings()]);
      }
    }
  });
};

// src/settings/ThreadSettings.ts
var _add_settings_thread = (plugin, contentEl) => {
  const { settings } = plugin;
  new_setting(contentEl, {
    name: "Destination",
    desc: "Where to write the new edge to",
    select: {
      options: ["frontmatter", "dataview-inline", "none"],
      value: settings.commands.thread.default_options.destination,
      cb: async (value) => {
        settings.commands.thread.default_options.destination = value;
        await plugin.saveSettings();
      }
    }
  });
  new_setting(contentEl, {
    name: "Target Path Template",
    desc: "The template to use for the target path. You don't need to add the .md extension.",
    input: {
      value: settings.commands.thread.default_options.target_path_template,
      cb: async (value) => {
        settings.commands.thread.default_options.target_path_template = value;
        await plugin.saveSettings();
      }
    }
  });
};

// src/settings/TreeViewSettings.ts
var _add_settings_tree_view = (plugin, containerEl) => {
  new_setting(containerEl, {
    name: "Collapse",
    desc: "Collapse the tree by default",
    toggle: {
      value: plugin.settings.views.side.tree.collapse,
      cb: async (checked) => {
        plugin.settings.views.side.tree.collapse = checked;
        await Promise.all([
          plugin.saveSettings(),
          plugin.refresh({
            redraw_side_views: true,
            rebuild_graph: false
          })
        ]);
      }
    }
  });
  new EdgeSortIdSettingItem_default({
    target: containerEl,
    props: { edge_sort_id: plugin.settings.views.side.tree.edge_sort_id }
  }).$on("select", async (e) => {
    plugin.settings.views.side.tree.edge_sort_id = e.detail;
    await Promise.all([
      plugin.saveSettings(),
      plugin.refresh({
        redraw_side_views: true,
        rebuild_graph: false
      })
    ]);
  });
  new ShowAttributesSettingItem_default({
    target: containerEl,
    props: {
      show_attributes: plugin.settings.views.side.tree.show_attributes
    }
  }).$on("select", async (e) => {
    plugin.settings.views.side.tree.show_attributes = e.detail;
    await Promise.all([
      plugin.saveSettings(),
      plugin.refresh({
        redraw_side_views: true,
        rebuild_graph: false
      })
    ]);
  });
  new FieldGroupLabelsSettingItem_default({
    target: containerEl,
    props: {
      edge_field_groups: plugin.settings.edge_field_groups,
      field_group_labels: plugin.settings.views.side.tree.field_group_labels
    }
  }).$on("select", async (e) => {
    plugin.settings.views.side.tree.field_group_labels = e.detail;
    await Promise.all([
      plugin.saveSettings(),
      plugin.refresh({
        redraw_side_views: true,
        rebuild_graph: false
      })
    ]);
  });
  new_setting(containerEl, {
    name: "Merge Fields",
    desc: "Merge fields in the traversal, instead of keeping their paths separate",
    toggle: {
      value: plugin.settings.views.side.tree.merge_fields,
      cb: async (value) => {
        plugin.settings.views.side.tree.merge_fields = value;
        await Promise.all([
          plugin.saveSettings(),
          plugin.refresh({
            redraw_side_views: true,
            rebuild_graph: false
          })
        ]);
      }
    }
  });
  _add_settings_show_node_options(plugin, containerEl, {
    get: () => plugin.settings.views.side.tree.show_node_options,
    set: (value) => plugin.settings.views.side.tree.show_node_options = value
  });
};

// src/settings/SettingsTab.ts
var make_details_el = (parent, o) => {
  let details;
  let summary;
  let children2;
  details = parent.createEl("details", {
    cls: "tree-item",
    ...o == null ? void 0 : o.d
  });
  summary = details.createEl("summary", {
    cls: "text-xl p-1 tree-item-self is-clickable",
    ...o == null ? void 0 : o.s
  });
  children2 = details.createEl("div", { cls: "tree-item-children pl-4" });
  return {
    details,
    summary,
    children: children2
  };
};
var BreadcrumbsSettingTab = class extends import_obsidian24.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.components = [];
    this.plugin = plugin;
  }
  display() {
    const { containerEl, plugin } = this;
    containerEl.empty();
    containerEl.addClass("BC-settings-tab");
    this.components.push(
      new EdgeFieldSettings_default({
        props: { plugin },
        target: make_details_el(containerEl, {
          s: { text: "> Edge Fields" }
        }).children
      })
    );
    containerEl.createEl("hr");
    containerEl.createEl("h3", { text: "Implied Relations" });
    this.components.push(
      new TransitiveImpliedRelations_default({
        props: { plugin },
        target: make_details_el(containerEl, {
          s: { text: "> Transitive" }
        }).children
      })
    );
    containerEl.createEl("hr");
    containerEl.createEl("h3", { text: "Edge Sources" });
    _add_settings_tag_note(
      plugin,
      make_details_el(containerEl, { s: { text: "> Tag Notes" } }).children
    );
    _add_settings_list_note(
      plugin,
      make_details_el(containerEl, { s: { text: "> List Notes" } }).children
    );
    _add_settings_date_note(
      plugin,
      make_details_el(containerEl, { s: { text: "> Date Notes" } }).children
    );
    _add_settings_regex_note(
      plugin,
      make_details_el(containerEl, { s: { text: "> Regex Notes" } }).children
    );
    _add_settings_dendron_note(
      plugin,
      make_details_el(containerEl, { s: { text: "> Dendron Notes" } }).children
    );
    _add_settings_johnny_decimal_note(
      plugin,
      make_details_el(containerEl, {
        s: { text: "> Johnny Decimal Notes" }
      }).children
    );
    containerEl.createEl("hr");
    containerEl.createEl("h3", { text: "Views" });
    _add_settings_matrix(
      plugin,
      make_details_el(containerEl, { s: { text: "> Matrix" } }).children
    );
    const page_details = make_details_el(containerEl, {
      s: { text: "> Page" }
    }).children;
    page_details.createEl("h5", { text: "General" });
    _add_settings_page_views(plugin, page_details);
    page_details.createEl("h5", { text: "Trail" });
    _add_settings_trail_view(plugin, page_details);
    page_details.createEl("h5", { text: "Previous/Next" });
    _add_settings_prev_next_view(plugin, page_details);
    _add_settings_tree_view(
      plugin,
      make_details_el(containerEl, { s: { text: "> Tree" } }).children
    );
    _add_settings_codeblocks(
      plugin,
      make_details_el(containerEl, { s: { text: "> Codeblocks" } }).children
    );
    containerEl.createEl("hr");
    containerEl.createEl("h3", { text: "Commands" });
    _add_settings_rebuild_graph(
      plugin,
      make_details_el(containerEl, { s: { text: "> Rebuild Graph" } }).children
    );
    _add_settings_list_index(
      plugin,
      make_details_el(containerEl, { s: { text: "> List Index" } }).children
    );
    _add_settings_freeze_implied_edges(
      plugin,
      make_details_el(containerEl, {
        s: { text: "> Freeze Implied Edges" }
      }).children
    );
    _add_settings_thread(
      plugin,
      make_details_el(containerEl, { s: { text: "> Thread" } }).children
    );
    containerEl.createEl("hr");
    containerEl.createEl("h3", { text: "Suggestors" });
    _add_settings_edge_field_suggestor(
      plugin,
      make_details_el(containerEl, {
        s: { text: "> Edge Field Suggestor" }
      }).children
    );
    containerEl.createEl("hr");
    _add_settings_debug(
      plugin,
      make_details_el(containerEl, { s: { text: "> Debug" } }).children
    );
  }
  hide() {
    if (this.plugin.settings.is_dirty) {
      new import_obsidian24.Notice(
        "\u26A0\uFE0F Exited without saving settings. Your changes are still in effect, but were not saved. Go back and click 'Save' if you want them to persist. Otherwise, reload Obsidian to revert to the last saved settings."
      );
    }
    this.components.forEach((c) => c.$destroy());
  }
};

// src/views/matrix.ts
var import_obsidian25 = require("obsidian");

// src/components/button/ChevronCollapseButton.svelte
function create_else_block6(ctx) {
  let chevronsupdown;
  let current;
  chevronsupdown = new chevrons_up_down_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      create_component(chevronsupdown.$$.fragment);
    },
    m(target, anchor) {
      mount_component(chevronsupdown, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(chevronsupdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chevronsupdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(chevronsupdown, detaching);
    }
  };
}
function create_if_block12(ctx) {
  let chevronsdownup;
  let current;
  chevronsdownup = new chevrons_down_up_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      create_component(chevronsdownup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(chevronsdownup, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(chevronsdownup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chevronsdownup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(chevronsdownup, detaching);
    }
  };
}
function create_fragment43(ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let button_aria_label_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block12, create_else_block6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*collapse*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(
        button,
        "class",
        /*cls*/
        ctx[1]
      );
      attr(button, "aria-label", button_aria_label_value = /*collapse*/
      ctx[0] ? "Expand" : "Collapse");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(button, null);
      }
      if (!current || dirty & /*cls*/
      2) {
        attr(
          button,
          "class",
          /*cls*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*collapse*/
      1 && button_aria_label_value !== (button_aria_label_value = /*collapse*/
      ctx2[0] ? "Expand" : "Collapse")) {
        attr(button, "aria-label", button_aria_label_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function instance43($$self, $$props, $$invalidate) {
  let { cls = "" } = $$props;
  let { collapse } = $$props;
  const click_handler = () => $$invalidate(0, collapse = !collapse);
  $$self.$$set = ($$props2) => {
    if ("cls" in $$props2)
      $$invalidate(1, cls = $$props2.cls);
    if ("collapse" in $$props2)
      $$invalidate(0, collapse = $$props2.collapse);
  };
  return [collapse, cls, click_handler];
}
var ChevronCollapseButton = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance43, create_fragment43, safe_not_equal, { cls: 1, collapse: 0 });
  }
};
var ChevronCollapseButton_default = ChevronCollapseButton;

// src/components/button/RebuildGraphButton.svelte
function create_fragment44(ctx) {
  let button;
  let rotateccw;
  let current;
  let mounted;
  let dispose;
  rotateccw = new rotate_ccw_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      button = element("button");
      create_component(rotateccw.$$.fragment);
      attr(
        button,
        "class",
        /*cls*/
        ctx[0]
      );
      attr(button, "aria-label", "Rebuild Graph");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(rotateccw, button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*cls*/
      1) {
        attr(
          button,
          "class",
          /*cls*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(rotateccw.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rotateccw.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(rotateccw);
      mounted = false;
      dispose();
    }
  };
}
function instance44($$self, $$props, $$invalidate) {
  let { cls = "" } = $$props;
  let { plugin } = $$props;
  const click_handler = () => plugin.refresh();
  $$self.$$set = ($$props2) => {
    if ("cls" in $$props2)
      $$invalidate(0, cls = $$props2.cls);
    if ("plugin" in $$props2)
      $$invalidate(1, plugin = $$props2.plugin);
  };
  return [cls, plugin, click_handler];
}
var RebuildGraphButton = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance44, create_fragment44, safe_not_equal, { cls: 0, plugin: 1 });
  }
};
var RebuildGraphButton_default = RebuildGraphButton;

// src/components/obsidian/TreeItemFlair.svelte
function create_fragment45(ctx) {
  let div;
  let span;
  let t;
  let span_class_value;
  return {
    c() {
      div = element("div");
      span = element("span");
      t = text(
        /*label*/
        ctx[1]
      );
      attr(span, "class", span_class_value = /*cls*/
      ctx[0] + " tree-item-flair");
      attr(
        span,
        "aria-label",
        /*aria_label*/
        ctx[2]
      );
      attr(div, "class", "tree-item-flair-outer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, t);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*label*/
      2)
        set_data(
          t,
          /*label*/
          ctx2[1]
        );
      if (dirty & /*cls*/
      1 && span_class_value !== (span_class_value = /*cls*/
      ctx2[0] + " tree-item-flair")) {
        attr(span, "class", span_class_value);
      }
      if (dirty & /*aria_label*/
      4) {
        attr(
          span,
          "aria-label",
          /*aria_label*/
          ctx2[2]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance45($$self, $$props, $$invalidate) {
  let { cls = "" } = $$props;
  let { label = "" } = $$props;
  let { aria_label = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("cls" in $$props2)
      $$invalidate(0, cls = $$props2.cls);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("aria_label" in $$props2)
      $$invalidate(2, aria_label = $$props2.aria_label);
  };
  return [cls, label, aria_label];
}
var TreeItemFlair = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance45, create_fragment45, safe_not_equal, { cls: 0, label: 1, aria_label: 2 });
  }
};
var TreeItemFlair_default = TreeItemFlair;

// src/components/side_views/MatrixEdgeField.svelte
function get_each_context9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_each_block9(ctx) {
  let div2;
  let div1;
  let div0;
  let edgelink;
  let t0;
  let treeitemflair;
  let t1;
  let current;
  edgelink = new EdgeLink_default({
    props: {
      edge: (
        /*edge*/
        ctx[8]
      ),
      plugin: (
        /*plugin*/
        ctx[3]
      ),
      show_node_options: (
        /*show_node_options*/
        ctx[6]
      ),
      cls: "grow tree-item-inner-text"
    }
  });
  treeitemflair = new TreeItemFlair_default({
    props: {
      cls: "font-mono",
      label: (
        /*edge*/
        ctx[8].attr.explicit ? "x" : "i"
      ),
      aria_label: url_search_params(untyped_pick(
        /*edge*/
        ctx[8].attr,
        /*show_attributes*/
        ctx[4]
      ), { trim_lone_param: true })
    }
  });
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      create_component(edgelink.$$.fragment);
      t0 = space();
      create_component(treeitemflair.$$.fragment);
      t1 = space();
      attr(div0, "class", "tree-item-inner flex grow");
      attr(div1, "class", "tree-item-self is-clickable");
      attr(div2, "class", "tree-item");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      mount_component(edgelink, div0, null);
      append(div1, t0);
      mount_component(treeitemflair, div1, null);
      append(div2, t1);
      current = true;
    },
    p(ctx2, dirty) {
      const edgelink_changes = {};
      if (dirty & /*edges, sort*/
      34)
        edgelink_changes.edge = /*edge*/
        ctx2[8];
      if (dirty & /*plugin*/
      8)
        edgelink_changes.plugin = /*plugin*/
        ctx2[3];
      edgelink.$set(edgelink_changes);
      const treeitemflair_changes = {};
      if (dirty & /*edges, sort*/
      34)
        treeitemflair_changes.label = /*edge*/
        ctx2[8].attr.explicit ? "x" : "i";
      if (dirty & /*edges, sort, show_attributes*/
      50)
        treeitemflair_changes.aria_label = url_search_params(untyped_pick(
          /*edge*/
          ctx2[8].attr,
          /*show_attributes*/
          ctx2[4]
        ), { trim_lone_param: true });
      treeitemflair.$set(treeitemflair_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(edgelink.$$.fragment, local);
      transition_in(treeitemflair.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edgelink.$$.fragment, local);
      transition_out(treeitemflair.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(edgelink);
      destroy_component(treeitemflair);
    }
  };
}
function create_key_block4(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*edges*/
    ctx[1].sort(
      /*sort*/
      ctx[5]
    )
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block9(get_each_context9(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*edges, sort, show_attributes, plugin, show_node_options*/
      122) {
        each_value = ensure_array_like(
          /*edges*/
          ctx2[1].sort(
            /*sort*/
            ctx2[5]
          )
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context9(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block9(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment46(ctx) {
  let details;
  let summary;
  let div0;
  let chevronopener;
  let t0;
  let div1;
  let span0;
  let t1_value = (
    /*field*/
    ctx[2].label + ""
  );
  let t1;
  let t2;
  let div2;
  let span1;
  let t3_value = (
    /*edges*/
    ctx[1].length + ""
  );
  let t3;
  let t4;
  let div3;
  let previous_key = (
    /*sort*/
    ctx[5]
  );
  let details_class_value;
  let current;
  let mounted;
  let dispose;
  chevronopener = new ChevronOpener_default({ props: { open: (
    /*open*/
    ctx[0]
  ) } });
  let key_block = create_key_block4(ctx);
  return {
    c() {
      details = element("details");
      summary = element("summary");
      div0 = element("div");
      create_component(chevronopener.$$.fragment);
      t0 = space();
      div1 = element("div");
      span0 = element("span");
      t1 = text(t1_value);
      t2 = space();
      div2 = element("div");
      span1 = element("span");
      t3 = text(t3_value);
      t4 = space();
      div3 = element("div");
      key_block.c();
      attr(div0, "class", "tree-item-icon collapse-icon");
      attr(span0, "class", "tree-item-inner-text");
      attr(div1, "class", "tree-item-inner");
      attr(span1, "class", "tree-item-flair font-mono text-lg");
      attr(div2, "class", "tree-item-flair-outer");
      attr(summary, "class", "tree-item-self is-clickable mod-collapsible text-lg");
      attr(div3, "class", "tree-item-children flex flex-col");
      attr(details, "class", details_class_value = "BC-matrix-view-field BC-matrix-view-field-" + /*field*/
      ctx[2].label + " tree-item");
    },
    m(target, anchor) {
      insert(target, details, anchor);
      append(details, summary);
      append(summary, div0);
      mount_component(chevronopener, div0, null);
      append(summary, t0);
      append(summary, div1);
      append(div1, span0);
      append(span0, t1);
      append(summary, t2);
      append(summary, div2);
      append(div2, span1);
      append(span1, t3);
      append(details, t4);
      append(details, div3);
      key_block.m(div3, null);
      details.open = /*open*/
      ctx[0];
      current = true;
      if (!mounted) {
        dispose = listen(
          details,
          "toggle",
          /*details_toggle_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const chevronopener_changes = {};
      if (dirty & /*open*/
      1)
        chevronopener_changes.open = /*open*/
        ctx2[0];
      chevronopener.$set(chevronopener_changes);
      if ((!current || dirty & /*field*/
      4) && t1_value !== (t1_value = /*field*/
      ctx2[2].label + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & /*edges*/
      2) && t3_value !== (t3_value = /*edges*/
      ctx2[1].length + ""))
        set_data(t3, t3_value);
      if (dirty & /*sort*/
      32 && safe_not_equal(previous_key, previous_key = /*sort*/
      ctx2[5])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block4(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div3, null);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (!current || dirty & /*field*/
      4 && details_class_value !== (details_class_value = "BC-matrix-view-field BC-matrix-view-field-" + /*field*/
      ctx2[2].label + " tree-item")) {
        attr(details, "class", details_class_value);
      }
      if (dirty & /*open*/
      1) {
        details.open = /*open*/
        ctx2[0];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(chevronopener.$$.fragment, local);
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(chevronopener.$$.fragment, local);
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(details);
      }
      destroy_component(chevronopener);
      key_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance46($$self, $$props, $$invalidate) {
  let { open } = $$props;
  let { edges } = $$props;
  let { field } = $$props;
  let { plugin } = $$props;
  let { show_attributes } = $$props;
  let { show_node_options } = plugin.settings.views.side.matrix;
  let { sort } = $$props;
  function details_toggle_handler() {
    open = this.open;
    $$invalidate(0, open);
  }
  $$self.$$set = ($$props2) => {
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("edges" in $$props2)
      $$invalidate(1, edges = $$props2.edges);
    if ("field" in $$props2)
      $$invalidate(2, field = $$props2.field);
    if ("plugin" in $$props2)
      $$invalidate(3, plugin = $$props2.plugin);
    if ("show_attributes" in $$props2)
      $$invalidate(4, show_attributes = $$props2.show_attributes);
    if ("sort" in $$props2)
      $$invalidate(5, sort = $$props2.sort);
  };
  return [
    open,
    edges,
    field,
    plugin,
    show_attributes,
    sort,
    show_node_options,
    details_toggle_handler
  ];
}
var MatrixEdgeField = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance46, create_fragment46, safe_not_equal, {
      open: 0,
      edges: 1,
      field: 2,
      plugin: 3,
      show_attributes: 4,
      sort: 5
    });
  }
};
var MatrixEdgeField_default = MatrixEdgeField;

// src/components/side_views/Matrix.svelte
function get_each_context10(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  const constants_0 = (
    /*grouped_out_edges*/
    child_ctx[6][
      /*field*/
      child_ctx[13].label
    ]
  );
  child_ctx[14] = constants_0;
  return child_ctx;
}
function create_else_block7(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "No outgoings edges";
      attr(p, "class", "search-empty-state");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block13(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*plugin*/
    ctx[0].settings.edge_fields
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block10(get_each_context10(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*sort, grouped_out_edges, plugin, show_attributes, collapse*/
      121) {
        each_value = ensure_array_like(
          /*plugin*/
          ctx2[0].settings.edge_fields
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context10(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block10(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_15(ctx) {
  let matrixedgefield;
  let current;
  matrixedgefield = new MatrixEdgeField_default({
    props: {
      sort: (
        /*sort*/
        ctx[5]
      ),
      edges: (
        /*edges*/
        ctx[14]
      ),
      field: (
        /*field*/
        ctx[13]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      show_attributes: (
        /*show_attributes*/
        ctx[3]
      ),
      open: !/*collapse*/
      ctx[4]
    }
  });
  return {
    c() {
      create_component(matrixedgefield.$$.fragment);
    },
    m(target, anchor) {
      mount_component(matrixedgefield, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const matrixedgefield_changes = {};
      if (dirty & /*sort*/
      32)
        matrixedgefield_changes.sort = /*sort*/
        ctx2[5];
      if (dirty & /*grouped_out_edges, plugin*/
      65)
        matrixedgefield_changes.edges = /*edges*/
        ctx2[14];
      if (dirty & /*plugin*/
      1)
        matrixedgefield_changes.field = /*field*/
        ctx2[13];
      if (dirty & /*plugin*/
      1)
        matrixedgefield_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*show_attributes*/
      8)
        matrixedgefield_changes.show_attributes = /*show_attributes*/
        ctx2[3];
      if (dirty & /*collapse*/
      16)
        matrixedgefield_changes.open = !/*collapse*/
        ctx2[4];
      matrixedgefield.$set(matrixedgefield_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(matrixedgefield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(matrixedgefield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(matrixedgefield, detaching);
    }
  };
}
function create_each_block10(ctx) {
  var _a;
  let if_block_anchor;
  let current;
  let if_block = (
    /*edges*/
    ((_a = ctx[14]) == null ? void 0 : _a.length) && create_if_block_15(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      if (
        /*edges*/
        (_a2 = ctx2[14]) == null ? void 0 : _a2.length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*grouped_out_edges, plugin*/
          65) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_15(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_key_block5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block13, create_else_block7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*grouped_out_edges*/
      ctx2[6]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_fragment47(ctx) {
  let div2;
  let div1;
  let div0;
  let rebuildgraphbutton;
  let t0;
  let edgesortidselector;
  let updating_edge_sort_id;
  let t1;
  let chevroncollapsebutton;
  let updating_collapse;
  let t2;
  let showattributesselectormenu;
  let updating_show_attributes;
  let t3;
  let fieldgroupselector;
  let updating_field_group_labels;
  let t4;
  let previous_key = (
    /*grouped_out_edges*/
    ctx[6]
  );
  let current;
  rebuildgraphbutton = new RebuildGraphButton_default({
    props: {
      cls: "clickable-icon nav-action-button",
      plugin: (
        /*plugin*/
        ctx[0]
      )
    }
  });
  function edgesortidselector_edge_sort_id_binding(value) {
    ctx[9](value);
  }
  let edgesortidselector_props = {
    cls: "clickable-icon nav-action-button",
    exclude_fields: ["field", "neighbour-field:"]
  };
  if (
    /*edge_sort_id*/
    ctx[1] !== void 0
  ) {
    edgesortidselector_props.edge_sort_id = /*edge_sort_id*/
    ctx[1];
  }
  edgesortidselector = new EdgeSortIdSelector_default({ props: edgesortidselector_props });
  binding_callbacks.push(() => bind(edgesortidselector, "edge_sort_id", edgesortidselector_edge_sort_id_binding));
  function chevroncollapsebutton_collapse_binding(value) {
    ctx[10](value);
  }
  let chevroncollapsebutton_props = { cls: "clickable-icon nav-action-button" };
  if (
    /*collapse*/
    ctx[4] !== void 0
  ) {
    chevroncollapsebutton_props.collapse = /*collapse*/
    ctx[4];
  }
  chevroncollapsebutton = new ChevronCollapseButton_default({ props: chevroncollapsebutton_props });
  binding_callbacks.push(() => bind(chevroncollapsebutton, "collapse", chevroncollapsebutton_collapse_binding));
  function showattributesselectormenu_show_attributes_binding(value) {
    ctx[11](value);
  }
  let showattributesselectormenu_props = {
    cls: "clickable-icon nav-action-button",
    exclude_attributes: ["field", "explicit"]
  };
  if (
    /*show_attributes*/
    ctx[3] !== void 0
  ) {
    showattributesselectormenu_props.show_attributes = /*show_attributes*/
    ctx[3];
  }
  showattributesselectormenu = new ShowAttributesSelectorMenu_default({ props: showattributesselectormenu_props });
  binding_callbacks.push(() => bind(showattributesselectormenu, "show_attributes", showattributesselectormenu_show_attributes_binding));
  function fieldgroupselector_field_group_labels_binding(value) {
    ctx[12](value);
  }
  let fieldgroupselector_props = {
    cls: "clickable-icon nav-action-button",
    edge_field_groups: (
      /*plugin*/
      ctx[0].settings.edge_field_groups
    )
  };
  if (
    /*field_group_labels*/
    ctx[2] !== void 0
  ) {
    fieldgroupselector_props.field_group_labels = /*field_group_labels*/
    ctx[2];
  }
  fieldgroupselector = new FieldGroupLabelsSelector_default({ props: fieldgroupselector_props });
  binding_callbacks.push(() => bind(fieldgroupselector, "field_group_labels", fieldgroupselector_field_group_labels_binding));
  let key_block = create_key_block5(ctx);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      create_component(rebuildgraphbutton.$$.fragment);
      t0 = space();
      create_component(edgesortidselector.$$.fragment);
      t1 = space();
      create_component(chevroncollapsebutton.$$.fragment);
      t2 = space();
      create_component(showattributesselectormenu.$$.fragment);
      t3 = space();
      create_component(fieldgroupselector.$$.fragment);
      t4 = space();
      key_block.c();
      attr(div0, "class", "nav-buttons-container");
      attr(div1, "class", "nav-header");
      attr(div2, "class", "markdown-rendered BC-matrix-view");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      mount_component(rebuildgraphbutton, div0, null);
      append(div0, t0);
      mount_component(edgesortidselector, div0, null);
      append(div0, t1);
      mount_component(chevroncollapsebutton, div0, null);
      append(div0, t2);
      mount_component(showattributesselectormenu, div0, null);
      append(div0, t3);
      mount_component(fieldgroupselector, div0, null);
      append(div2, t4);
      key_block.m(div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const rebuildgraphbutton_changes = {};
      if (dirty & /*plugin*/
      1)
        rebuildgraphbutton_changes.plugin = /*plugin*/
        ctx2[0];
      rebuildgraphbutton.$set(rebuildgraphbutton_changes);
      const edgesortidselector_changes = {};
      if (!updating_edge_sort_id && dirty & /*edge_sort_id*/
      2) {
        updating_edge_sort_id = true;
        edgesortidselector_changes.edge_sort_id = /*edge_sort_id*/
        ctx2[1];
        add_flush_callback(() => updating_edge_sort_id = false);
      }
      edgesortidselector.$set(edgesortidselector_changes);
      const chevroncollapsebutton_changes = {};
      if (!updating_collapse && dirty & /*collapse*/
      16) {
        updating_collapse = true;
        chevroncollapsebutton_changes.collapse = /*collapse*/
        ctx2[4];
        add_flush_callback(() => updating_collapse = false);
      }
      chevroncollapsebutton.$set(chevroncollapsebutton_changes);
      const showattributesselectormenu_changes = {};
      if (!updating_show_attributes && dirty & /*show_attributes*/
      8) {
        updating_show_attributes = true;
        showattributesselectormenu_changes.show_attributes = /*show_attributes*/
        ctx2[3];
        add_flush_callback(() => updating_show_attributes = false);
      }
      showattributesselectormenu.$set(showattributesselectormenu_changes);
      const fieldgroupselector_changes = {};
      if (dirty & /*plugin*/
      1)
        fieldgroupselector_changes.edge_field_groups = /*plugin*/
        ctx2[0].settings.edge_field_groups;
      if (!updating_field_group_labels && dirty & /*field_group_labels*/
      4) {
        updating_field_group_labels = true;
        fieldgroupselector_changes.field_group_labels = /*field_group_labels*/
        ctx2[2];
        add_flush_callback(() => updating_field_group_labels = false);
      }
      fieldgroupselector.$set(fieldgroupselector_changes);
      if (dirty & /*grouped_out_edges*/
      64 && safe_not_equal(previous_key, previous_key = /*grouped_out_edges*/
      ctx2[6])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block5(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div2, null);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(rebuildgraphbutton.$$.fragment, local);
      transition_in(edgesortidselector.$$.fragment, local);
      transition_in(chevroncollapsebutton.$$.fragment, local);
      transition_in(showattributesselectormenu.$$.fragment, local);
      transition_in(fieldgroupselector.$$.fragment, local);
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(rebuildgraphbutton.$$.fragment, local);
      transition_out(edgesortidselector.$$.fragment, local);
      transition_out(chevroncollapsebutton.$$.fragment, local);
      transition_out(showattributesselectormenu.$$.fragment, local);
      transition_out(fieldgroupselector.$$.fragment, local);
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(rebuildgraphbutton);
      destroy_component(edgesortidselector);
      destroy_component(chevroncollapsebutton);
      destroy_component(showattributesselectormenu);
      destroy_component(fieldgroupselector);
      key_block.d(detaching);
    }
  };
}
function instance47($$self, $$props, $$invalidate) {
  let edge_field_labels;
  let grouped_out_edges;
  let sort;
  let $active_file_store;
  component_subscribe($$self, active_file_store, ($$value) => $$invalidate(8, $active_file_store = $$value));
  let { plugin } = $$props;
  let { edge_sort_id, field_group_labels, show_attributes, collapse } = plugin.settings.views.side.matrix;
  function edgesortidselector_edge_sort_id_binding(value) {
    edge_sort_id = value;
    $$invalidate(1, edge_sort_id);
  }
  function chevroncollapsebutton_collapse_binding(value) {
    collapse = value;
    $$invalidate(4, collapse);
  }
  function showattributesselectormenu_show_attributes_binding(value) {
    show_attributes = value;
    $$invalidate(3, show_attributes);
  }
  function fieldgroupselector_field_group_labels_binding(value) {
    field_group_labels = value;
    $$invalidate(2, field_group_labels);
  }
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*plugin, field_group_labels*/
    5) {
      $:
        $$invalidate(7, edge_field_labels = resolve_field_group_labels(plugin.settings.edge_field_groups, field_group_labels));
    }
    if ($$self.$$.dirty & /*$active_file_store, plugin, edge_field_labels*/
    385) {
      $:
        $$invalidate(6, grouped_out_edges = $active_file_store && // Even tho we ensure the graph is built before the views are registered,
        // Existing views still try render before the graph is built.
        plugin.graph.hasNode($active_file_store.path) ? group_by(plugin.graph.get_out_edges($active_file_store.path).filter((e) => has_edge_attrs(e, { $or_fields: edge_field_labels })), (e) => e.attr.field) : null);
    }
    if ($$self.$$.dirty & /*edge_sort_id, plugin*/
    3) {
      $:
        $$invalidate(5, sort = get_edge_sorter(edge_sort_id, plugin.graph));
    }
  };
  return [
    plugin,
    edge_sort_id,
    field_group_labels,
    show_attributes,
    collapse,
    sort,
    grouped_out_edges,
    edge_field_labels,
    $active_file_store,
    edgesortidselector_edge_sort_id_binding,
    chevroncollapsebutton_collapse_binding,
    showattributesselectormenu_show_attributes_binding,
    fieldgroupselector_field_group_labels_binding
  ];
}
var Matrix = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance47, create_fragment47, safe_not_equal, { plugin: 0 });
  }
};
var Matrix_default = Matrix;

// src/views/matrix.ts
var MatrixView = class extends import_obsidian25.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.icon = "blinds";
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_IDS.matrix;
  }
  getDisplayText() {
    return "Matrix view";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    this.component = new Matrix_default({
      target: this.contentEl,
      props: { plugin: this.plugin }
    });
  }
  async onClose() {
    var _a;
    (_a = this.component) == null ? void 0 : _a.$destroy();
  }
};

// src/api/index.ts
var BCAPI = class {
  constructor(plugin) {
    this.refresh = () => this.plugin.refresh();
    /** @deprecated Use refresh */
    this.refreshIndex = this.refresh;
    /** @deprecated Filter edges of plugin.graph instead */
    this.getSubForFields = (fields, g = this.plugin.graph) => {
    };
    this.build_tree = Traverse.build_tree;
    this.breadth_first_traversal = Traverse.breadth_first;
    this.create_list_index = (start_node = ((_a) => (_a = get_store_value(active_file_store)) == null ? void 0 : _a.path)(), options) => {
      if (!start_node)
        throw new Error("No active file");
      return ListIndex.build(
        this.plugin.graph,
        start_node,
        Object.assign({ ...ListIndex.DEFAULT_OPTIONS }, options)
      );
    };
    // BREAKING
    /** @deprecated Use flatten_all_paths and flat_paths_to_index_list instead. Or, create_list_index */
    this.createIndex = () => {
    };
    this.get_neighbours = (source = ((_b) => (_b = get_store_value(active_file_store)) == null ? void 0 : _b.path)()) => source && this.plugin.graph.hasNode(source) ? this.plugin.graph.get_out_edges(source) : [];
    /** @deprecated Use get_neighbours instead */
    this.getMatrixNeighbours = this.get_neighbours;
    this.plugin = plugin;
  }
  get fields() {
    return this.plugin.settings.edge_fields;
  }
  get field_groups() {
    return this.plugin.settings.edge_field_groups;
  }
};

// src/codeblocks/MDRC.ts
var import_obsidian27 = require("obsidian");

// src/components/codeblocks/CodeblockErrors.svelte
function create_if_block14(ctx) {
  let p0;
  let t1;
  let p1;
  let t3;
  let div;
  let rendermarkdown;
  let t4;
  let hr;
  let t5;
  let p2;
  let t9;
  let p3;
  let t10;
  let code;
  let t11_value = (
    /*plugin*/
    ctx[0].manifest.version + ""
  );
  let t11;
  let current;
  rendermarkdown = new RenderMarkdown_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      markdown: (
        /*markdown*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      p0 = element("p");
      p0.textContent = "Breadcrumbs Codeblock Errors";
      t1 = space();
      p1 = element("p");
      p1.textContent = "The codeblock YAML has errors in the following keys/properties:";
      t3 = space();
      div = element("div");
      create_component(rendermarkdown.$$.fragment);
      t4 = space();
      hr = element("hr");
      t5 = space();
      p2 = element("p");
      p2.innerHTML = `See the <a target="_blank" class="external-link" href="https://publish.obsidian.md/breadcrumbs-docs/Views/Codeblocks">codeblock docs</a> for more info`;
      t9 = space();
      p3 = element("p");
      t10 = text("Version: ");
      code = element("code");
      t11 = text(t11_value);
      attr(p0, "class", "text-warning text-lg font-semibold");
      attr(div, "class", "BC-codeblock-errors");
    },
    m(target, anchor) {
      insert(target, p0, anchor);
      insert(target, t1, anchor);
      insert(target, p1, anchor);
      insert(target, t3, anchor);
      insert(target, div, anchor);
      mount_component(rendermarkdown, div, null);
      insert(target, t4, anchor);
      insert(target, hr, anchor);
      insert(target, t5, anchor);
      insert(target, p2, anchor);
      insert(target, t9, anchor);
      insert(target, p3, anchor);
      append(p3, t10);
      append(p3, code);
      append(code, t11);
      current = true;
    },
    p(ctx2, dirty) {
      const rendermarkdown_changes = {};
      if (dirty & /*plugin*/
      1)
        rendermarkdown_changes.plugin = /*plugin*/
        ctx2[0];
      rendermarkdown.$set(rendermarkdown_changes);
      if ((!current || dirty & /*plugin*/
      1) && t11_value !== (t11_value = /*plugin*/
      ctx2[0].manifest.version + ""))
        set_data(t11, t11_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(rendermarkdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rendermarkdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p0);
        detach(t1);
        detach(p1);
        detach(t3);
        detach(div);
        detach(t4);
        detach(hr);
        detach(t5);
        detach(p2);
        detach(t9);
        detach(p3);
      }
      destroy_component(rendermarkdown);
    }
  };
}
function create_fragment48(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*errors*/
    ctx[1].length && create_if_block14(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*errors*/
        ctx2[1].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*errors*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block14(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance48($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let { errors } = $$props;
  const markdown = errors.map((e) => `- **\`${e.path}\`**: ${e.message}`).join("\n");
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("errors" in $$props2)
      $$invalidate(1, errors = $$props2.errors);
  };
  return [plugin, errors, markdown];
}
var CodeblockErrors = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance48, create_fragment48, safe_not_equal, { plugin: 0, errors: 1 });
  }
};
var CodeblockErrors_default = CodeblockErrors;

// src/components/button/CopyToClipboardButton.svelte
function create_else_block8(ctx) {
  let clipboardicon;
  let current;
  clipboardicon = new clipboard_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      create_component(clipboardicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(clipboardicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(clipboardicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clipboardicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(clipboardicon, detaching);
    }
  };
}
function create_if_block15(ctx) {
  let checkicon;
  let current;
  checkicon = new check_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      create_component(checkicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(checkicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkicon, detaching);
    }
  };
}
function create_fragment49(ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let button_aria_label_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block15, create_else_block8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*copied*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(
        button,
        "class",
        /*cls*/
        ctx[0]
      );
      attr(button, "aria-label", button_aria_label_value = /*copied*/
      ctx[4] ? "Copied!" : (
        /*aria_label*/
        ctx[2]
      ));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(button, null);
      }
      if (!current || dirty & /*cls*/
      1) {
        attr(
          button,
          "class",
          /*cls*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*copied, aria_label*/
      20 && button_aria_label_value !== (button_aria_label_value = /*copied*/
      ctx2[4] ? "Copied!" : (
        /*aria_label*/
        ctx2[2]
      ))) {
        attr(button, "aria-label", button_aria_label_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function instance49($$self, $$props, $$invalidate) {
  let { cls = "" } = $$props;
  let { text: text2 } = $$props;
  let { aria_label = "Copy to Clipboard" } = $$props;
  let { options = {} } = $$props;
  let copied = false;
  const click_handler = () => {
    $$invalidate(4, copied = true);
    copy_to_clipboard(text2, options);
    setTimeout(() => $$invalidate(4, copied = false), 2500);
  };
  $$self.$$set = ($$props2) => {
    if ("cls" in $$props2)
      $$invalidate(0, cls = $$props2.cls);
    if ("text" in $$props2)
      $$invalidate(1, text2 = $$props2.text);
    if ("aria_label" in $$props2)
      $$invalidate(2, aria_label = $$props2.aria_label);
    if ("options" in $$props2)
      $$invalidate(3, options = $$props2.options);
  };
  return [cls, text2, aria_label, options, copied, click_handler];
}
var CopyToClipboardButton = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance49, create_fragment49, safe_not_equal, {
      cls: 0,
      text: 1,
      aria_label: 2,
      options: 3
    });
  }
};
var CopyToClipboardButton_default = CopyToClipboardButton;

// src/components/codeblocks/CodeblockMarkmap.svelte
function create_if_block_16(ctx) {
  let h3;
  let t_value = (
    /*options*/
    ctx[1].title + ""
  );
  let t;
  return {
    c() {
      h3 = element("h3");
      t = text(t_value);
      attr(h3, "class", "BC-codeblock-markmap-title");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*options*/
      2 && t_value !== (t_value = /*options*/
      ctx2[1].title + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
      }
    }
  };
}
function create_else_block9(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "No paths found.";
      attr(p, "class", "search-empty-state");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block16(ctx) {
  let div1;
  let div0;
  let copytoclipboardbutton;
  let t;
  let renderexternalcodeblock;
  let current;
  copytoclipboardbutton = new CopyToClipboardButton_default({
    props: {
      text: (
        /*code*/
        ctx[4]
      ),
      cls: "clickable-icon nav-action-button"
    }
  });
  renderexternalcodeblock = new RenderExternalCodeblock_default({
    props: {
      code: (
        /*code*/
        ctx[4]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      source_path: (
        /*source_path*/
        ctx[5]
      ),
      type: "markmap"
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(copytoclipboardbutton.$$.fragment);
      t = space();
      create_component(renderexternalcodeblock.$$.fragment);
      attr(div0, "class", "absolute left-2 top-2 flex");
      attr(div1, "class", "relative");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(copytoclipboardbutton, div0, null);
      append(div1, t);
      mount_component(renderexternalcodeblock, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const copytoclipboardbutton_changes = {};
      if (dirty & /*code*/
      16)
        copytoclipboardbutton_changes.text = /*code*/
        ctx2[4];
      copytoclipboardbutton.$set(copytoclipboardbutton_changes);
      const renderexternalcodeblock_changes = {};
      if (dirty & /*code*/
      16)
        renderexternalcodeblock_changes.code = /*code*/
        ctx2[4];
      if (dirty & /*plugin*/
      1)
        renderexternalcodeblock_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*source_path*/
      32)
        renderexternalcodeblock_changes.source_path = /*source_path*/
        ctx2[5];
      renderexternalcodeblock.$set(renderexternalcodeblock_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(copytoclipboardbutton.$$.fragment, local);
      transition_in(renderexternalcodeblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(copytoclipboardbutton.$$.fragment, local);
      transition_out(renderexternalcodeblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(copytoclipboardbutton);
      destroy_component(renderexternalcodeblock);
    }
  };
}
function create_fragment50(ctx) {
  let div;
  let codeblockerrors;
  let t0;
  let t1;
  let current_block_type_index;
  let if_block1;
  let current;
  codeblockerrors = new CodeblockErrors_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      errors: (
        /*errors*/
        ctx[2]
      )
    }
  });
  let if_block0 = (
    /*options*/
    ctx[1].title && create_if_block_16(ctx)
  );
  const if_block_creators = [create_if_block16, create_else_block9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tree*/
      ctx2[3].length
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      create_component(codeblockerrors.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if_block1.c();
      attr(div, "class", "BC-codeblock-markmap");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(codeblockerrors, div, null);
      append(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t1);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const codeblockerrors_changes = {};
      if (dirty & /*plugin*/
      1)
        codeblockerrors_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*errors*/
      4)
        codeblockerrors_changes.errors = /*errors*/
        ctx2[2];
      codeblockerrors.$set(codeblockerrors_changes);
      if (
        /*options*/
        ctx2[1].title
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_16(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(codeblockerrors.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(codeblockerrors.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(codeblockerrors);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance50($$self, $$props, $$invalidate) {
  let source_path;
  let code;
  let $active_file_store;
  component_subscribe($$self, active_file_store, ($$value) => $$invalidate(9, $active_file_store = $$value));
  var _a, _b;
  let { plugin } = $$props;
  let { options } = $$props;
  let { errors } = $$props;
  let { file_path } = $$props;
  const sort = get_edge_sorter(
    // @ts-expect-error: ts(2345)
    options.sort,
    plugin.graph
  );
  const { show_node_options } = plugin.settings.views.codeblocks;
  let tree = [];
  const update2 = () => {
    $$invalidate(3, tree = Traverse.sort_edge_tree(get_tree(), sort));
  };
  const base_traversal = (attr2) => Traverse.build_tree(plugin.graph, source_path, { max_depth: options.depth[1] }, (e) => has_edge_attrs(e, Object.assign(Object.assign({}, attr2), {
    $or_target_ids: options["dataview-from-paths"]
  })));
  const edge_field_labels = (_a = options.fields) !== null && _a !== void 0 ? _a : plugin.settings.edge_fields.map((f) => f.label);
  const get_tree = () => {
    if (source_path && plugin.graph.hasNode(source_path)) {
      const traversal = options["merge-fields"] ? base_traversal({ $or_fields: options.fields }) : edge_field_labels.flatMap((field) => base_traversal({ field }));
      return options.flat ? Traverse.flatten_tree(traversal).map((item) => ({ depth: 0, children: [], edge: item.edge })) : traversal;
    } else {
      return [];
    }
  };
  onMount(update2);
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("errors" in $$props2)
      $$invalidate(2, errors = $$props2.errors);
    if ("file_path" in $$props2)
      $$invalidate(6, file_path = $$props2.file_path);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*file_path, $active_file_store*/
    576) {
      $:
        $$invalidate(5, source_path = file_path ? file_path : $active_file_store ? $active_file_store.path : "");
    }
    if ($$self.$$.dirty & /*tree, plugin, options, _b*/
    267) {
      $:
        $$invalidate(4, code = ListIndex.edge_tree_to_list_index(tree, Object.assign(Object.assign({}, plugin.settings.commands.list_index.default_options), {
          show_node_options,
          show_attributes: $$invalidate(8, _b = options["show-attributes"]) !== null && _b !== void 0 ? _b : []
        })));
    }
  };
  return [
    plugin,
    options,
    errors,
    tree,
    code,
    source_path,
    file_path,
    update2,
    _b,
    $active_file_store
  ];
}
var CodeblockMarkmap = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance50, create_fragment50, safe_not_equal, {
      plugin: 0,
      options: 1,
      errors: 2,
      file_path: 6,
      update: 7
    });
  }
  get update() {
    return this.$$.ctx[7];
  }
};
var CodeblockMarkmap_default = CodeblockMarkmap;

// src/graph/distance.ts
var from_traversal_items = (items) => {
  const distances = /* @__PURE__ */ new Map();
  items.forEach((item) => {
    var _a;
    distances.set(
      item.edge.target_id,
      Math.min(
        (_a = distances.get(item.edge.target_id)) != null ? _a : Infinity,
        item.depth + 1
      )
    );
  });
  return distances;
};
var Distance = {
  from_traversal_items
};

// src/utils/numbers.ts
var is_between = (value, min, max) => value >= min && value <= max;

// src/components/codeblocks/CodeblockMermaid.svelte
function create_if_block_17(ctx) {
  let h3;
  let t_value = (
    /*options*/
    ctx[1].title + ""
  );
  let t;
  return {
    c() {
      h3 = element("h3");
      t = text(t_value);
      attr(h3, "class", "BC-codeblock-mermaid-title");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*options*/
      2 && t_value !== (t_value = /*options*/
      ctx2[1].title + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
      }
    }
  };
}
function create_else_block10(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "No paths found.";
      attr(p, "class", "search-empty-state");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block17(ctx) {
  let div1;
  let div0;
  let copytoclipboardbutton;
  let t0;
  let button0;
  let imageicon;
  let t1;
  let button1;
  let pencilicon;
  let t2;
  let renderexternalcodeblock;
  let current;
  let mounted;
  let dispose;
  copytoclipboardbutton = new CopyToClipboardButton_default({
    props: {
      text: (
        /*code*/
        ctx[4]
      ),
      cls: "clickable-icon nav-action-button"
    }
  });
  imageicon = new image_default({ props: { size: ICON_SIZE } });
  pencilicon = new pencil_default({ props: { size: ICON_SIZE } });
  renderexternalcodeblock = new RenderExternalCodeblock_default({
    props: {
      code: (
        /*code*/
        ctx[4]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      source_path: (
        /*source_path*/
        ctx[5]
      ),
      type: "mermaid"
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(copytoclipboardbutton.$$.fragment);
      t0 = space();
      button0 = element("button");
      create_component(imageicon.$$.fragment);
      t1 = space();
      button1 = element("button");
      create_component(pencilicon.$$.fragment);
      t2 = space();
      create_component(renderexternalcodeblock.$$.fragment);
      attr(button0, "role", "link");
      attr(button0, "aria-label", "View Image on mermaid.ink");
      attr(button0, "class", "clickable-icon nav-action-button");
      attr(button1, "role", "link");
      attr(button1, "aria-label", "Live Edit on mermaid.live");
      attr(button1, "class", "clickable-icon nav-action-button");
      attr(div0, "class", "absolute left-2 top-2 flex");
      attr(div1, "class", "relative");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(copytoclipboardbutton, div0, null);
      append(div0, t0);
      append(div0, button0);
      mount_component(imageicon, button0, null);
      append(div0, t1);
      append(div0, button1);
      mount_component(pencilicon, button1, null);
      append(div1, t2);
      mount_component(renderexternalcodeblock, div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[12]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const copytoclipboardbutton_changes = {};
      if (dirty & /*code*/
      16)
        copytoclipboardbutton_changes.text = /*code*/
        ctx2[4];
      copytoclipboardbutton.$set(copytoclipboardbutton_changes);
      const renderexternalcodeblock_changes = {};
      if (dirty & /*code*/
      16)
        renderexternalcodeblock_changes.code = /*code*/
        ctx2[4];
      if (dirty & /*plugin*/
      1)
        renderexternalcodeblock_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*source_path*/
      32)
        renderexternalcodeblock_changes.source_path = /*source_path*/
        ctx2[5];
      renderexternalcodeblock.$set(renderexternalcodeblock_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(copytoclipboardbutton.$$.fragment, local);
      transition_in(imageicon.$$.fragment, local);
      transition_in(pencilicon.$$.fragment, local);
      transition_in(renderexternalcodeblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(copytoclipboardbutton.$$.fragment, local);
      transition_out(imageicon.$$.fragment, local);
      transition_out(pencilicon.$$.fragment, local);
      transition_out(renderexternalcodeblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(copytoclipboardbutton);
      destroy_component(imageicon);
      destroy_component(pencilicon);
      destroy_component(renderexternalcodeblock);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment51(ctx) {
  let div;
  let codeblockerrors;
  let t0;
  let t1;
  let current_block_type_index;
  let if_block1;
  let current;
  codeblockerrors = new CodeblockErrors_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      errors: (
        /*errors*/
        ctx[2]
      )
    }
  });
  let if_block0 = (
    /*options*/
    ctx[1].title && create_if_block_17(ctx)
  );
  const if_block_creators = [create_if_block17, create_else_block10];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*traversal_items*/
      ctx2[3].length
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      create_component(codeblockerrors.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if_block1.c();
      attr(div, "class", "BC-codeblock-mermaid");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(codeblockerrors, div, null);
      append(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t1);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const codeblockerrors_changes = {};
      if (dirty & /*plugin*/
      1)
        codeblockerrors_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*errors*/
      4)
        codeblockerrors_changes.errors = /*errors*/
        ctx2[2];
      codeblockerrors.$set(codeblockerrors_changes);
      if (
        /*options*/
        ctx2[1].title
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_17(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(codeblockerrors.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(codeblockerrors.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(codeblockerrors);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance51($$self, $$props, $$invalidate) {
  let source_path;
  let edges;
  let code;
  let $active_file_store;
  component_subscribe($$self, active_file_store, ($$value) => $$invalidate(11, $active_file_store = $$value));
  var _a;
  let { plugin } = $$props;
  let { options } = $$props;
  let { errors } = $$props;
  let { file_path } = $$props;
  const sort = get_edge_sorter(
    // @ts-expect-error: ts(2345)
    options.sort,
    plugin.graph
  );
  let traversal_items = [];
  let distances = /* @__PURE__ */ new Map();
  const update2 = () => {
    $$invalidate(3, traversal_items = get_traversal_items());
    $$invalidate(9, distances = Distance.from_traversal_items(traversal_items));
  };
  const base_traversal = (attr2) => Traverse.gather_items(plugin.graph, source_path, (item) => has_edge_attrs(item.edge, Object.assign(Object.assign({}, attr2), {
    $or_target_ids: options["dataview-from-paths"]
  })));
  const edge_field_labels = (_a = options.fields) !== null && _a !== void 0 ? _a : plugin.settings.edge_fields.map((f) => f.label);
  const get_traversal_items = () => {
    if (source_path && plugin.graph.hasNode(source_path)) {
      return options["merge-fields"] ? base_traversal({ $or_fields: options.fields }) : edge_field_labels.flatMap((field) => base_traversal({ field }));
    } else {
      return [];
    }
  };
  onMount(update2);
  const click_handler = () => {
    window.open(Mermaid.to_image_link(code), "_blank");
  };
  const click_handler_1 = () => {
    window.open(Mermaid.to_live_edit_link(code), "_blank");
  };
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("errors" in $$props2)
      $$invalidate(2, errors = $$props2.errors);
    if ("file_path" in $$props2)
      $$invalidate(6, file_path = $$props2.file_path);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*file_path, $active_file_store*/
    2112) {
      $:
        $$invalidate(5, source_path = file_path ? file_path : $active_file_store ? $active_file_store.path : "");
    }
    if ($$self.$$.dirty & /*traversal_items, distances, options*/
    522) {
      $:
        $$invalidate(10, edges = traversal_items.filter((item) => {
          var _a2;
          return is_between(
            (_a2 = distances.get(item.edge.target_id)) !== null && _a2 !== void 0 ? _a2 : 0,
            options.depth[0] + 1,
            options.depth[1]
          );
        }).map((item) => item.edge).sort(sort));
    }
    if ($$self.$$.dirty & /*edges, source_path, options, plugin*/
    1059) {
      $:
        $$invalidate(4, code = Mermaid.from_edges(edges, {
          kind: "graph",
          click: { method: "class" },
          active_node_id: source_path,
          renderer: options["mermaid-renderer"],
          curve_style: options["mermaid-curve"],
          direction: options["mermaid-direction"],
          show_attributes: options["show-attributes"],
          get_node_label: (node_id, _attr) => {
            const file = plugin.app.vault.getFileByPath(node_id);
            return file ? plugin.app.fileManager.generateMarkdownLink(file, source_path).slice(2, -2) : Paths.drop_ext(Links.resolve_to_absolute_path(plugin.app, node_id, source_path));
          }
        }));
    }
    if ($$self.$$.dirty & /*code*/
    16) {
      $:
        log.debug(code);
    }
  };
  return [
    plugin,
    options,
    errors,
    traversal_items,
    code,
    source_path,
    file_path,
    update2,
    _a,
    distances,
    edges,
    $active_file_store,
    click_handler,
    click_handler_1
  ];
}
var CodeblockMermaid = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance51, create_fragment51, safe_not_equal, {
      plugin: 0,
      options: 1,
      errors: 2,
      file_path: 6,
      update: 7
    });
  }
  get update() {
    return this.$$.ctx[7];
  }
};
var CodeblockMermaid_default = CodeblockMermaid;

// src/components/NestedEdgeList.svelte
function get_each_context11(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  child_ctx[10] = list;
  child_ctx[11] = i;
  return child_ctx;
}
function create_if_block_25(ctx) {
  let div;
  let chevronopener;
  let current;
  chevronopener = new ChevronOpener_default({
    props: { open: (
      /*opens*/
      ctx[5][
        /*i*/
        ctx[11]
      ]
    ) }
  });
  return {
    c() {
      div = element("div");
      create_component(chevronopener.$$.fragment);
      attr(div, "class", "tree-item-icon collapse-icon mod-collapsible");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(chevronopener, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const chevronopener_changes = {};
      if (dirty & /*opens*/
      32)
        chevronopener_changes.open = /*opens*/
        ctx2[5][
          /*i*/
          ctx2[11]
        ];
      chevronopener.$set(chevronopener_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(chevronopener.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chevronopener.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(chevronopener);
    }
  };
}
function create_if_block_18(ctx) {
  let treeitemflair;
  let current;
  treeitemflair = new TreeItemFlair_default({
    props: {
      label: url_search_params(untyped_pick(
        /*item*/
        ctx[9].edge.attr,
        /*show_attributes*/
        ctx[3]
      ), { trim_lone_param: true })
    }
  });
  return {
    c() {
      create_component(treeitemflair.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treeitemflair, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemflair_changes = {};
      if (dirty & /*tree, sort, show_attributes*/
      26)
        treeitemflair_changes.label = url_search_params(untyped_pick(
          /*item*/
          ctx2[9].edge.attr,
          /*show_attributes*/
          ctx2[3]
        ), { trim_lone_param: true });
      treeitemflair.$set(treeitemflair_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemflair.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemflair.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemflair, detaching);
    }
  };
}
function create_if_block18(ctx) {
  let div;
  let nestededgelist;
  let current;
  nestededgelist = new NestedEdgeList({
    props: {
      sort: (
        /*sort*/
        ctx[4]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      show_attributes: (
        /*show_attributes*/
        ctx[3]
      ),
      show_node_options: (
        /*show_node_options*/
        ctx[2]
      ),
      tree: (
        /*item*/
        ctx[9].children
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(nestededgelist.$$.fragment);
      attr(div, "class", "tree-item-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(nestededgelist, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const nestededgelist_changes = {};
      if (dirty & /*sort*/
      16)
        nestededgelist_changes.sort = /*sort*/
        ctx2[4];
      if (dirty & /*plugin*/
      1)
        nestededgelist_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*show_attributes*/
      8)
        nestededgelist_changes.show_attributes = /*show_attributes*/
        ctx2[3];
      if (dirty & /*show_node_options*/
      4)
        nestededgelist_changes.show_node_options = /*show_node_options*/
        ctx2[2];
      if (dirty & /*tree, sort*/
      18)
        nestededgelist_changes.tree = /*item*/
        ctx2[9].children;
      nestededgelist.$set(nestededgelist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nestededgelist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nestededgelist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(nestededgelist);
    }
  };
}
function create_each_block11(ctx) {
  var _a;
  let details;
  let summary;
  let t0;
  let div;
  let edgelink;
  let t1;
  let t2;
  let t3;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*item*/
    ctx[9].children.length && create_if_block_25(ctx)
  );
  edgelink = new EdgeLink_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      edge: (
        /*item*/
        ctx[9].edge
      ),
      show_node_options: (
        /*show_node_options*/
        ctx[2]
      ),
      cls: "tree-item-inner-text"
    }
  });
  let if_block1 = (
    /*show_attributes*/
    ((_a = ctx[3]) == null ? void 0 : _a.length) && create_if_block_18(ctx)
  );
  let if_block2 = (
    /*item*/
    ctx[9].children.length && create_if_block18(ctx)
  );
  function details_toggle_handler() {
    ctx[8].call(
      details,
      /*i*/
      ctx[11]
    );
  }
  return {
    c() {
      details = element("details");
      summary = element("summary");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      create_component(edgelink.$$.fragment);
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      attr(div, "class", "tree-item-inner");
      attr(summary, "class", "tree-item-self is-clickable flex items-center");
      attr(details, "class", "tree-item");
    },
    m(target, anchor) {
      insert(target, details, anchor);
      append(details, summary);
      if (if_block0)
        if_block0.m(summary, null);
      append(summary, t0);
      append(summary, div);
      mount_component(edgelink, div, null);
      append(summary, t1);
      if (if_block1)
        if_block1.m(summary, null);
      append(details, t2);
      if (if_block2)
        if_block2.m(details, null);
      append(details, t3);
      details.open = /*opens*/
      ctx[5][
        /*i*/
        ctx[11]
      ];
      current = true;
      if (!mounted) {
        dispose = listen(details, "toggle", details_toggle_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      if (
        /*item*/
        ctx[9].children.length
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & /*tree, sort*/
          18) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_25(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(summary, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const edgelink_changes = {};
      if (dirty & /*plugin*/
      1)
        edgelink_changes.plugin = /*plugin*/
        ctx[0];
      if (dirty & /*tree, sort*/
      18)
        edgelink_changes.edge = /*item*/
        ctx[9].edge;
      if (dirty & /*show_node_options*/
      4)
        edgelink_changes.show_node_options = /*show_node_options*/
        ctx[2];
      edgelink.$set(edgelink_changes);
      if (
        /*show_attributes*/
        (_a2 = ctx[3]) == null ? void 0 : _a2.length
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty & /*show_attributes*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_18(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(summary, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*item*/
        ctx[9].children.length
      ) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
          if (dirty & /*tree, sort*/
          18) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block18(ctx);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(details, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (dirty & /*opens*/
      32) {
        details.open = /*opens*/
        ctx[5][
          /*i*/
          ctx[11]
        ];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(edgelink.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(edgelink.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(details);
      }
      if (if_block0)
        if_block0.d();
      destroy_component(edgelink);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment52(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*tree*/
    ctx[1].sort(
      /*func*/
      ctx[7]
    )
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block11(get_each_context11(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*opens, sort, plugin, show_attributes, show_node_options, tree*/
      63) {
        each_value = ensure_array_like(
          /*tree*/
          ctx2[1].sort(
            /*func*/
            ctx2[7]
          )
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context11(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block11(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance52($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let { tree } = $$props;
  let { open_signal } = $$props;
  let { show_node_options } = $$props;
  let { show_attributes } = $$props;
  let { sort } = $$props;
  let opens = tree.map(() => true);
  const func = (a, b) => sort(a.edge, b.edge);
  function details_toggle_handler(i) {
    opens[i] = this.open;
    $$invalidate(5, opens), $$invalidate(6, open_signal);
  }
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("tree" in $$props2)
      $$invalidate(1, tree = $$props2.tree);
    if ("open_signal" in $$props2)
      $$invalidate(6, open_signal = $$props2.open_signal);
    if ("show_node_options" in $$props2)
      $$invalidate(2, show_node_options = $$props2.show_node_options);
    if ("show_attributes" in $$props2)
      $$invalidate(3, show_attributes = $$props2.show_attributes);
    if ("sort" in $$props2)
      $$invalidate(4, sort = $$props2.sort);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open_signal, opens*/
    96) {
      $:
        if (open_signal === true) {
          $$invalidate(5, opens = opens.map(() => true));
          $$invalidate(6, open_signal = null);
        } else if (open_signal === false) {
          $$invalidate(5, opens = opens.map(() => false));
          $$invalidate(6, open_signal = null);
        }
    }
  };
  return [
    plugin,
    tree,
    show_node_options,
    show_attributes,
    sort,
    opens,
    open_signal,
    func,
    details_toggle_handler
  ];
}
var NestedEdgeList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance52, create_fragment52, safe_not_equal, {
      plugin: 0,
      tree: 1,
      open_signal: 6,
      show_node_options: 2,
      show_attributes: 3,
      sort: 4
    });
  }
};
var NestedEdgeList_default = NestedEdgeList;

// src/components/codeblocks/CodeblockTree.svelte
function create_if_block_19(ctx) {
  let h3;
  let t_value = (
    /*options*/
    ctx[1].title + ""
  );
  let t;
  return {
    c() {
      h3 = element("h3");
      t = text(t_value);
      attr(h3, "class", "BC-codeblock-tree-title");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*options*/
      2 && t_value !== (t_value = /*options*/
      ctx2[1].title + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
      }
    }
  };
}
function create_else_block11(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "No paths found";
      attr(p, "class", "search-empty-state");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block19(ctx) {
  var _a;
  let div2;
  let div0;
  let copytoclipboardbutton;
  let t;
  let div1;
  let nestededgelist;
  let current;
  copytoclipboardbutton = new CopyToClipboardButton_default({
    props: {
      cls: "clickable-icon nav-action-button",
      text: ListIndex.edge_tree_to_list_index(
        /*tree*/
        ctx[3],
        {
          .../*plugin*/
          ctx[0].settings.commands.list_index.default_options,
          show_attributes: (
            /*options*/
            (_a = ctx[1]["show-attributes"]) != null ? _a : []
          )
        }
      )
    }
  });
  nestededgelist = new NestedEdgeList_default({
    props: {
      sort: (
        /*sort*/
        ctx[4]
      ),
      tree: (
        /*tree*/
        ctx[3]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      show_node_options: (
        /*show_node_options*/
        ctx[5]
      ),
      open_signal: !/*options*/
      ctx[1].collapse,
      show_attributes: (
        /*options*/
        ctx[1]["show-attributes"]
      )
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(copytoclipboardbutton.$$.fragment);
      t = space();
      div1 = element("div");
      create_component(nestededgelist.$$.fragment);
      attr(div0, "class", "absolute bottom-2 right-2 flex");
      attr(div1, "class", "pr-10");
      attr(div2, "class", "BC-codeblock-tree-items relative");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(copytoclipboardbutton, div0, null);
      append(div2, t);
      append(div2, div1);
      mount_component(nestededgelist, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const copytoclipboardbutton_changes = {};
      if (dirty & /*tree, plugin, options*/
      11)
        copytoclipboardbutton_changes.text = ListIndex.edge_tree_to_list_index(
          /*tree*/
          ctx2[3],
          {
            .../*plugin*/
            ctx2[0].settings.commands.list_index.default_options,
            show_attributes: (
              /*options*/
              (_a2 = ctx2[1]["show-attributes"]) != null ? _a2 : []
            )
          }
        );
      copytoclipboardbutton.$set(copytoclipboardbutton_changes);
      const nestededgelist_changes = {};
      if (dirty & /*tree*/
      8)
        nestededgelist_changes.tree = /*tree*/
        ctx2[3];
      if (dirty & /*plugin*/
      1)
        nestededgelist_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*options*/
      2)
        nestededgelist_changes.open_signal = !/*options*/
        ctx2[1].collapse;
      if (dirty & /*options*/
      2)
        nestededgelist_changes.show_attributes = /*options*/
        ctx2[1]["show-attributes"];
      nestededgelist.$set(nestededgelist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(copytoclipboardbutton.$$.fragment, local);
      transition_in(nestededgelist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(copytoclipboardbutton.$$.fragment, local);
      transition_out(nestededgelist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(copytoclipboardbutton);
      destroy_component(nestededgelist);
    }
  };
}
function create_fragment53(ctx) {
  let div;
  let codeblockerrors;
  let t0;
  let t1;
  let current_block_type_index;
  let if_block1;
  let current;
  codeblockerrors = new CodeblockErrors_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      errors: (
        /*errors*/
        ctx[2]
      )
    }
  });
  let if_block0 = (
    /*options*/
    ctx[1].title && create_if_block_19(ctx)
  );
  const if_block_creators = [create_if_block19, create_else_block11];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tree*/
      ctx2[3].length
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      create_component(codeblockerrors.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if_block1.c();
      attr(div, "class", "BC-codeblock-tree");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(codeblockerrors, div, null);
      append(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t1);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const codeblockerrors_changes = {};
      if (dirty & /*plugin*/
      1)
        codeblockerrors_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*errors*/
      4)
        codeblockerrors_changes.errors = /*errors*/
        ctx2[2];
      codeblockerrors.$set(codeblockerrors_changes);
      if (
        /*options*/
        ctx2[1].title
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_19(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(codeblockerrors.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(codeblockerrors.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(codeblockerrors);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance53($$self, $$props, $$invalidate) {
  let source_path;
  let $active_file_store;
  component_subscribe($$self, active_file_store, ($$value) => $$invalidate(8, $active_file_store = $$value));
  var _a;
  let { plugin } = $$props;
  let { options } = $$props;
  let { errors } = $$props;
  let { file_path } = $$props;
  const sort = get_edge_sorter(
    // @ts-expect-error: ts(2345)
    options.sort,
    plugin.graph
  );
  const { show_node_options } = plugin.settings.views.codeblocks;
  let tree = [];
  const update2 = () => {
    $$invalidate(3, tree = get_tree());
  };
  const base_traversal = (attr2) => Traverse.build_tree(plugin.graph, source_path, { max_depth: options.depth[1] }, (e) => has_edge_attrs(e, Object.assign(Object.assign({}, attr2), {
    $or_target_ids: options["dataview-from-paths"]
  })));
  const edge_field_labels = (_a = options.fields) !== null && _a !== void 0 ? _a : plugin.settings.edge_fields.map((f) => f.label);
  const get_tree = () => {
    if (source_path && plugin.graph.hasNode(source_path)) {
      const traversal = options["merge-fields"] ? base_traversal({ $or_fields: options.fields }) : edge_field_labels.flatMap((field) => base_traversal({ field }));
      return options.flat ? Traverse.flatten_tree(traversal).map((item) => ({ depth: 0, children: [], edge: item.edge })) : traversal;
    } else {
      return [];
    }
  };
  onMount(update2);
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("errors" in $$props2)
      $$invalidate(2, errors = $$props2.errors);
    if ("file_path" in $$props2)
      $$invalidate(6, file_path = $$props2.file_path);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*file_path, $active_file_store*/
    320) {
      $:
        source_path = file_path ? file_path : $active_file_store ? $active_file_store.path : "";
    }
  };
  return [
    plugin,
    options,
    errors,
    tree,
    sort,
    show_node_options,
    file_path,
    update2,
    $active_file_store
  ];
}
var CodeblockTree = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance53, create_fragment53, safe_not_equal, {
      plugin: 0,
      options: 1,
      errors: 2,
      file_path: 6,
      update: 7
    });
  }
  get update() {
    return this.$$.ctx[7];
  }
};
var CodeblockTree_default = CodeblockTree;

// src/codeblocks/MDRC.ts
var CodeblockMDRC = class extends import_obsidian27.MarkdownRenderChild {
  constructor(plugin, containerEl, source, file_path) {
    super(containerEl);
    this.plugin = plugin;
    this.source = source;
    this.file_path = file_path;
    this.id = window.crypto.randomUUID();
  }
  async update() {
    log.debug("CodeblockMDRC.update");
    if (this.component) {
      try {
        this.component.update();
      } catch (e) {
        log.error("CodeblockMDRC.update error >", e);
      }
    }
  }
  async onload() {
    const timer_outer = new Timer();
    log.debug("CodeblockMDRC.load");
    Codeblocks.register(this);
    this.containerEl.empty();
    const timer_inner = new Timer();
    const { parsed, errors } = Codeblocks.parse_source(this.source, {
      edge_fields: this.plugin.settings.edge_fields,
      field_groups: this.plugin.settings.edge_field_groups
    });
    log.debug(timer_inner.elapsedMessage("Codeblocks.parse_source", true));
    if (!parsed) {
      log.warn("fatal codeblock errors", errors);
      new CodeblockErrors_default({
        target: this.containerEl,
        props: { errors, plugin: this.plugin }
      });
      return;
    }
    const { options, file_path } = Codeblocks.postprocess_options(
      this.file_path,
      parsed,
      errors,
      this.plugin
    );
    log.debug("resolved codeblock options", options);
    log.debug(
      timer_inner.elapsedMessage("Codeblocks.postprocess_options", true)
    );
    if (errors.length)
      log.warn("non-fatal codeblock errors", errors);
    if (options.type === "tree") {
      this.component = new CodeblockTree_default({
        target: this.containerEl,
        props: {
          errors,
          options,
          file_path,
          plugin: this.plugin
        }
      });
    } else if (options.type === "mermaid") {
      this.component = new CodeblockMermaid_default({
        target: this.containerEl,
        props: {
          errors,
          options,
          file_path,
          plugin: this.plugin
        }
      });
    } else if (options.type === "markmap") {
      this.component = new CodeblockMarkmap_default({
        target: this.containerEl,
        props: {
          errors,
          options,
          file_path,
          plugin: this.plugin
        }
      });
    } else {
      log.error("CodeblockMDRC unknown type", options.type);
    }
    log.debug(timer_inner.elapsedMessage("component creation", true));
    log.debug(timer_outer.elapsedMessage("CodeblockMDRC.onload"));
  }
  onunload() {
    var _a;
    log.debug("CodeblockMDRC.unload");
    Codeblocks.unregister(this);
    (_a = this.component) == null ? void 0 : _a.$destroy();
  }
};

// src/commands/init.ts
var import_obsidian34 = require("obsidian");

// src/components/input/SimpleInput.svelte
function create_if_block20(ctx) {
  let label_1;
  let t;
  return {
    c() {
      label_1 = element("label");
      t = text(
        /*label*/
        ctx[0]
      );
      attr(label_1, "for", "input");
    },
    m(target, anchor) {
      insert(target, label_1, anchor);
      append(label_1, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*label*/
      1)
        set_data(
          t,
          /*label*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(label_1);
      }
    }
  };
}
function create_fragment54(ctx) {
  let div;
  let t0;
  let input;
  let t1;
  let button;
  let t2;
  let button_disabled_value;
  let mounted;
  let dispose;
  let if_block = (
    /*label*/
    ctx[0] && create_if_block20(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      input = element("input");
      t1 = space();
      button = element("button");
      t2 = text("Submit");
      attr(input, "name", "input");
      attr(input, "type", "text");
      button.disabled = button_disabled_value = /*disabled_cb*/
      ctx[1](
        /*value*/
        ctx[2]
      );
      attr(div, "class", "flex flex-col gap-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t0);
      append(div, input);
      set_input_value(
        input,
        /*value*/
        ctx[2]
      );
      append(div, t1);
      append(div, button);
      append(button, t2);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[4]
          ),
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*label*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block20(ctx2);
          if_block.c();
          if_block.m(div, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*value*/
      4 && input.value !== /*value*/
      ctx2[2]) {
        set_input_value(
          input,
          /*value*/
          ctx2[2]
        );
      }
      if (dirty & /*disabled_cb, value*/
      6 && button_disabled_value !== (button_disabled_value = /*disabled_cb*/
      ctx2[1](
        /*value*/
        ctx2[2]
      ))) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance54($$self, $$props, $$invalidate) {
  let { label = "" } = $$props;
  let { disabled_cb = (_value) => false } = $$props;
  let value = "";
  const dispatch = createEventDispatcher();
  function input_input_handler() {
    value = this.value;
    $$invalidate(2, value);
  }
  const click_handler = () => dispatch("submit", value);
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(0, label = $$props2.label);
    if ("disabled_cb" in $$props2)
      $$invalidate(1, disabled_cb = $$props2.disabled_cb);
  };
  return [label, disabled_cb, value, dispatch, input_input_handler, click_handler];
}
var SimpleInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance54, create_fragment54, safe_not_equal, { label: 0, disabled_cb: 1 });
  }
};
var SimpleInput_default = SimpleInput;

// src/modals/CreateListIndexModal.ts
var import_obsidian28 = require("obsidian");
var CreateListIndexModal = class extends import_obsidian28.Modal {
  constructor(app, plugin) {
    super(app);
    this.active_file = get_store_value(active_file_store);
    this.plugin = plugin;
    this.options = plugin.settings.commands.list_index.default_options;
  }
  onOpen() {
    if (!this.active_file) {
      new import_obsidian28.Notice("No active file");
      return this.close();
    }
    const { contentEl, plugin } = this;
    contentEl.createEl("h2", {
      text: "Create List Index"
    });
    new FieldGroupLabelsSettingItem_default({
      target: contentEl,
      props: {
        field_group_labels: this.options.field_group_labels,
        edge_field_groups: plugin.settings.edge_field_groups
      }
    }).$on("select", (e) => {
      this.options.field_group_labels = e.detail;
      this.options.fields = resolve_field_group_labels(
        plugin.settings.edge_field_groups,
        this.options.field_group_labels
      );
    });
    new_setting(contentEl, {
      name: "Link Kind",
      desc: "Format to use for links",
      select: {
        options: LINK_KINDS,
        value: this.options.link_kind,
        cb: (value) => this.options.link_kind = value
      }
    });
    new_setting(contentEl, {
      name: "Indent",
      desc: "Indentation to use for each level",
      input: {
        value: this.options.indent,
        cb: (value) => this.options.indent = value
      }
    });
    new EdgeSortIdSettingItem_default({
      target: contentEl,
      props: { edge_sort_id: this.options.edge_sort_id }
    }).$on("select", (e) => {
      this.options.edge_sort_id = e.detail;
    });
    new ShowAttributesSettingItem_default({
      target: contentEl,
      props: { show_attributes: this.options.show_attributes }
    }).$on("select", (e) => {
      this.options.show_attributes = e.detail;
    });
    _add_settings_show_node_options(
      plugin,
      contentEl,
      {
        get: () => this.options.show_node_options,
        set: (value) => this.options.show_node_options = value
      },
      { save_and_refresh: false }
    );
    new import_obsidian28.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Build & Copy to Clipboard").setCta().onClick(async () => {
        log.debug("build_list_index options", this.options);
        const list_index = ListIndex.build(
          plugin.graph,
          this.active_file.path,
          this.options
        );
        if (list_index) {
          await navigator.clipboard.writeText(list_index);
          new import_obsidian28.Notice("List index copied to clipboard");
        } else {
          new import_obsidian28.Notice("No list items to copy");
        }
        this.close();
      })
    );
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/modals/GenericModal.ts
var import_obsidian29 = require("obsidian");
var GenericModal = class extends import_obsidian29.Modal {
  constructor(app, cb) {
    super(app);
    this.cb = cb;
  }
  onOpen() {
    this.cb(this);
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/commands/freeze_edges/index.ts
var import_obsidian31 = require("obsidian");

// src/utils/drop_crumb.ts
var import_obsidian30 = require("obsidian");
var linkify_edge = (plugin, source_id, target_id, target_aliases) => {
  const target_file = plugin.app.vault.getFileByPath(target_id);
  if (!target_file) {
    return `[[${Paths.drop_ext(target_id)}]]`;
  } else {
    return plugin.app.fileManager.generateMarkdownLink(
      target_file,
      source_id,
      void 0,
      target_aliases == null ? void 0 : target_aliases.at(0)
    );
  }
};
var drop_crumbs = async (plugin, destination_file, crumbs, options) => {
  var _a, _b;
  if (!crumbs.length)
    return;
  const links_by_field = group_projection(
    group_by(crumbs, (e) => e.attr.field),
    (edges) => edges.map(
      (e) => linkify_edge(
        plugin,
        e.source_id,
        e.target_id,
        e.target_attr.aliases
      )
    )
  );
  switch (options.destination) {
    case "frontmatter": {
      let mutated = false;
      const frontmatter = (_b = (_a = plugin.app.metadataCache.getFileCache(destination_file)) == null ? void 0 : _a.frontmatter) != null ? _b : {};
      Object.entries(links_by_field).forEach(([field, links]) => {
        if (!(links == null ? void 0 : links.length))
          return;
        const existing = frontmatter[field];
        if (existing) {
          const existing_array = ensure_is_array(existing);
          const new_links = remove_duplicates(
            existing_array.concat(links)
          );
          if (new_links.length !== existing_array.length) {
            mutated = true;
            frontmatter[field] = new_links;
          }
        } else {
          mutated = true;
          frontmatter[field] = links;
        }
      });
      if (mutated) {
        await plugin.app.fileManager.processFrontMatter(
          destination_file,
          (old_frontmatter) => {
            const new_frontmatter = Object.assign(
              old_frontmatter,
              frontmatter
            );
            log.debug(
              "drop_crumbs > processed frontmatter",
              new_frontmatter
            );
          }
        );
      }
      break;
    }
    case "dataview-inline": {
      const dataview_fields = Object.entries(links_by_field).map(([field, links]) => {
        if (!(links == null ? void 0 : links.length))
          return "";
        else
          return `${field}:: ${links.join(", ")}`;
      }).filter(Boolean);
      await plugin.app.vault.process(destination_file, (content) => {
        content += "\n\n" + dataview_fields.join("\n");
        return content;
      });
      break;
    }
    case "none": {
      break;
    }
  }
};

// src/commands/freeze_edges/index.ts
var freeze_implied_edges_to_note = async (plugin, source_file, options) => {
  const implied_edges = plugin.graph.get_out_edges(source_file.path).filter(
    (e) => (
      // Don't freeze a note to itself (self_is_sibling)
      !is_self_loop(e) && !e.attr.explicit && // If field === null, we don't have an opposite field to freeze to
      e.attr.field !== null
    )
  );
  await drop_crumbs(plugin, source_file, implied_edges, options);
};

// src/commands/jump/index.ts
var import_obsidian32 = require("obsidian");
var jump_to_neighbour = async (plugin, options) => {
  const active_file = get_store_value(active_file_store);
  if (!active_file)
    return;
  const matches = plugin.graph.get_out_edges(active_file.path).filter(
    (e) => has_edge_attrs(e, options.attr) && e.target_id !== active_file.path
  );
  if (!matches.length) {
    new import_obsidian32.Notice(
      `No matches found with attributes: ${url_search_params(options.attr)}`
    );
    return;
  } else {
    await plugin.app.workspace.openLinkText(
      matches[0].target_id,
      active_file.path
    );
  }
};

// src/commands/stats/index.ts
var get_graph_stats = (graph, data) => {
  var _a, _b;
  const stats = {
    nodes: {
      resolved: {}
    },
    edges: {
      round: {},
      field: {},
      group: {},
      source: {},
      explicit: {},
      implied_kind: {}
    }
  };
  for (const node of graph.nodeEntries()) {
    const resolved = String(node.attributes.resolved);
    stats.nodes.resolved[resolved] = (stats.nodes.resolved[resolved] || 0) + 1;
  }
  for (const { attributes: attr2 } of graph.edgeEntries()) {
    stats.edges.field[(_a = attr2.field) != null ? _a : "null"] = (stats.edges.field[(_b = attr2.field) != null ? _b : "null"] || 0) + 1;
    data.groups.forEach((group) => {
      if (group.fields.includes(attr2.field)) {
        stats.edges.group[group.label] = (stats.edges.group[group.label] || 0) + 1;
      }
    });
    const explicit = String(attr2.explicit);
    stats.edges.explicit[explicit] = (stats.edges.explicit[explicit] || 0) + 1;
    if (attr2.explicit) {
      stats.edges.source[attr2.source] = (stats.edges.source[attr2.source] || 0) + 1;
    } else {
      stats.edges.implied_kind[attr2.implied_kind] = (stats.edges.implied_kind[attr2.implied_kind] || 0) + 1;
      const round = String(attr2.round);
      stats.edges.round[round] = (stats.edges.round[round] || 0) + 1;
    }
  }
  return stats;
};

// src/commands/thread/index.ts
var import_obsidian33 = require("obsidian");
var thread = async (plugin, attr2, options) => {
  var _a, _b;
  const active_view = plugin.app.workspace.getActiveViewOfType(import_obsidian33.MarkdownView);
  if (!active_view)
    return;
  const source_file = active_view.file;
  if (!source_file)
    return;
  const template_data = {
    attr: attr2,
    source: {
      path: source_file.path,
      folder: (_b = (_a = source_file.parent) == null ? void 0 : _a.path) != null ? _b : "",
      basename: source_file.basename
    }
  };
  log.info("template_data", template_data);
  const target_path = Paths.normalise(
    Paths.ensure_ext(
      resolve_templates(options.target_path_template, template_data),
      "md"
    )
  );
  log.debug("thread > target_path", target_path);
  let target_file = null;
  try {
    target_file = await plugin.app.vault.create(target_path, "");
  } catch (error) {
    const msg = `Error creating file "${target_path}". ${error instanceof Error ? error.message : error}`;
    new import_obsidian33.Notice(msg);
    log.error(msg);
    return;
  }
  await drop_crumbs(
    plugin,
    source_file,
    [
      {
        attr: attr2,
        target_id: target_path,
        source_id: source_file.path,
        target_attr: { aliases: [] }
      }
    ],
    options
  );
  await Promise.all([
    // Let the cache update so that the refresh sees the new file
    // NOTE: I half-completed a less-flaky solution by listening to app.metadataCache.on("changed", ...)
    // But this only works if Dataview isn't enabled, and I couldn't find the correct event to listen to for Dataview
    sleep(500),
    active_view.leaf.openFile(target_file)
  ]);
  await plugin.refresh();
};

// src/commands/init.ts
var init_all_commands = (plugin) => {
  plugin.addCommand({
    id: "breadcrumbs:rebuild-graph",
    name: "Rebuild graph",
    callback: async () => await plugin.refresh()
  });
  Object.keys(VIEW_IDS).forEach((view_id) => {
    plugin.addCommand({
      id: `breadcrumbs:open-${view_id}-view`,
      name: `Open ${view_id} view`,
      callback: () => plugin.activateView(VIEW_IDS[view_id])
    });
  });
  plugin.addCommand({
    id: "breadcrumbs:create-list-index",
    name: "Create list index",
    callback: () => {
      new CreateListIndexModal(plugin.app, plugin).open();
    }
  });
  plugin.addCommand({
    id: "breadcrumbs:graph-stats",
    name: "Show/Copy graph stats",
    callback: async () => {
      const stats = get_graph_stats(plugin.graph, {
        groups: plugin.settings.edge_field_groups
      });
      log.feat("Graph stats >", stats);
      await navigator.clipboard.writeText(JSON.stringify(stats, null, 2));
      new import_obsidian34.Notice(
        "Graph stats printed to console and copied to clipboard"
      );
    }
  });
  plugin.addCommand({
    id: "breadcrumbs:freeze-implied-edges-to-note",
    name: "Freeze implied edges to note",
    callback: async () => {
      const active_file = get_store_value(active_file_store);
      if (!active_file)
        return;
      await freeze_implied_edges_to_note(
        plugin,
        active_file,
        plugin.settings.commands.freeze_implied_edges.default_options
      );
      new import_obsidian34.Notice("Implied edges frozen to note");
    }
  });
  plugin.addCommand({
    id: "breadcrumbs:freeze-implied-edges-to-vault",
    name: "Freeze implied edges to all notes in vault",
    callback: async () => {
      if (!confirm(
        "Are you sure you want to freeze implied edges to all notes in vault? This will write to all notes that have outgoing implied edges."
      )) {
        return new import_obsidian34.Notice("Command cancelled");
      }
      const PROMPT_TARGET = "FREEZE TO VAULT";
      new GenericModal(plugin.app, (modal) => {
        new SimpleInput_default({
          target: modal.contentEl,
          props: {
            label: `Type '${PROMPT_TARGET}' to confirm`,
            disabled_cb: (value) => value !== PROMPT_TARGET
          }
        }).$on("submit", async (e) => {
          if (e.detail !== PROMPT_TARGET) {
            new import_obsidian34.Notice("Command cancelled");
          } else {
            const timer = new Timer();
            const notice = new import_obsidian34.Notice(
              "Freezing implied edges to all notes in vault..."
            );
            await Promise.all(
              plugin.app.vault.getMarkdownFiles().map(
                (file) => freeze_implied_edges_to_note(
                  plugin,
                  file,
                  plugin.settings.commands.freeze_implied_edges.default_options
                )
              )
            );
            log.debug(
              `freeze-implied-edges-to-vault > took ${timer.elapsed_str()}ms`
            );
            notice.setMessage(
              `Implied edges frozen to all notes in ${timer.elapsed_str()}ms`
            );
          }
          modal.close();
        });
      }).open();
    }
  });
  plugin.settings.edge_field_groups.forEach((group) => {
    plugin.addCommand({
      id: `breadcrumbs:jump-to-first-neighbour-group:${group.label}`,
      name: `Jump to first neighbour by group:${group.label}`,
      callback: () => jump_to_neighbour(plugin, {
        attr: { $or_fields: group.fields }
      })
    });
  });
  plugin.settings.edge_fields.forEach(({ label }) => {
    plugin.addCommand({
      id: `breadcrumbs:thread-field:${label}`,
      name: `Thread by field:${label}`,
      callback: () => thread(
        plugin,
        { field: label },
        plugin.settings.commands.thread.default_options
      )
    });
  });
};

// src/interfaces/settings.ts
var OLD_DIRECTIONS = ["up", "down", "same", "prev", "next"];

// src/settings/migration.ts
var get_opposite_direction = (dir) => {
  switch (dir) {
    case "up":
      return "down";
    case "down":
      return "up";
    case "same":
      return "same";
    case "next":
      return "prev";
    case "prev":
      return "next";
  }
};
var migrate_old_settings = (settings) => {
  const old = settings;
  if (old.userHiers && old.impliedRelations) {
    const implied_relationships = {
      opposite_direction: {
        rounds: 1
      },
      self_is_sibling: {
        rounds: Number(old.impliedRelations.siblingIdentity)
      },
      cousin_is_sibling: {
        rounds: Number(old.impliedRelations.cousinsIsSibling)
      },
      same_parent_is_sibling: {
        rounds: Number(old.impliedRelations.sameParentIsSibling)
      },
      same_sibling_is_sibling: {
        rounds: Number(old.impliedRelations.siblingsSiblingIsSibling)
      },
      siblings_parent_is_parent: {
        rounds: Number(old.impliedRelations.siblingsParentIsParent)
      },
      parents_sibling_is_parent: {
        rounds: Number(old.impliedRelations.parentsSiblingsIsParents)
      }
    };
    old.hierarchies = old.userHiers.map((hierarchy) => ({
      dirs: OLD_DIRECTIONS.reduce(
        (acc, dir) => ({
          ...acc,
          [dir]: hierarchy[dir]
        }),
        {}
      ),
      implied_relationships
    }));
    delete old.userHiers;
    delete old.impliedRelations;
  }
  if (old.hierarchies) {
    OLD_DIRECTIONS.forEach((dir) => {
      const fields = old.hierarchies.flatMap((hier) => hier.dirs[dir]).filter(Boolean);
      const label = `${dir}s`;
      const existing = settings.edge_field_groups.find(
        (group) => group.label === label
      );
      if (existing) {
        existing.fields.push(...fields);
        existing.fields = remove_duplicates(existing.fields);
      } else {
        settings.edge_field_groups.push({ label, fields });
      }
    });
    old.hierarchies.forEach((hier, hier_i) => {
      Object.values(hier.dirs).flatMap((fields) => fields).filter(Boolean).forEach((label) => {
        if (!settings.edge_fields.find(
          (field) => field.label === label
        )) {
          settings.edge_fields.push({ label });
        }
      });
      Object.entries(hier.implied_relationships).forEach(
        ([rel, { rounds }]) => {
          if (!rounds)
            return;
          const fields = {
            up: hier.dirs.up[0],
            same: hier.dirs.same[0],
            down: hier.dirs.down[0],
            next: hier.dirs.next[0],
            prev: hier.dirs.prev[0]
          };
          switch (rel) {
            case "opposite_direction": {
              OLD_DIRECTIONS.forEach((dir) => {
                const field = fields[dir];
                const close_field = fields[get_opposite_direction(dir)];
                if (!field || !close_field)
                  return;
                settings.implied_relations.transitive.push({
                  rounds,
                  name: "",
                  close_field,
                  chain: [{ field }],
                  close_reversed: true
                });
              });
              break;
            }
            case "cousin_is_sibling": {
              if (!fields.up || !fields.same || !fields.down) {
                return;
              }
              settings.implied_relations.transitive.push({
                rounds,
                name: "",
                chain: [
                  { field: fields.up },
                  { field: fields.same },
                  { field: fields.down }
                ],
                close_reversed: false,
                close_field: fields.same
              });
              break;
            }
            case "same_parent_is_sibling": {
              if (!fields.up || !fields.down || !fields.down) {
                return;
              }
              settings.implied_relations.transitive.push({
                rounds,
                name: "",
                chain: [
                  { field: fields.up },
                  { field: fields.down }
                ],
                close_reversed: false,
                close_field: fields.same
              });
              break;
            }
            case "same_sibling_is_sibling": {
              if (!fields.same)
                return;
              settings.implied_relations.transitive.push({
                rounds,
                name: "",
                chain: [
                  { field: fields.same },
                  { field: fields.same }
                ],
                close_reversed: false,
                close_field: fields.same
              });
              break;
            }
            case "siblings_parent_is_parent": {
              if (!fields.up || !fields.same)
                return;
              settings.implied_relations.transitive.push({
                rounds,
                name: "",
                chain: [
                  { field: fields.same },
                  { field: fields.up }
                ],
                close_reversed: false,
                close_field: fields.up
              });
              break;
            }
            case "parents_sibling_is_parent": {
              if (!fields.up || !fields.same)
                return;
              settings.implied_relations.transitive.push({
                rounds,
                name: "",
                chain: [
                  { field: fields.up },
                  { field: fields.same }
                ],
                close_reversed: false,
                close_field: fields.up
              });
              break;
            }
          }
        }
      );
    });
    delete old.hierarchies;
    settings.edge_field_groups = remove_duplicates_by(
      settings.edge_field_groups,
      (group) => group.label
    );
  }
  if (old.custom_implied_relations) {
    old.custom_implied_relations.transitive.forEach((rel) => {
      settings.implied_relations.transitive.push({
        ...rel,
        name: "",
        close_reversed: false
      });
    });
    delete old.custom_implied_relations;
  }
  settings.implied_relations.transitive = remove_duplicates_by(
    settings.implied_relations.transitive,
    stringify_transitive_relation
  );
  if (old.tagNoteField !== void 0) {
    settings.explicit_edge_sources.tag_note.default_field = old.tagNoteField;
    delete old.tagNoteField;
  }
  if (old.hierarchyNotes !== void 0 && old.hierarchyNoteIsParent !== void 0 && old.HNUpField !== void 0) {
    if (old.hierarchyNotes.length > 0) {
      const msg = `DEPRECATED: The central Hierarchy Notes setting is deprecated in favour of the "${META_ALIAS["list-note-field"]}" field in each hierarchy note.`;
      log.warn(msg);
    }
    delete old.HNUpField;
    delete old.hierarchyNotes;
    delete old.hierarchyNoteIsParent;
  }
  if (old.addDendronNotes !== void 0 && old.dendronNoteField !== void 0 && old.trimDendronNotes !== void 0 && old.dendronNoteDelimiter !== void 0) {
    settings.explicit_edge_sources.dendron_note = {
      enabled: old.addDendronNotes,
      default_field: old.dendronNoteField,
      delimiter: old.dendronNoteDelimiter,
      display_trimmed: old.trimDendronNotes
    };
    delete old.addDendronNotes;
    delete old.dendronNoteField;
    delete old.trimDendronNotes;
    delete old.dendronNoteDelimiter;
  }
  if (old.addDateNotes !== void 0 && old.dateNoteField !== void 0 && old.dateNoteFormat !== void 0) {
    settings.explicit_edge_sources.date_note = {
      ...DEFAULT_SETTINGS.explicit_edge_sources.date_note,
      enabled: old.addDateNotes,
      default_field: old.dateNoteField,
      date_format: old.dateNoteFormat
    };
    delete old.addDateNotes;
    delete old.dateNoteField;
    delete old.dateNoteFormat;
  }
  if (old.respectReadableLineLength !== void 0) {
    settings.views.page.all.readable_line_width = old.respectReadableLineLength;
    delete old.respectReadableLineLength;
  }
  if (old.showBCs !== void 0) {
    settings.views.page.trail.enabled = old.showBCs;
    delete old.showBCs;
  }
  if (old.showGrid !== void 0) {
    settings.views.page.trail.format = old.showGrid ? "grid" : "path";
    delete old.showGrid;
  }
  if (old.gridDefaultDepth !== void 0) {
    settings.views.page.trail.default_depth = old.gridDefaultDepth;
    delete old.gridDefaultDepth;
  }
  if (old.noPathMessage !== void 0) {
    settings.views.page.trail.no_path_message = old.noPathMessage;
    delete old.noPathMessage;
  }
  if (old.showPrevNext !== void 0) {
    settings.views.page.prev_next.enabled = old.showPrevNext;
    delete old.showPrevNext;
  }
  if (old.views.side.tree.default_dir !== void 0) {
    delete old.views.side.tree.default_dir;
  }
  if (settings.codeblocks !== void 0) {
    settings.views.codeblocks = settings.codeblocks;
    delete settings.codeblocks;
  }
  if (old.showRefreshNotice !== void 0 && old.refreshOnNoteSave !== void 0 && old.refreshOnNoteChange !== void 0) {
    settings.commands.rebuild_graph.notify = old.showRefreshNotice;
    settings.commands.rebuild_graph.trigger = {
      note_save: old.refreshOnNoteSave,
      layout_change: old.refreshOnNoteChange
    };
    delete old.showRefreshNotice;
    delete old.refreshOnNoteSave;
    delete old.refreshOnNoteChange;
  }
  if (old.wikilinkIndex !== void 0 && old.aliasesInIndex !== void 0 && old.createIndexIndent !== void 0) {
    settings.commands.list_index.default_options = {
      ...settings.commands.list_index.default_options,
      indent: old.createIndexIndent,
      link_kind: old.wikilinkIndex ? "wiki" : "none",
      show_node_options: {
        ...ListIndex.DEFAULT_OPTIONS.show_node_options,
        alias: old.aliasesInIndex
      }
    };
    delete settings.commands.list_index.default_options.dir;
    delete old.wikilinkIndex;
    delete old.aliasesInIndex;
    delete old.createIndexIndent;
  }
  if (old.writeBCsInline !== void 0) {
    settings.commands.freeze_implied_edges.default_options.destination = old.writeBCsInline ? "dataview-inline" : "frontmatter";
    delete old.writeBCsInline;
  }
  if (old.threadingTemplate !== void 0) {
    settings.commands.thread.default_options.target_path_template = old.threadingTemplate;
    delete old.threadingTemplate;
  }
  if (old.threadUnderCursor !== void 0) {
    settings.commands.thread.default_options.destination = old.threadUnderCursor ? "dataview-inline" : "frontmatter";
    delete old.threadUnderCursor;
  }
  if (old.enableRelationSuggestor !== void 0) {
    settings.suggestors.edge_field.enabled = old.enableRelationSuggestor;
    delete old.enableRelationSuggestor;
  }
  if (old.relSuggestorTrigger !== void 0) {
    settings.suggestors.edge_field.trigger = old.relSuggestorTrigger;
    delete old.relSuggestorTrigger;
  }
  if (old.suggestors.hierarchy_field !== void 0) {
    settings.suggestors.edge_field = old.suggestors.hierarchy_field;
    delete old.suggestors.hierarchy_field;
  }
  if (old.alphaSortAsc !== void 0) {
    delete old.alphaSortAsc;
  }
  if (old.debugMode) {
    delete old.debugMode;
  }
  if (old.dvWaitTime !== void 0) {
    delete old.dvWaitTime;
  }
  if (old.fieldSuggestor !== void 0) {
    delete old.fieldSuggestor;
  }
  if (old.filterImpliedSiblingsOfDifferentTypes !== void 0) {
    delete old.filterImpliedSiblingsOfDifferentTypes;
  }
  if (old.jugglLayout !== void 0) {
    delete old.jugglLayout;
  }
  return settings;
};

// src/suggestor/edge_fields.ts
var import_obsidian35 = require("obsidian");
var EdgeFieldSuggestor = class extends import_obsidian35.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.getSuggestions = ({ query }) => this.plugin.settings.edge_fields.map((f) => f.label).filter((field) => field.includes(query));
    this.plugin = plugin;
  }
  onTrigger(cursor, editor, _file) {
    const { trigger } = this.plugin.settings.suggestors.edge_field;
    const sub = editor.getLine(cursor.line).substring(0, cursor.ch);
    if (!sub.startsWith(trigger))
      return null;
    const query = sub.slice(trigger.length);
    return {
      query,
      end: cursor,
      start: { ch: 0, line: cursor.line }
    };
  }
  renderSuggestion(suggestion, el) {
    el.createDiv({ text: suggestion });
  }
  selectSuggestion(suggestion) {
    if (!this.context)
      return;
    const { start, end, editor } = this.context;
    editor.replaceRange(suggestion + ":: [[", start, end);
  }
};

// src/views/tree.ts
var import_obsidian36 = require("obsidian");

// src/components/side_views/TreeView.svelte
function create_else_block12(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "No paths found";
      attr(div, "class", "search-empty-state");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block21(ctx) {
  let nestededgelist;
  let current;
  nestededgelist = new NestedEdgeList_default({
    props: {
      sort: (
        /*sort*/
        ctx[7]
      ),
      tree: (
        /*tree*/
        ctx[6]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      show_attributes: (
        /*show_attributes*/
        ctx[4]
      ),
      show_node_options: (
        /*show_node_options*/
        ctx[8]
      ),
      open_signal: !/*collapse*/
      ctx[5]
    }
  });
  return {
    c() {
      create_component(nestededgelist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(nestededgelist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const nestededgelist_changes = {};
      if (dirty & /*sort*/
      128)
        nestededgelist_changes.sort = /*sort*/
        ctx2[7];
      if (dirty & /*tree*/
      64)
        nestededgelist_changes.tree = /*tree*/
        ctx2[6];
      if (dirty & /*plugin*/
      1)
        nestededgelist_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*show_attributes*/
      16)
        nestededgelist_changes.show_attributes = /*show_attributes*/
        ctx2[4];
      if (dirty & /*collapse*/
      32)
        nestededgelist_changes.open_signal = !/*collapse*/
        ctx2[5];
      nestededgelist.$set(nestededgelist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nestededgelist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nestededgelist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(nestededgelist, detaching);
    }
  };
}
function create_key_block6(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block21, create_else_block12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tree*/
      ctx2[6].length
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_fragment55(ctx) {
  let div3;
  let div1;
  let div0;
  let rebuildgraphbutton;
  let t0;
  let edgesortidselector;
  let updating_edge_sort_id;
  let t1;
  let showattributesselectormenu;
  let updating_show_attributes;
  let t2;
  let chevroncollapsebutton;
  let updating_collapse;
  let t3;
  let mergefieldsbutton;
  let updating_merge_fields;
  let t4;
  let fieldgrouplabelsselector;
  let updating_field_group_labels;
  let t5;
  let div2;
  let previous_key = (
    /*tree*/
    ctx[6] || /*sort*/
    ctx[7]
  );
  let current;
  rebuildgraphbutton = new RebuildGraphButton_default({
    props: {
      cls: "clickable-icon nav-action-button",
      plugin: (
        /*plugin*/
        ctx[0]
      )
    }
  });
  function edgesortidselector_edge_sort_id_binding(value) {
    ctx[11](value);
  }
  let edgesortidselector_props = {
    cls: "clickable-icon nav-action-button",
    exclude_fields: []
  };
  if (
    /*edge_sort_id*/
    ctx[1] !== void 0
  ) {
    edgesortidselector_props.edge_sort_id = /*edge_sort_id*/
    ctx[1];
  }
  edgesortidselector = new EdgeSortIdSelector_default({ props: edgesortidselector_props });
  binding_callbacks.push(() => bind(edgesortidselector, "edge_sort_id", edgesortidselector_edge_sort_id_binding));
  function showattributesselectormenu_show_attributes_binding(value) {
    ctx[12](value);
  }
  let showattributesselectormenu_props = { cls: "clickable-icon nav-action-button" };
  if (
    /*show_attributes*/
    ctx[4] !== void 0
  ) {
    showattributesselectormenu_props.show_attributes = /*show_attributes*/
    ctx[4];
  }
  showattributesselectormenu = new ShowAttributesSelectorMenu_default({ props: showattributesselectormenu_props });
  binding_callbacks.push(() => bind(showattributesselectormenu, "show_attributes", showattributesselectormenu_show_attributes_binding));
  function chevroncollapsebutton_collapse_binding(value) {
    ctx[13](value);
  }
  let chevroncollapsebutton_props = { cls: "clickable-icon nav-action-button" };
  if (
    /*collapse*/
    ctx[5] !== void 0
  ) {
    chevroncollapsebutton_props.collapse = /*collapse*/
    ctx[5];
  }
  chevroncollapsebutton = new ChevronCollapseButton_default({ props: chevroncollapsebutton_props });
  binding_callbacks.push(() => bind(chevroncollapsebutton, "collapse", chevroncollapsebutton_collapse_binding));
  function mergefieldsbutton_merge_fields_binding(value) {
    ctx[14](value);
  }
  let mergefieldsbutton_props = { cls: "clickable-icon nav-action-button" };
  if (
    /*merge_fields*/
    ctx[2] !== void 0
  ) {
    mergefieldsbutton_props.merge_fields = /*merge_fields*/
    ctx[2];
  }
  mergefieldsbutton = new MergeFieldsButton_default({ props: mergefieldsbutton_props });
  binding_callbacks.push(() => bind(mergefieldsbutton, "merge_fields", mergefieldsbutton_merge_fields_binding));
  function fieldgrouplabelsselector_field_group_labels_binding(value) {
    ctx[15](value);
  }
  let fieldgrouplabelsselector_props = {
    cls: "clickable-icon nav-action-button",
    edge_field_groups: (
      /*plugin*/
      ctx[0].settings.edge_field_groups
    )
  };
  if (
    /*field_group_labels*/
    ctx[3] !== void 0
  ) {
    fieldgrouplabelsselector_props.field_group_labels = /*field_group_labels*/
    ctx[3];
  }
  fieldgrouplabelsselector = new FieldGroupLabelsSelector_default({ props: fieldgrouplabelsselector_props });
  binding_callbacks.push(() => bind(fieldgrouplabelsselector, "field_group_labels", fieldgrouplabelsselector_field_group_labels_binding));
  let key_block = create_key_block6(ctx);
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      create_component(rebuildgraphbutton.$$.fragment);
      t0 = space();
      create_component(edgesortidselector.$$.fragment);
      t1 = space();
      create_component(showattributesselectormenu.$$.fragment);
      t2 = space();
      create_component(chevroncollapsebutton.$$.fragment);
      t3 = space();
      create_component(mergefieldsbutton.$$.fragment);
      t4 = space();
      create_component(fieldgrouplabelsselector.$$.fragment);
      t5 = space();
      div2 = element("div");
      key_block.c();
      attr(div0, "class", "nav-buttons-container");
      attr(div1, "class", "nav-header");
      attr(div2, "class", "BC-tree-view-items");
      attr(div3, "class", "markdown-rendered BC-tree-view");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, div0);
      mount_component(rebuildgraphbutton, div0, null);
      append(div0, t0);
      mount_component(edgesortidselector, div0, null);
      append(div0, t1);
      mount_component(showattributesselectormenu, div0, null);
      append(div0, t2);
      mount_component(chevroncollapsebutton, div0, null);
      append(div0, t3);
      mount_component(mergefieldsbutton, div0, null);
      append(div0, t4);
      mount_component(fieldgrouplabelsselector, div0, null);
      append(div3, t5);
      append(div3, div2);
      key_block.m(div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const rebuildgraphbutton_changes = {};
      if (dirty & /*plugin*/
      1)
        rebuildgraphbutton_changes.plugin = /*plugin*/
        ctx2[0];
      rebuildgraphbutton.$set(rebuildgraphbutton_changes);
      const edgesortidselector_changes = {};
      if (!updating_edge_sort_id && dirty & /*edge_sort_id*/
      2) {
        updating_edge_sort_id = true;
        edgesortidselector_changes.edge_sort_id = /*edge_sort_id*/
        ctx2[1];
        add_flush_callback(() => updating_edge_sort_id = false);
      }
      edgesortidselector.$set(edgesortidselector_changes);
      const showattributesselectormenu_changes = {};
      if (!updating_show_attributes && dirty & /*show_attributes*/
      16) {
        updating_show_attributes = true;
        showattributesselectormenu_changes.show_attributes = /*show_attributes*/
        ctx2[4];
        add_flush_callback(() => updating_show_attributes = false);
      }
      showattributesselectormenu.$set(showattributesselectormenu_changes);
      const chevroncollapsebutton_changes = {};
      if (!updating_collapse && dirty & /*collapse*/
      32) {
        updating_collapse = true;
        chevroncollapsebutton_changes.collapse = /*collapse*/
        ctx2[5];
        add_flush_callback(() => updating_collapse = false);
      }
      chevroncollapsebutton.$set(chevroncollapsebutton_changes);
      const mergefieldsbutton_changes = {};
      if (!updating_merge_fields && dirty & /*merge_fields*/
      4) {
        updating_merge_fields = true;
        mergefieldsbutton_changes.merge_fields = /*merge_fields*/
        ctx2[2];
        add_flush_callback(() => updating_merge_fields = false);
      }
      mergefieldsbutton.$set(mergefieldsbutton_changes);
      const fieldgrouplabelsselector_changes = {};
      if (dirty & /*plugin*/
      1)
        fieldgrouplabelsselector_changes.edge_field_groups = /*plugin*/
        ctx2[0].settings.edge_field_groups;
      if (!updating_field_group_labels && dirty & /*field_group_labels*/
      8) {
        updating_field_group_labels = true;
        fieldgrouplabelsselector_changes.field_group_labels = /*field_group_labels*/
        ctx2[3];
        add_flush_callback(() => updating_field_group_labels = false);
      }
      fieldgrouplabelsselector.$set(fieldgrouplabelsselector_changes);
      if (dirty & /*tree, sort*/
      192 && safe_not_equal(previous_key, previous_key = /*tree*/
      ctx2[6] || /*sort*/
      ctx2[7])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block6(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div2, null);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(rebuildgraphbutton.$$.fragment, local);
      transition_in(edgesortidselector.$$.fragment, local);
      transition_in(showattributesselectormenu.$$.fragment, local);
      transition_in(chevroncollapsebutton.$$.fragment, local);
      transition_in(mergefieldsbutton.$$.fragment, local);
      transition_in(fieldgrouplabelsselector.$$.fragment, local);
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(rebuildgraphbutton.$$.fragment, local);
      transition_out(edgesortidselector.$$.fragment, local);
      transition_out(showattributesselectormenu.$$.fragment, local);
      transition_out(chevroncollapsebutton.$$.fragment, local);
      transition_out(mergefieldsbutton.$$.fragment, local);
      transition_out(fieldgrouplabelsselector.$$.fragment, local);
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(rebuildgraphbutton);
      destroy_component(edgesortidselector);
      destroy_component(showattributesselectormenu);
      destroy_component(chevroncollapsebutton);
      destroy_component(mergefieldsbutton);
      destroy_component(fieldgrouplabelsselector);
      key_block.d(detaching);
    }
  };
}
function instance55($$self, $$props, $$invalidate) {
  let sort;
  let edge_field_labels;
  let tree;
  let $active_file_store;
  component_subscribe($$self, active_file_store, ($$value) => $$invalidate(10, $active_file_store = $$value));
  let { plugin } = $$props;
  let { edge_sort_id, merge_fields, show_attributes, show_node_options, field_group_labels, collapse } = plugin.settings.views.side.tree;
  const base_traversal = (attr2) => Traverse.build_tree(
    plugin.graph,
    $active_file_store.path,
    // TODO: Customisable max depth
    { max_depth: 20 },
    (edge) => has_edge_attrs(edge, attr2)
  );
  function edgesortidselector_edge_sort_id_binding(value) {
    edge_sort_id = value;
    $$invalidate(1, edge_sort_id);
  }
  function showattributesselectormenu_show_attributes_binding(value) {
    show_attributes = value;
    $$invalidate(4, show_attributes);
  }
  function chevroncollapsebutton_collapse_binding(value) {
    collapse = value;
    $$invalidate(5, collapse);
  }
  function mergefieldsbutton_merge_fields_binding(value) {
    merge_fields = value;
    $$invalidate(2, merge_fields);
  }
  function fieldgrouplabelsselector_field_group_labels_binding(value) {
    field_group_labels = value;
    $$invalidate(3, field_group_labels);
  }
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*edge_sort_id, plugin*/
    3) {
      $:
        $$invalidate(7, sort = get_edge_sorter(edge_sort_id, plugin.graph));
    }
    if ($$self.$$.dirty & /*plugin, field_group_labels*/
    9) {
      $:
        $$invalidate(9, edge_field_labels = resolve_field_group_labels(plugin.settings.edge_field_groups, field_group_labels));
    }
    if ($$self.$$.dirty & /*$active_file_store, plugin, merge_fields, edge_field_labels*/
    1541) {
      $:
        $$invalidate(6, tree = $active_file_store && plugin.graph.hasNode($active_file_store.path) ? merge_fields ? base_traversal({ $or_fields: edge_field_labels }) : edge_field_labels.flatMap((field) => base_traversal({ field })) : []);
    }
  };
  return [
    plugin,
    edge_sort_id,
    merge_fields,
    field_group_labels,
    show_attributes,
    collapse,
    tree,
    sort,
    show_node_options,
    edge_field_labels,
    $active_file_store,
    edgesortidselector_edge_sort_id_binding,
    showattributesselectormenu_show_attributes_binding,
    chevroncollapsebutton_collapse_binding,
    mergefieldsbutton_merge_fields_binding,
    fieldgrouplabelsselector_field_group_labels_binding
  ];
}
var TreeView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance55, create_fragment55, safe_not_equal, { plugin: 0 });
  }
};
var TreeView_default = TreeView;

// src/views/tree.ts
var TreeView2 = class extends import_obsidian36.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.icon = "tree-pine";
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_IDS.tree;
  }
  getDisplayText() {
    return "Tree view";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    this.component = new TreeView_default({
      target: this.contentEl,
      props: { plugin: this.plugin }
    });
  }
  async onClose() {
    var _a;
    (_a = this.component) == null ? void 0 : _a.$destroy();
  }
};

// src/main.ts
var BreadcrumbsPlugin = class extends import_obsidian37.Plugin {
  constructor() {
    super(...arguments);
    this.graph = new BCGraph();
    /** rebuild_graph, then react by updating active_file_store and redrawing page_views.
     * Optionally disable any of these steps.
     */
    this.refresh = async (options) => {
      if ((options == null ? void 0 : options.rebuild_graph) !== false) {
        const timer = new Timer();
        const notice = this.settings.commands.rebuild_graph.notify ? new import_obsidian37.Notice("Rebuilding graph") : null;
        const rebuild_results = await rebuild_graph(this);
        this.graph = rebuild_results.graph;
        const explicit_edge_errors = rebuild_results.explicit_edge_results.filter((result) => result.errors.length).reduce(
          (acc, { source, errors }) => {
            acc[source] = errors;
            return acc;
          },
          {}
        );
        const implied_edge_results = Object.fromEntries(
          Object.entries(rebuild_results.implied_edge_results).filter(([_, errors]) => errors.length).map(([implied_kind, errors]) => [implied_kind, errors])
        );
        if (Object.keys(explicit_edge_errors).length) {
          log.warn("explicit_edge_errors >", explicit_edge_errors);
        }
        if (Object.keys(implied_edge_results).length) {
          log.warn("implied_edge_results >", implied_edge_results);
        }
        notice == null ? void 0 : notice.setMessage(
          [
            `Rebuilt graph in ${timer.elapsed_str()}ms`,
            explicit_edge_errors.length ? "\nExplicit edge errors (see console for details):" : null,
            ...Object.entries(explicit_edge_errors).map(
              ([source, errors]) => `- ${source}: ${errors.length} errors`
            ),
            implied_edge_results.length ? "\nImplied edge errors (see console for details):" : null,
            ...Object.entries(implied_edge_results).map(
              ([implied_kind, errors]) => `- ${implied_kind}: ${errors.length} errors`
            )
          ].filter(Boolean).join("\n")
        );
      }
      if ((options == null ? void 0 : options.active_file_store) !== false) {
        active_file_store.refresh(this.app);
      }
      if ((options == null ? void 0 : options.redraw_page_views) !== false) {
        redraw_page_views(this);
      }
      if ((options == null ? void 0 : options.redraw_codeblocks) !== false) {
        Codeblocks.update_all();
      }
      if ((options == null ? void 0 : options.redraw_side_views) === true) {
        this.app.workspace.getLeavesOfType(VIEW_IDS.matrix).forEach((leaf) => {
          leaf.view.onOpen();
        });
        this.app.workspace.getLeavesOfType(VIEW_IDS.tree).forEach((leaf) => {
          leaf.view.onOpen();
        });
      }
    };
  }
  async onload() {
    var _a, _b;
    await this.loadSettings();
    log.set_level(this.settings.debug.level);
    log.info(
      `loading plugin "${this.manifest.name}" plugin v${this.manifest.version}`
    );
    log.debug("settings >", this.settings);
    this.settings = migrate_old_settings(this.settings);
    await this.saveSettings();
    try {
      const all_properties = this.app.metadataTypeManager.getAllProperties();
      for (const field of this.settings.edge_fields) {
        if (((_a = all_properties[field.label]) == null ? void 0 : _a.type) === "multitext")
          continue;
        this.app.metadataTypeManager.setType(field.label, "multitext");
      }
      for (const [field, { property_type }] of Object.entries(
        METADATA_FIELDS_MAP
      )) {
        if (((_b = all_properties[field]) == null ? void 0 : _b.type) === property_type)
          continue;
        this.app.metadataTypeManager.setType(field, property_type);
      }
    } catch (error) {
      log.error("metadataTypeManager.setType error >", error);
    }
    this.addSettingTab(new BreadcrumbsSettingTab(this.app, this));
    this.api = new BCAPI(this);
    window.BCAPI = this.api;
    this.register(
      // @ts-ignore: Don't want to make it optional, but still delete on unload
      () => delete window.BCAPI
    );
    this.registerHoverLinkSource("breadcrumbs", {
      defaultMod: true,
      display: "Breadcrumbs"
    });
    if (this.settings.suggestors.edge_field.enabled) {
      this.registerEditorSuggest(new EdgeFieldSuggestor(this));
    }
    this.app.workspace.onLayoutReady(async () => {
      log.debug("on:layout-ready");
      await dataview_plugin.await_if_enabled(this);
      if (this.app.metadataCache.initialized) {
        log.debug("metadataCache:initialized");
        await this.refresh();
      } else {
        const metadatacache_init_event = this.app.metadataCache.on(
          "initialized",
          async () => {
            log.debug("on:metadatacache-initialized");
            await this.refresh();
            this.app.metadataCache.offref(metadatacache_init_event);
          }
        );
      }
      this.registerEvent(
        this.app.workspace.on("layout-change", async () => {
          log.debug("on:layout-change");
          await this.refresh({
            rebuild_graph: this.settings.commands.rebuild_graph.trigger.layout_change
          });
        })
      );
      this.registerEvent(
        this.app.workspace.on("active-leaf-change", async (leaf) => {
          log.debug("on:active-leaf-change");
          if ((leaf == null ? void 0 : leaf.getViewState().type) !== "markdown") {
            return;
          }
          this.refresh({
            rebuild_graph: false,
            redraw_page_views: false
          });
        })
      );
      this.registerEvent(
        this.app.vault.on("create", (file) => {
          log.debug("on:create >", file.path);
          if (file instanceof import_obsidian37.TFile) {
            this.graph.upsert_node(file.path, { resolved: true });
          }
        })
      );
      this.registerEvent(
        this.app.vault.on("rename", (file, old_path) => {
          log.debug("on:rename >", old_path, "->", file.path);
          if (file instanceof import_obsidian37.TFile) {
            const res = this.graph.safe_rename_node(
              old_path,
              file.path
            );
            if (!res.ok) {
              log.error("safe_rename_node >", res.error.message);
            }
          }
        })
      );
      this.registerEvent(
        this.app.vault.on("delete", (file) => {
          log.debug("on:delete >", file.path);
          if (file instanceof import_obsidian37.TFile) {
            this.graph.setNodeAttribute(
              file.path,
              "resolved",
              false
            );
          }
        })
      );
      this.registerView(
        VIEW_IDS.matrix,
        (leaf) => new MatrixView(leaf, this)
      );
      this.registerView(
        VIEW_IDS.tree,
        (leaf) => new TreeView2(leaf, this)
      );
    });
    this.registerMarkdownCodeBlockProcessor(
      "breadcrumbs",
      (source, el, ctx) => {
        const mdrc = new CodeblockMDRC(
          this,
          el,
          source,
          ctx.sourcePath
        );
        ctx.addChild(mdrc);
      }
    );
    init_all_commands(this);
    log.debug("loaded Breadcrumbs plugin");
  }
  onunload() {
  }
  async loadSettings() {
    var _a;
    this.settings = deep_merge_objects(
      (_a = await this.loadData()) != null ? _a : {},
      DEFAULT_SETTINGS
    );
  }
  async saveSettings() {
    this.settings.is_dirty = false;
    await this.saveData(this.settings);
  }
  // SOURCE: https://docs.obsidian.md/Plugins/User+interface/Views
  async activateView(view_id, options) {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(view_id);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = (options == null ? void 0 : options.side) === "left" ? workspace.getLeftLeaf(false) : workspace.getRightLeaf(false);
      if (!leaf) {
        log.warn("activate_view > no leaf found");
        return;
      }
      await leaf.setViewState({ type: view_id, active: true });
    }
    workspace.revealLeaf(leaf);
  }
};
/*! Bundled license information:

lucide-svelte/dist/defaultAttributes.js:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-down-wide-narrow.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-down.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-up-narrow-wide.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-up.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/check.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/chevron-down.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/chevron-right.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/chevrons-down-up.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/chevrons-up-down.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/clipboard.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-json.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/group.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/image.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/merge.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/pencil.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/plus.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/rotate-ccw.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/save.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/split.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/index.js:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/aliases.js:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/
