---
created: 2025-03-21T13:40:42
title: "Paraleln√≠ ≈ôazen√≠ v OpenMP"
up: "[[üìñNI-PDP]]"
---

TARGET DECK: NI-PDP
FILE TAGS: NI-PDP prednaska05 status-toReview


START
FIT-Card

Jak√© vlastnosti m√° QuickSort? (4)

Back:

- **Datovƒõ citliv√Ω** - rychlost z√°vis√≠ na vstupu
- **In-place**
- **Nestabiln√≠** - nezachov√°v√° po≈ôad√≠ stejn√Ωch prvk≈Ø
- **Staƒç√≠ operace** compare & swap

<!-- DetailInfoStart -->
![](../../Assets/Pasted%20image%2020250321134058.png)
<!-- DetailInfoEnd -->

Tags: otazka14
<!--ID: 1746599653590-->
END

---


START
FIT-Card

Jak vypad√° sekvenƒçn√≠ verze QuickSortu?

Back:

**seq_quicksort**:
- `if(lo<hi)`
- `long r = seq_partition_L(A,lo,hi)` - najde dƒõl√≠c√≠ bod
- `seq_quicksort(A, lo, r-1)`
- `seq_quicksort(A, r+1, hi)`

**seq_partition_L**
- `pivot = A[hi]` - posledn√≠ prvek je pivot
- `j = lo; iterace od lo do hi`
	- `if(A[j] < pivot) swap (A, i++, j)`
- `swap(A,i,hi)`
- `return i`

**swap**
- prohod√≠ prvky

![](../../Assets/Pasted%20image%2020250321134512.png)

Tags: otazka14
<!--ID: 1746599653605-->
END

---


START
FIT-Card

Jak funguje **Lomutova varianta** partitioningu v QuickSortu?

Back:

![](../../Assets/Pasted%20image%2020250321134544.png)

![](../../Assets/Pasted%20image%2020250321134556.png)

Tags: otazka14
<!--ID: 1746599653613-->
END

---


START
FIT-Card

Jak se d√° **paralelizovat quicksort**? Jak√© to m√° probl√©my?

Back:

Pomoc√≠ funkƒçn√≠ho paralelismu - `task` nad obƒõ vƒõtve rekurzvn√≠ho vol√°n√≠

Probl√©my: mnoho vl√°ken, velk√° re≈æie, rozdƒõlen√≠ vstupn√≠ho pole je st√°le sekvenƒçn√≠

![](../../Assets/Pasted%20image%2020250321134624.png)

Tags: otazka14
<!--ID: 1746599653621-->
END

---


START
FIT-Card

Jak√© jsou dal≈°√≠ verze quicksortu?

Back:

- SGNU - sekvenƒçn√≠ z knihovny Libstdc++
- PGNU - paraleln√≠ z knihovky Libstdc++
- SUV - sekvenƒçn√≠ "uƒçebnicov√Ω"
- PUV - p√∫araleln√≠ "uƒçebnicov√Ω"
<!--ID: 1746599653629-->
END

---


START
FIT-Card

Jak√© je srovn√°n√≠ SGNU, PGNU, SUV, PUV?

Back:

![](../../Assets/Pasted%20image%2020250321134817.png)
<!--ID: 1746599653637-->
END

---


START
FIT-Card

Proƒç je PUV v√Ωraznƒõ pomalej≈°√≠ ne≈æ PGNU?

Back:

![](../../Assets/Pasted%20image%2020250321134849.png)
<!--ID: 1746599653646-->
END

---


START
FIT-Card

Jak se d√° PUV zlep≈°it? (3)

Back:

![](../../Assets/Pasted%20image%2020250321134900.png)

- Koncov√° rekurze - je to "zadarmo", staƒç√≠ jen p≈ôeuspo≈ô√°dat k√≥d
- Zaveden√≠ prahu - ke konci rekurze nem√° cenu to poƒç√≠tat rekurzivnƒõ
<!--ID: 1746599653653-->
END

---


START
FIT-Card

Jak lze zrychlit quicksort?

Back:

- **tail call optimization** (viz d√°le)
- **zaveden√≠ prahu pro vytv√°≈ôen√≠ task≈Ø** (viz d√°le)
- **paralelizace algoritmu rozdƒõlov√°n√≠** (viz d√°le)
- **p≈ôibl√≠≈æen√≠ pivota bl√≠zko medi√°nu** (nap≈ô. v√Ωbƒõrem medi√°nu z n√°hodn√©ho vzorku)
- **rozdƒõlen√≠ poƒçtu vl√°ken** na levou a pravou pod√∫lohu podle velikosti pod√∫loh

Tags: otazka14
<!--ID: 1749202568493-->
END

---


START
FIT-Card

Jak funguje **Tail call optimization** (TCO) u quicksortu? Jak√© slo≈æitosti t√≠m doc√≠l√≠me?

Back:

QuickSort lze zrychlit nahrazen√≠m druh√©ho rekurzivn√≠ho vol√°n√≠ iterac√≠ ve `while`

- U≈°et≈ô√≠me poƒçet rekurzivn√≠ch vol√°n√≠ a tedy poƒçet vytv√°≈ôen√Ωch task≈Ø
- Pokud je pivot skoromedi√°n, sn√≠≈æ√≠me poƒçet rekurzivn√≠ch vol√°n√≠ z $O(n)$ na $O(\log n)$

![](../../Assets/Pasted%20image%2020250321134952.png)

Tags: otazka14
<!--ID: 1746599653660-->
END

---


START
FIT-Card

Jak funguje **Prahov√°n√≠ task paralelismu** (ST) u quicksortu?

Back:

nap≈ô. pokud je nese≈ôazen√Ωch ƒç√≠sel m√≠≈à ne≈æ $n/kp$, dopoƒç√≠t√°me zbytek sekvenƒçnƒõ v aktu√°ln√≠ √∫loze m√≠sto vytv√°≈ôen√≠ nov√Ωch

![](../../Assets/Pasted%20image%2020250321135010.png)
![](../../Assets/Pasted%20image%2020250321135017.png)

Tags: otazka14
<!--ID: 1746599653667-->
END

---


START
FIT-Card

Jak funguje **Paralelizovan√© rozdƒõlov√°n√≠ u quicksortu**? Jak√© jsou p≈ôedpoklady?

Back:

P≈ôedpoklady:
- Hod√≠ se na to **Hoareova** varianta quicksortu (neutralizace z obou stran) ne≈æ Lomutova
- vy≈æaduje vno≈ôen√Ω OpenMP paralelismus (`omp_set_max_active_levels na v√≠c ne≈æ 1`)

Jak funguje:
- indexy lev√©ho a prav√©ho prvku (`i`, `j`) budou sd√≠len√© promƒõnn√©, ka≈æd√© vl√°kno si od nich opakovanƒõ odvozuje lok√°ln√≠ `my_i` a `my_j` a n√°rokuje si tak dvojici prvk≈Ø pro sebe
    - pro p≈ôeƒçten√≠ a in/dekrementaci `i` a `j` je nutn√Ω `atomic capture`
- to ale vede na ob≈ô√≠ re≈æii s `atomic` a fale≈°n√© sd√≠len√≠, tak≈æe je lep≈°√≠ si m√≠sto prvk≈Ø n√°rokovat cel√© disjunktn√≠ bloky (tzn. in/dekrementovat indexy o $K$ m√≠sto o $1$)
- na konci smyƒçky je pot≈ôeba `barrier`, pak neutralizace zb√Ωvaj√≠c√≠ch (max. $p$) blok≈Ø a nakonec sekvenƒçn√≠ √∫klid posledn√≠ho ≈°pinav√©ho bloku
- pivota neodkl√°d√°me stranou jako u neblokov√© varianty, jen si zapamatujeme hodnotu


![](../../Assets/Pasted%20image%2020250321135035.png)

Tags: otazka14
<!--ID: 1746599653679-->
END

---


START
FIT-Card

Jak vypad√° Hoareova varianta quicksortu (partitioningu)?

(tohle tu≈°it jen obecnƒõ)

Back:

todo shrnout obecnƒõ

![](../../Assets/Pasted%20image%2020250321135059.png)
![](../../Assets/Pasted%20image%2020250321135107.png)

Tags: otazka14
<!--ID: 1746599653687-->
END

---


START
FIT-Card

Jak se d√° optimalizovat quicksort optimalizac√≠ po≈ôad√≠ vyhodnocen√≠ podm√≠nek?

(tohle je v optimalizaci trochu detail)

Back:

![](../../Assets/Pasted%20image%2020250321135205.png)
<!--ID: 1746599653696-->
END

---


START
FIT-Card

Jak lze paralelizovat quicksort algoritmus (Hoareova)?

Back:

Pozn. vl√°kna mi budou zpracov√°vat r≈Øzn√© ƒç√°sti toho pole je velice d≈Øle≈æit√Ω, abych si pohl√≠dal, aby mi nezpracov√°vali danou dvojici ƒç√≠sel najednou, jinak by do≈°lo ke kolizi.

Hlavn√≠ my≈°lenka:
- Budeme m√≠t glob√°ln√≠ i a j a v≈ædy kdy≈æ si nƒõjak√© vl√°kno naƒçte tyto prvky, updatne indexy tak, aby to u≈æ neƒçetlo jin√© vl√°kno
	- ≈Ω√°dn√° dvƒõ vl√°kna nesm√≠ m√≠t stejn√Ω 

![](../../Assets/Pasted%20image%2020250321135234.png)
![](../../Assets/Pasted%20image%2020250321135241.png)

<!-- DetailInfoStart -->
![](../../Assets/Pasted%20image%2020250321135251.png)
![](../../Assets/Pasted%20image%2020250321135304.png)
<!-- DetailInfoEnd -->
<!--ID: 1746599653704-->
END

---


START
FIT-Card

Proƒç nen√≠ tento quicksort algoritmus korektn√≠?
![](../../Assets/Pasted%20image%2020250321135323.png)

Back:

Mus√≠me zajistit, aby zapisov√°n√≠ do sd√≠len√Ωch promƒõnn√Ωch bylo atomick√©.

![](../../Assets/Pasted%20image%2020250321135328.png)
![](../../Assets/Pasted%20image%2020250321135341.png)
![](../../Assets/Pasted%20image%2020250321135347.png)
<!--ID: 1746599653713-->
END

---


START
FIT-Card

Proƒç je algoritmus par_partition_2 neefektivn√≠?

Back:

Proto≈æe se tam furt lockuj√≠ ty glob√°ln√≠ promƒõnn√© - volaj√≠ se stovky atomic capute. Ta re≈æie je ob≈ô√≠.

Kdy≈æ u≈æ si nƒõjak√© vl√°kno "vysoutƒõ≈æ√≠" p≈ô√≠stup k t√© sd√≠len√© pamƒõti, tak jim ned√°me jeden prvek, ale rovnou $K$ prvk≈Ø, a≈• m≈Ø≈æe chv√≠li pracovat a nejde zase do t√© pamƒõti.

![](../../Assets/Pasted%20image%2020250321135415.png)
<!--ID: 1746599653720-->
END

---


START
FIT-Card

Jak funguje sekvenƒçn√≠ neutralizace 2 blok≈Ø Hoareova QuickSortu?

Back:

![](../../Assets/Pasted%20image%2020250321135447.png)
![](../../Assets/Pasted%20image%2020250321135456.png)

<!-- ExampleStart -->
![](../../Assets/Pasted%20image%2020250321135506.png)
<!-- ExampleEnd -->
<!--ID: 1746599653729-->
END

---


START
FIT-Card

Jak se u paraleln√≠ho QuickSortu vyb√≠r√° pivot?

Back:

![](../../Assets/Pasted%20image%2020250321135529.png)
<!--ID: 1746599653738-->
END

---


START
FIT-Card

Jak se u paraleln√≠ho quicksortu dƒõl√° vyva≈æov√°n√≠?

Back:

![](../../Assets/Pasted%20image%2020250321135542.png)
<!--ID: 1746599653746-->
END

---


START
FIT-Card

Je paraleln√≠ rozdƒõlov√°n√≠ slo≈æit√° √∫loha?

Back:

![](../../Assets/Pasted%20image%2020250321135643.png)

<!-- DetailInfoStart -->
![](../../Assets/Pasted%20image%2020250321135653.png)
<!-- DetailInfoEnd -->
<!--ID: 1746599653752-->
END

---


START
FIT-Card

Jak√© je srovn√°n√≠ QuickSort implementac√≠?

Back:

![](../../Assets/Pasted%20image%2020250321135653.png)
<!--ID: 1746599653760-->
END

---

### Merge Sort


START
FIT-Card

Jak√© vlastnosti m√° MergeSort? (3)

Back:

- **Datovƒõ necitliv√Ω**
- **Out of place**
- **Stabiln√≠**

<!-- DetailInfoStart -->
![](../../Assets/Pasted%20image%2020250321134112.png)
<!-- DetailInfoEnd -->

Tags: otazka15
<!--ID: 1746599653597-->
END

---

START
FIT-Card

Jak vypad√° uƒçebnicov√° verze Merge Sortu? (SUV)

Back:

M√°me pole $A$ d√©lky $n$

**mergesort**
- Inicializuje pole $B[n]$ na hodnoty $A$ƒçka
- sput√≠ `mergesort_rec(B,0,n,A);`

**mergesort_rec**
- konec rekurze `if((hi-lo) <2) return;`
- spoƒçten√≠ prost≈ôedku `long middle = (hi+lo)/2`
- zavol√°n√≠ na levou ƒç√°st `mergesort_rec(A, lo, middle, B)`
- zavol√°n√≠ na levou ƒç√°st `mergesort_rec(A, middle, hi, B)`
- merge `merge(B, lo, middle, hi, A)`

**merge** (2-cestn√© sluƒçov√°n√≠)
- `i = lo; j = middle`
- iterujeme $k$ mezi `lo..hi`
	- V≈ædy p≈ôi≈ôazujeme jako prvn√≠ men≈°√≠ prvek
	- 1) P≈ôi≈ôazen√≠ prvku z prvn√≠ ƒç√°sti (pokud jsme vypl√Ωtvali prav√© pole nebo je prvek men≈°√≠):
	- `if((i<middle) && ((j >= hi) || (B[i] <= B[j]))) A[k] = B[i++];`
	- `else A[k] = B[j++];`

![](../../Assets/Pasted%20image%2020250321135717.png)

Tags: otazka15
<!--ID: 1746599653768-->
END

---


START
FIT-Card

Jak vypad√° **p≈ô√≠moƒçar√° (naivn√≠) paralelizace merge sortu**? (PUV)

Back:

Uvnit≈ô **mergesort**
- P≈ôed cykly `#pragma omp parallel`
- P≈ôed for `#pragma omp for`
- P≈ôed `mergesort_rec` d√°me `#pragma omp single`

Uvnit≈ô **mergesort_rec**:
- P≈ôed `mergesort_rec` d√°me `#pragma omp task`
- P≈ôed `seq_merge` d√°me `#pragma omp taskwait`

![](../../Assets/Pasted%20image%2020250321135735.png)

Tags: otazka15
<!--ID: 1746599653777-->
END

---


START
FIT-Card

Proƒç u MergeSortu nefunguje **naivn√≠ funkƒçn√≠ paralelizace**?

Back:

- `taskwait` ƒçek√° na podvl√°kna a tƒõ≈æk√° pr√°ce je a≈æ za t√≠m
- **vytv√°≈ô√≠ se ob≈ô√≠ mno≈æstv√≠ task≈Ø**, kter√© v listech sluƒçuj√≠ **dvouprvkov√° pole**
- **obrovsk√© fale≈°n√© sd√≠len√≠**

Kv≈Øli tomu je to **n√°sobnƒõ pomalej≈°√≠** (t≈ôeba 14 kr√°t) ne≈æ v≈Øbec **sekvenƒçn√≠ verze**

<!-- DetailInfoStart -->
![](../../Assets/Pasted%20image%2020250321135825.png)
<!-- DetailInfoEnd -->

Tags: otazka15
<!--ID: 1749235012461-->
END

---


START
FIT-Card

Jak√© je srovn√°n√≠ QuickSortu a MergeSortu a jejich verz√≠?

Back:

![](../../Assets/Pasted%20image%2020250321135825.png)
<!--ID: 1746599653784-->
END

---


START
FIT-Card

Jak funguje obecnƒõ QuickSort PUV?

Back:

![](../../Assets/Pasted%20image%2020250321135845.png)
<!--ID: 1746599653794-->
END

---


START
FIT-Card

Jak funguje obecnƒõ MergeSort PUV?

Back:

![](../../Assets/Pasted%20image%2020250321135857.png)
<!--ID: 1746599653802-->
END

---


START
FIT-Card

Co je d≈Øsledek toho jak funguje QuickSort a MergeSort?

Back:

![](../../Assets/Pasted%20image%2020250321135913.png)
<!--ID: 1746599653810-->
END

---


START
FIT-Card

Jak√© jsou 3 mo≈ænosti zlep≈°en√≠ paraleln√≠ho MergeSortu?

Back:

- **zaveden√≠m prahu** (stejnƒõ jako u quicksortu)
- **vytv√°≈ôen√≠m nov√© √∫lohy jen pro levou polovinu** ("rozdƒõl a p≈Ølku si nech")
- **paralelizac√≠ algoritmu dvoucestn√©ho sluƒçov√°n√≠** (viz d√°le)

<!-- DetailInfoStart -->
![](../../Assets/Pasted%20image%2020250321135945.png)
<!-- DetailInfoEnd -->

Tags: otazka15
<!--ID: 1746599653817-->
END

---


START
FIT-Card

Jak funguje MergeSort s metodou "**Prahov√°n√≠ a Rozdƒõl-a-P≈ØlkuSiNech**"?

Back:

Prahov√°n√≠ - M√≠sto p≈Øvodn√≠ koncov√© podm√≠nky d√°me:
- `if((hi-lo) < threshold)`
	- `seq_mergesort_Rec(B, lo, hi,A)`
	- `return`

Rozdƒõl a p≈Ølku si nech:
- `#pragma omp task` d√°me pouze p≈ôed lev√Ω `par_merge_sort_rec`

![](../../Assets/Pasted%20image%2020250321140019.png)
Tags: otazka15
<!--ID: 1746599653827-->
END

---


START
FIT-Card

Jak√© je srovn√°n√≠ PUV+ST a PUV merge sortu?

Back:

![](../../Assets/Pasted%20image%2020250321140042.png)
<!--ID: 1746599653835-->
END

---


START
FIT-Card

Jak se d√° u merge sortu paralelizovat operace `seq_merge`?

Back:

![](../../Assets/Pasted%20image%2020250321140112.png)
<!--ID: 1746599653843-->
END

---


START
FIT-Card

Jak funguje paralelizace algoritmu **2-cestn√©ho** sluƒçov√°n√≠ u MergeSortu? 

Back:

todo p≈ôepsat tak, aby mi to d√°valo smysl

1. sluƒçovan√° se≈ôazen√° pole $C, D$ d√©lky $n/2$ si p≈ôedstavme jako ≈ô√°dkov√© a sloupcov√© indexy matice, v n√≠≈æ jsou jedniƒçky tam, kde sloupcov√Ω index $>$ ≈ô√°dkov√Ω, jinde nuly
2. v≈°echny jedniƒçky jsou v prav√©m horn√≠m rohu, od nul je dƒõl√≠ lomen√° ƒç√°ra (na obr√°zku tlust√° modr√°)
3. ka≈æd√© vl√°kno si najde sv≈Øj pr≈Øseƒç√≠k t√©to lomen√© ƒç√°ry s $p-1$ vedlej≈°√≠mi diagon√°lami matice (bin√°rn√≠m dƒõlen√≠m v ƒçase $O(\log n)$) rozm√≠stƒõn√Ωmi ve vzd√°lenosti $n/2p$ od sebe
4. pr≈Øseƒç√≠ky prom√≠tneme (horizont√°lnƒõ/vertik√°lnƒõ) na strany matice a podle toho rozkouskujeme $C$ i $D$ na $p$ ƒç√°st√≠ (oznaƒçen√Ωch nap≈ô. $C_1$ a≈æ $C_p$ resp. $D_1$ a≈æ $D_p$)
5. $i$-t√© vl√°kno sekvenƒçnƒõ mergne $C_i$ a $D_i$, ƒç√≠m≈æ vznikne $X_i$
6. z≈ôetƒõzme $X_1 \dots X_p$ ‚Üí m√°me se≈ôazen√© pole

![](../../Assets/Pasted%20image%2020250606202744.png)

<!-- DetailInfoStart -->
![](../../Assets/Pasted%20image%2020250321140150.png)
![](../../Assets/Pasted%20image%2020250321140158.png)
![](../../Assets/Pasted%20image%2020250321140204.png)
<!-- DetailInfoEnd -->

Tags: otazka15
<!--ID: 1746599653850-->
END

---


START
FIT-Card

Jak√° je u paraleln√≠ho 2-cestn√©ho sluƒçov√°n√≠ merge sortu slo≈æitost najit√≠ vlastn√≠ho pr≈Øseƒç√≠ku? Jak√Ωm algoritmem se to hled√°?

Back:

Alogirmem **bin√°rn√≠ dƒõlen√≠**:
$$O(\log n)$$
Tags: otazka15
<!--ID: 1749286664601-->
END

---



START
FIT-Card

Jak funguje **merge sort** s $p$-cestn√Ωm paraleln√≠m sluƒçov√°n√≠m? (obecn√° my≈°lenka)

Back:

**My≈°lenka:**
1. Rozsek√°me vstupn√≠ pole na $n/p$ stejnƒõ velk√Ωch ƒç√°st√≠ $S_1 \dots S_p$
2. Ka≈æd√© vl√°kno sekvenƒçnƒõ se≈ôad√≠ svoji ƒç√°st $S_i$ ($O(\frac n p \log \frac n p)$)
3. Potom zaƒçne $p$-cestn√© sluƒçov√°n√≠

**p-cestn√© sluƒçov√°n√≠**
Funguje podobnƒõ jako 2-cestn√©, ale obecnƒõji:
1. Ka≈æd√© vl√°kno si najde **pole rozdƒõlovaƒç≈Ø** pomoc√≠ `Splitters_by_Rank(S, my_id*n/p)`
2. Na z√°kladƒõ rozdƒõlovaƒç≈Ø si do pomocn√©ho pole (v `my_tuple[my_id]`) nahraje √∫seky z $S_0 \dots S_1$ (na obr√°zku jsou √∫seky oznaƒçeny $\tau_i$)
3. Do pole $B$ pak na danou pozici nahraje sekvenƒçnƒõ mergnut√© pomocn√© pole (merge je jako norm√°ln√≠, ale nemergujou se 2 pole, ale p pol√≠)

![](../../Assets/Pasted%20image%2020250606203342.png)

<!-- DetailInfoStart -->
4. Ka≈æd√© vl√°kno si stejnƒõ jako u 2-cestn√©ho najde **rozdƒõlovaƒç** (tam to byly ty pr≈Øseƒç√≠ky s lomennou ƒç√°rou), kter√Ω mi v ka≈æd√©m poli $S_1 \dots S_p$ oznaƒç√≠ ƒç√°st $\tau_i$, kterou bude $i$-t√© vl√°kno zpracov√°vat. Zde bude rozdƒõlovaƒç **vektor** bod≈Ø v poli(to jsou jakoby pr≈Ømƒõty toho rozdƒõlovaƒçe do tƒõch ƒç√°st√≠ pole). To najde funkce `Splitters_by_Rank(S,my_id*n/p)`.
	- Tyto ƒç√°sti $\tau_i$ jsou pro ka≈æd√© vl√°kno **stejnƒõ velk√©**.
	- Pro v≈°echny prvky $\tau_i$ plat√≠, ≈æe jsou men≈°√≠ ne≈æ $\tau_{i-1}$ (d√≠ky tomu a≈æ slijeme pole tak bude opƒõt se≈ôazen√©)
5. Ka≈æd√© vl√°kno pak sekvenƒçnƒõ slouƒç√≠ v≈°echny svoje ƒç√°sti v $\tau_i$
6. Tyto ƒç√°sti pak d√°me za sebe a z√≠sk√°me se≈ôazen√© pole

Podrobnƒõj≈°√≠ vysvƒõtlen√≠:
1. vstupn√≠ pole se roz≈ôez√° na pravideln√© $p$-tiny
2. ka≈æd√© vl√°kno sekvenƒçnƒõ se≈ôad√≠ svoji $p$-tinu ($O(\frac n p \log \frac n p)$)
3. ka≈æd√© vl√°kno vypoƒç√≠t√° sv≈Øj vektor rozdƒõlovaƒç≈Ø (jeden rozdƒõlovaƒç v ka≈æd√© se≈ôazen√© $p$-tinƒõ) pomoc√≠ $\log n$ proveden√≠ $p$ instanc√≠ bin√°rn√≠ho vyhled√°v√°n√≠ ($O(p \log \frac n p \log n)$), funkce `Splitters_by_Rank(S,my_id*n/p)`
4. ka≈æd√© vl√°kno si z ka≈æd√© $p$-tiny vy≈ô√≠zne jeden √∫sek mezi sv√Ωm a sousedn√≠m rozdƒõlovaƒçem
5. ka≈æd√© vl√°kno $p$-cestnƒõ slouƒç√≠ sv√Ωch $p$ √∫sek≈Ø do vyhrazen√© ƒç√°sti v√Ωstupu ($O(\frac n p \log p)$)
- pro mal√° $p$ a velk√° $n$ slo≈æitostnƒõ dominuje krok 2 ‚Üí celkov√° slo≈æitost je $O(\frac n p \log \frac n p)$
- na konci krok≈Ø 2 a 3 na sebe mus√≠ vl√°kna poƒçkat (`barrier`)

![](../../Assets/Pasted%20image%2020250321140228.png)
![](../../Assets/Pasted%20image%2020250321140233.png)
![](../../Assets/Pasted%20image%2020250321140238.png)
<!-- DetailInfoEnd -->

Tags: otazka16
<!--ID: 1746599653860-->
END

---


START
FIT-Card

Jak√° je slo≈æitost u paraleln√≠ho p-cestn√©ho MergeSortu?

Back:

- Ka≈æd√© vl√°kno se≈ôad√≠ svoje pole $(O(\frac n p \log \frac n p))$
- Ka≈æd√© vl√°kno provede SplittersByRank $O(p \log \frac n p \log n)$
- Ka≈æd√© vl√°kno p-cestnƒõ slouƒç√≠ v√Ωsledn√° pole $O(\frac n p \log p)$

$$T(n,p) = O\left( \frac n p \log \frac n p + p \log \frac n p \log n + \frac n p \log p \right)$$

Pro mal√° $p$ a velk√° $n$ dominuje √∫vodn√≠ se≈ôazen√≠ a celkov√° slo≈æitost je $O(\frac n p \log \frac n p)$

Tags: otazka16
<!--ID: 1749235012473-->
END

---


START
FIT-Card

Jak funguje **merge sort** s $p$-cestn√Ωm paraleln√≠m sluƒçov√°n√≠m? (konkr√©tn√≠ implementace)

Back:

Vstup: pole $A$, d√©lka $n$

Implementace:
1. Alokujeme `B[n]`, `splitters[p][p]`, `my_tuple[p][n/p]`, `S[p][n/p]`
2. `#pragma omp parallel`
3. Z√≠sk√°me $S_i$ `S[my_id] = A[my_id*n/p .. (my_id+1)*n/p-1]`
4.  Sekvenƒçnƒõ sesort√≠me `S[my_id]`
5. `#pragma omp barrier`
6. Z√≠sk√°me splitters `splitters[my_id] = Splitters_By_Rank(S, my_id*n/p)`
7. `#pragma omp barrier`
8. `my_tuple[my_id]` p≈ôi≈ôad√≠me subarrays
9. Na ka≈æd√Ω `my_tuple` se provede sekvenƒçn√≠ $p$-cestn√Ω merge

![](../../Assets/Pasted%20image%2020250321140737.png)
![](../../Assets/Pasted%20image%2020250321140742.png)
![](../../Assets/Pasted%20image%2020250321140747.png)

Tags: otazka16
<!--ID: 1746599653868-->
END

---


START
FIT-Card

Jak u $p$-cestn√©ho MergeSortu funguje `Splitters_by_Rank`?

Back:

Vstup:
- cel√© se≈ôazen√© sd√≠len√© pole $A$
- rank - index, kde zaƒç√≠n√° √∫sek $S_i$ v se≈ôazen√©m poli
	- `rank = my_id*n/p`

V√Ωstup:
- vektor $p$ rozdƒõlovaƒç≈Ø, kde poƒçet prvk≈Ø nalevo od nich je p≈ôesnƒõ rovno `rank`

Implementace:
1. Pole $L[p],R[p]$
2. **Inicializace** - Iterujeme $i$ mezi $0\dots p$
	1. `L[i]=0; R[i]=n/p-1`
		- Tzn. v≈°echny `L[i]` nastav√≠me na nulu, v≈°echny `R[i]` na konec t√© ƒç√°sti pole $S_i$
3. `while exists i: L[i] < R[i]` (tzn. je tam je≈°tƒõ nƒõjak√Ω prostor nejistoty)
	1. $v$ = random pivot (elemet) v moment√°ln√≠m ohraniƒçen√≠ $L[i] \dots R[i]$
	2. v≈ædy zu≈æuju
	3. `for` - pro ka≈ædou sekci $S_i$
		- V ka≈æd√© sekci $S_i$ najdeme m√≠sto, kde jsou ƒç√≠sla men≈°√≠ ne≈æ pivot a napravo vƒõt≈°√≠ nebo rovno ne≈æ pivot. To ulo≈æ√≠me do `m[i]`
		- Tato ƒç√≠sla `m[i]` spoƒç√≠t√°m pro v≈°echny $S_i$ a seƒçtu je. Souƒçet porovn√°m s `rank`.
		- Kdy≈æ je to vƒõt≈°√≠ ne≈æ `rank`, tak nastavim `R[i] = m[i]`
		- Kdy≈æ je to men≈°√≠ ne≈æ `rank`, tak nastavim `L[i] = m[i]`
		- D√≠ky tomu posouv√°m takhle ty hranice dokud nedos√°hnu p≈ôesnƒõ toho ranku.
- Vr√°t√≠m vektor splitter≈Ø `L[0],...,L[p-1]`

![](../../Assets/Pasted%20image%2020250606203608.png)
![](../../Assets/Pasted%20image%2020250606203615.png)

Tags: otazka16
<!--ID: 1749235012476-->
END

---


START
FIT-Card

Jak√© je srovn√°n√≠ Merge sort implementac√≠?

Back:

![](../../Assets/Pasted%20image%2020250321140811.png)
<!--ID: 1746599653876-->
END

---
